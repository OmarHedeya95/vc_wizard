/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/python-shell/index.js
var require_python_shell = __commonJS({
  "node_modules/python-shell/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PythonShell = exports.NewlineTransformer = exports.PythonShellError = void 0;
    var events_1 = require("events");
    var child_process_1 = require("child_process");
    var os_1 = require("os");
    var path_1 = require("path");
    var stream_1 = require("stream");
    var fs_1 = require("fs");
    var util_1 = require("util");
    function toArray(source) {
      if (typeof source === "undefined" || source === null) {
        return [];
      } else if (!Array.isArray(source)) {
        return [source];
      }
      return source;
    }
    function extend(obj, ...args) {
      Array.prototype.slice.call(arguments, 1).forEach(function(source) {
        if (source) {
          for (let key in source) {
            obj[key] = source[key];
          }
        }
      });
      return obj;
    }
    function getRandomInt() {
      return Math.floor(Math.random() * 1e10);
    }
    var execPromise = (0, util_1.promisify)(child_process_1.exec);
    var PythonShellError = class extends Error {
    };
    exports.PythonShellError = PythonShellError;
    var NewlineTransformer = class extends stream_1.Transform {
      _transform(chunk, encoding, callback) {
        let data = chunk.toString();
        if (this._lastLineData)
          data = this._lastLineData + data;
        const lines = data.split(os_1.EOL);
        this._lastLineData = lines.pop();
        lines.forEach(this.push.bind(this));
        callback();
      }
      _flush(done) {
        if (this._lastLineData)
          this.push(this._lastLineData);
        this._lastLineData = null;
        done();
      }
    };
    exports.NewlineTransformer = NewlineTransformer;
    var PythonShell = class extends events_1.EventEmitter {
      constructor(scriptPath, options, stdoutSplitter = null, stderrSplitter = null) {
        super();
        function resolve(type, val) {
          if (typeof val === "string") {
            return PythonShell[type][val];
          } else if (typeof val === "function") {
            return val;
          }
        }
        if (scriptPath.trim().length == 0)
          throw Error("scriptPath cannot be empty! You must give a script for python to run");
        let self = this;
        let errorData = "";
        events_1.EventEmitter.call(this);
        options = extend({}, PythonShell.defaultOptions, options);
        let pythonPath2;
        if (!options.pythonPath) {
          pythonPath2 = PythonShell.defaultPythonPath;
        } else
          pythonPath2 = options.pythonPath;
        let pythonOptions = toArray(options.pythonOptions);
        let scriptArgs = toArray(options.args);
        this.scriptPath = (0, path_1.join)(options.scriptPath || "", scriptPath);
        this.command = pythonOptions.concat(this.scriptPath, scriptArgs);
        this.mode = options.mode || "text";
        this.formatter = resolve("format", options.formatter || this.mode);
        this.parser = resolve("parse", options.parser || this.mode);
        this.stderrParser = resolve("parse", options.stderrParser || "text");
        this.terminated = false;
        this.childProcess = (0, child_process_1.spawn)(pythonPath2, this.command, options);
        ["stdout", "stdin", "stderr"].forEach(function(name) {
          self[name] = self.childProcess[name];
          self.parser && self[name] && self[name].setEncoding(options.encoding || "utf8");
        });
        if (this.parser && this.stdout) {
          if (!stdoutSplitter)
            stdoutSplitter = new NewlineTransformer();
          stdoutSplitter.setEncoding(options.encoding || "utf8");
          this.stdout.pipe(stdoutSplitter).on("data", (chunk) => {
            this.emit("message", self.parser(chunk));
          });
        }
        if (this.stderrParser && this.stderr) {
          if (!stderrSplitter)
            stderrSplitter = new NewlineTransformer();
          stderrSplitter.setEncoding(options.encoding || "utf8");
          this.stderr.pipe(stderrSplitter).on("data", (chunk) => {
            this.emit("stderr", self.stderrParser(chunk));
          });
        }
        if (this.stderr) {
          this.stderr.on("data", function(data) {
            errorData += "" + data;
          });
          this.stderr.on("end", function() {
            self.stderrHasEnded = true;
            terminateIfNeeded();
          });
        } else {
          self.stderrHasEnded = true;
        }
        if (this.stdout) {
          this.stdout.on("end", function() {
            self.stdoutHasEnded = true;
            terminateIfNeeded();
          });
        } else {
          self.stdoutHasEnded = true;
        }
        this.childProcess.on("error", function(err) {
          self.emit("error", err);
        });
        this.childProcess.on("exit", function(code, signal) {
          self.exitCode = code;
          self.exitSignal = signal;
          terminateIfNeeded();
        });
        function terminateIfNeeded() {
          if (!self.stderrHasEnded || !self.stdoutHasEnded || self.exitCode == null && self.exitSignal == null)
            return;
          let err;
          if (self.exitCode && self.exitCode !== 0) {
            if (errorData) {
              err = self.parseError(errorData);
            } else {
              err = new PythonShellError("process exited with code " + self.exitCode);
            }
            err = extend(err, {
              executable: pythonPath2,
              options: pythonOptions.length ? pythonOptions : null,
              script: self.scriptPath,
              args: scriptArgs.length ? scriptArgs : null,
              exitCode: self.exitCode
            });
            if (self.listeners("pythonError").length || !self._endCallback) {
              self.emit("pythonError", err);
            }
          }
          self.terminated = true;
          self.emit("close");
          self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);
        }
        ;
      }
      static checkSyntax(code) {
        return __awaiter(this, void 0, void 0, function* () {
          const randomInt = getRandomInt();
          const filePath = (0, os_1.tmpdir)() + path_1.sep + `pythonShellSyntaxCheck${randomInt}.py`;
          const writeFilePromise = (0, util_1.promisify)(fs_1.writeFile);
          return writeFilePromise(filePath, code).then(() => {
            return this.checkSyntaxFile(filePath);
          });
        });
      }
      static getPythonPath() {
        return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;
      }
      static checkSyntaxFile(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
          const pythonPath2 = this.getPythonPath();
          let compileCommand = `${pythonPath2} -m py_compile ${filePath}`;
          return execPromise(compileCommand);
        });
      }
      static run(scriptPath, options, callback) {
        let pyshell = new PythonShell(scriptPath, options);
        let output = [];
        return pyshell.on("message", function(message) {
          output.push(message);
        }).end(function(err) {
          return callback(err ? err : null, output.length ? output : null);
        });
      }
      static runString(code, options, callback) {
        const randomInt = getRandomInt();
        const filePath = os_1.tmpdir + path_1.sep + `pythonShellFile${randomInt}.py`;
        (0, fs_1.writeFileSync)(filePath, code);
        return PythonShell.run(filePath, options, callback);
      }
      static getVersion(pythonPath2) {
        if (!pythonPath2)
          pythonPath2 = this.getPythonPath();
        return execPromise(pythonPath2 + " --version");
      }
      static getVersionSync(pythonPath2) {
        if (!pythonPath2)
          pythonPath2 = this.getPythonPath();
        return (0, child_process_1.execSync)(pythonPath2 + " --version").toString();
      }
      parseError(data) {
        let text = "" + data;
        let error;
        if (/^Traceback/.test(text)) {
          let lines = text.trim().split(os_1.EOL);
          let exception = lines.pop();
          error = new PythonShellError(exception);
          error.traceback = data;
          error.stack += os_1.EOL + "    ----- Python Traceback -----" + os_1.EOL + "  ";
          error.stack += lines.slice(1).join(os_1.EOL + "  ");
        } else {
          error = new PythonShellError(text);
        }
        return error;
      }
      send(message) {
        if (!this.stdin)
          throw new Error("stdin not open for writing");
        let data = this.formatter ? this.formatter(message) : message;
        if (this.mode !== "binary")
          data += os_1.EOL;
        this.stdin.write(data);
        return this;
      }
      end(callback) {
        if (this.childProcess.stdin) {
          this.childProcess.stdin.end();
        }
        this._endCallback = callback;
        return this;
      }
      kill(signal) {
        this.terminated = this.childProcess.kill(signal);
        return this;
      }
      terminate(signal) {
        return this.kill(signal);
      }
    };
    exports.PythonShell = PythonShell;
    PythonShell.defaultPythonPath = process.platform != "win32" ? "python3" : "python";
    PythonShell.defaultOptions = {};
    PythonShell.format = {
      text: function toText(data) {
        if (!data)
          return "";
        else if (typeof data !== "string")
          return data.toString();
        return data;
      },
      json: function toJson(data) {
        return JSON.stringify(data);
      }
    };
    PythonShell.parse = {
      text: function asText(data) {
        return data;
      },
      json: function asJson(data) {
        return JSON.parse(data);
      }
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VCWizardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var pythonPath = "";
var scriptPath_AI = "";
var affinityAPIKey = "";
var openaiAPIKey = "";
var owner_value = "10";
var connection_owner_field = "10";
var venture_network_list = "500";
async function summarize_selected_startup_text(editor, view) {
  const sel = editor.getSelection();
  let scriptPath = scriptPath_AI;
  const scriptName = "startup_summarizer_helper.py";
  var args = [sel, openaiAPIKey];
  new import_obsidian.Notice("Summarizing...");
  const summary = await launch_python(pythonPath, scriptPath, scriptName, args);
  let new_summary = String(summary);
  new_summary = new_summary.replace(/,-/g, "\n-");
  console.log(`The startup summary:
 ${new_summary}`);
  const replacement = "#gpt_summarized, #review_startup \n" + new_summary + "\n# Stop Indexing \n## Notes\n" + sel;
  editor.replaceSelection(replacement);
}
async function launch_python(pythonPath2, scriptPath, scriptName, args) {
  let { PythonShell } = require_python_shell();
  const options = { mode: "text", pythonPath: pythonPath2, scriptPath, args };
  const result = await new Promise((resolve, reject) => {
    PythonShell.run(scriptName, options, function(err, results) {
      if (err)
        throw err;
      return resolve(results);
    });
  });
  return result;
}
async function summarize_vc_text(text) {
  const scriptPath = scriptPath_AI;
  const scriptName = "vc_summarizer_helper.py";
  let [title, substrings] = extract_title_and_note(text);
  let text_to_summarize = substrings[0] + "\n" + substrings[1];
  console.log(`Summarizing: ${title}`);
  var args = ["Notes:\n" + text_to_summarize + "Summary:\n", openaiAPIKey];
  const summary = await launch_python(pythonPath, scriptPath, scriptName, args);
  let new_summary = String(summary);
  new_summary = new_summary.replace(/,-/g, "\n-");
  title = title.toString();
  let leading_text = "";
  let replacement = "";
  let tailing_text = "";
  if (substrings) {
    leading_text = substrings[0] + "\n" + title + "\n";
    for (let substring of substrings.slice(1)) {
      tailing_text = tailing_text + "\n" + substring;
    }
    replacement = leading_text + "#gpt_summarized, #review \n" + new_summary + "\n# Stop Indexing \n## Notes\n" + tailing_text;
    return [replacement, new_summary, title];
  } else {
    return [text, text, ""];
  }
}
function create_notice() {
  new import_obsidian.Notice("Nice to meet you!");
}
function extract_title_and_note(text) {
  let pattern = /^# .*\n/gm;
  let matches = text.match(pattern);
  let title = "";
  if (matches) {
    title = matches[0];
  }
  let substrings = text.split(pattern);
  console.log(`Title: ${title}`);
  console.log(substrings);
  return [title, substrings];
}
async function update_affinity(note, entity_name, scriptName) {
  const scriptPath = scriptPath_AI;
  if (scriptName == "affinity_vc_helper.py") {
    var args = [entity_name, note, affinityAPIKey, owner_value, connection_owner_field, venture_network_list];
  } else {
    var args = [entity_name, note, affinityAPIKey, owner_value];
  }
  console.log("Update Affinity");
  const response = await launch_python(pythonPath, scriptPath, scriptName, args);
  console.log(response);
  return response;
}
function vc_ready_for_affinity(file_content) {
  return file_content.includes("#gpt_summarized") && file_content.includes("#Affinity");
}
function startup_ready_for_affinity(file_content) {
  return file_content.includes("#startups/screened") && file_content.includes("#Affinity");
}
function notify_for_missing_people(person_name, response) {
  for (let item of response) {
    if (item.includes("Oops")) {
      new import_obsidian.Notice(`Person: ${person_name} was not found`, 36e3);
      return true;
    }
  }
  return false;
}
function notify_for_missing_startups(startup_name, response) {
  for (let item of response) {
    if (item.includes("Error")) {
      new import_obsidian.Notice(`Startup: ${startup_name} was found but could not be updated`, 36e3);
      return true;
    } else if (item.includes("Startup")) {
      new import_obsidian.Notice(`Startup: ${startup_name} could not be found`, 36e3);
      return true;
    }
  }
  return false;
}
async function push_vcs_to_affinity() {
  const files = this.app.vault.getMarkdownFiles();
  for (let item of files) {
    let file_content = await this.app.vault.read(item);
    if (vc_ready_for_affinity(file_content)) {
      let [title, substrings] = extract_title_and_note(file_content);
      let summary = substrings[1];
      let person_name = String(title);
      let scriptName = "affinity_vc_helper.py";
      let response = await update_affinity(summary, person_name, scriptName);
      if (!notify_for_missing_people(person_name, response)) {
        new import_obsidian.Notice(`VC: ${person_name} was updated on Affinity`);
        file_content = file_content.replace(/#Affinity/g, "");
        this.app.vault.modify(item, file_content);
      }
    }
  }
}
async function push_startups_to_affinity() {
  const files = this.app.vault.getMarkdownFiles();
  for (let item of files) {
    let file_content = await this.app.vault.read(item);
    if (startup_ready_for_affinity(file_content)) {
      let [title, substrings] = extract_title_and_note(file_content);
      let startup_name = String(title);
      let note = substrings[1];
      let scriptName = "affinity_startup_helper.py";
      let response = await update_affinity(note, startup_name, scriptName);
      if (!notify_for_missing_startups(startup_name, response)) {
        new import_obsidian.Notice(`Startup: ${startup_name} was updated on Affinity`);
        file_content = file_content.replace(/#Affinity/g, "");
        this.app.vault.modify(item, file_content);
      }
    }
  }
  new import_obsidian.Notice("Done!");
}
function is_summarizable(file_content) {
  return file_content.includes("#network/connected") && (file_content.includes("#Entity/VC") || file_content.includes("#Person/VC")) && file_content.includes("#gpt_summarized") != true && file_content.includes("dataview") != true;
}
var DEFAULT_SETTINGS = {
  vaultPath: "default",
  affinityKey: "default",
  openAIKey: "default",
  owner_person_value: "10",
  connection_owner_field_id: "100",
  venture_network_list_id: "500",
  pythonPath: "<path-to-virtual-env>"
};
var VCWizardPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("sun", "Omar Plugin", create_notice);
    this.addCommand({ id: "summarize-startup-command", name: "Summarize This Startup", editorCallback: (editor, view) => summarize_selected_startup_text(editor, view) });
    this.addCommand({ id: "summarize-all-vc-command", name: "Summarize All VC Notes", callback: () => this.summarize_all_vc() });
    this.addCommand({ id: "affinity-vc", name: "Push VCs to Affinity", callback: () => push_vcs_to_affinity() });
    this.addCommand({ id: "affinity-startup", name: "Push Startups to Affinity", callback: () => push_startups_to_affinity() });
    this.addSettingTab(new SampleSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    scriptPath_AI = this.settings.vaultPath + ".obsidian/plugins/vc_wizard";
    openaiAPIKey = this.settings.openAIKey;
    affinityAPIKey = this.settings.affinityKey;
    owner_value = this.settings.owner_person_value;
    connection_owner_field = this.settings.connection_owner_field_id;
    venture_network_list = this.settings.venture_network_list_id;
    pythonPath = this.settings.pythonPath;
  }
  async saveSettings() {
    await this.saveData(this.settings);
    scriptPath_AI = this.settings.vaultPath + ".obsidian/plugins/vc_wizard";
    openaiAPIKey = this.settings.openAIKey;
    affinityAPIKey = this.settings.affinityKey;
    owner_value = this.settings.owner_person_value;
    connection_owner_field = this.settings.connection_owner_field_id;
    venture_network_list = this.settings.venture_network_list_id;
    pythonPath = this.settings.pythonPath;
  }
  async summarize_all_vc() {
    const files = this.app.vault.getMarkdownFiles();
    for (let item of files) {
      let file_content = await this.app.vault.read(item);
      if (is_summarizable(file_content)) {
        console.log(`We are changing file: ${item.name}`);
        let [new_text, summary, title] = await summarize_vc_text(file_content);
        if (title != "") {
          this.app.vault.modify(item, new_text);
          new import_obsidian.Notice(`${title} has been summarized`);
        }
      }
    }
  }
};
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for your butler" });
    new import_obsidian.Setting(containerEl).setName("Obsidian Vault Path").setDesc("The path to the vault where you wish to use the plugin").addText((text) => text.setPlaceholder("Enter path").setValue(this.plugin.settings.vaultPath).onChange(async (value) => {
      console.log("path: " + value);
      this.plugin.settings.vaultPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API Key").addText((text) => text.setPlaceholder("Enter key").setValue(this.plugin.settings.openAIKey).onChange(async (value) => {
      console.log("Open AI key: " + value);
      this.plugin.settings.openAIKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Affinity: API Key").setDesc("Your Affinity API Key").addText((text) => text.setPlaceholder("Enter key").setValue(this.plugin.settings.affinityKey).onChange(async (value) => {
      console.log("key: " + value);
      this.plugin.settings.affinityKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Affinity: Owner Value").setDesc("Every person has a code on Affinity. Please give in the code for the person that should be added as owner of startups and VCs that gets pushed").addText((text) => text.setPlaceholder("Enter value").setValue(this.plugin.settings.owner_person_value).onChange(async (value) => {
      console.log("Owner value: " + value);
      this.plugin.settings.owner_person_value = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Affinity: Connection Owner Field ID").setDesc("Depending on the list you save fellow VCs in, there is a field that represent the 'connection owner with the fund', enter the field id here").addText((text) => text.setPlaceholder("Enter value").setValue(this.plugin.settings.connection_owner_field_id).onChange(async (value) => {
      console.log("Connection Owner Field ID value: " + value);
      this.plugin.settings.connection_owner_field_id = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Affinity: Venture Network List ID").setDesc("Please enter the list id for the list you save your relationships with VCs in").addText((text) => text.setPlaceholder("Enter value").setValue(this.plugin.settings.venture_network_list_id).onChange(async (value) => {
      console.log("Venture network list id: " + value);
      this.plugin.settings.venture_network_list_id = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Python Virtual Environment Path").setDesc("The path to python virtual environment").addText((text) => text.setPlaceholder("Enter path").setValue(this.plugin.settings.pythonPath).onChange(async (value) => {
      console.log("PythonPath: " + value);
      this.plugin.settings.pythonPath = value;
      await this.plugin.saveSettings();
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL3B5dGhvbi1zaGVsbC9pbmRleC50cyIsICJtYWluLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogW251bGwsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgTWFya2Rvd25WaWV3LCBNb2RhbCwgTm90aWNlLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIE1lbnUsIE1lbnVJdGVtLCBNYXJrZG93bkZpbGVJbmZvfSBmcm9tICdvYnNpZGlhbic7XG5cbmxldCBweXRob25QYXRoID0gJydcbmxldCBzY3JpcHRQYXRoX0FJID0gJydcbmxldCBhZmZpbml0eUFQSUtleSA9ICcnXG5sZXQgb3BlbmFpQVBJS2V5ID0gJydcbmxldCBvd25lcl92YWx1ZSA9ICcxMCdcbmxldCBjb25uZWN0aW9uX293bmVyX2ZpZWxkID0gJzEwJ1xubGV0IHZlbnR1cmVfbmV0d29ya19saXN0ID0gJzUwMCdcblxuXG5cbmFzeW5jIGZ1bmN0aW9uIHN1bW1hcml6ZV9zZWxlY3RlZF9zdGFydHVwX3RleHQoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlld3xNYXJrZG93bkZpbGVJbmZvKXtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIHRoZSBzZWxlY3RlZCB0ZXh0IGZyb20gYSBzdGFydHVwLCBzdW1tYXJpemVzIGl0LCBhbmQgdGhlbiBwdXRzIGl0IGJhY2sgaW4gdGhlIGZpbGVcbiAgICAgKiBUaGUgXCJmdWxsLXRleHRcIiBnZXRzIGFwcGVuZWQgYWZ0ZXIgdGhlIGhlYWRpbmcgJyMgU3RvcCBJbmRleGluZycgc3VjaCB0aGF0IGl0IGlzIG5vdCBpbmRleGVkIGFueW1vcmUgYnkgdGhlIGVtYmVkZGluZyBlbmdpbmVcbiAgICAgKiBUaGlzIGFsc28gaGVscHMgdG8gYXZvaWQgcHVzaGluZyBhbGwgb2YgdGhlIGNvbnZvbHV0ZWQgdGV4dCBpbnRvIEFmZmluaXR5IGxhdGVyIG9uXG4gICAgICovXG4gICAgY29uc3Qgc2VsID0gZWRpdG9yLmdldFNlbGVjdGlvbigpXG4gICAgLy9jb25zb2xlLmxvZyhgWW91ciBUZXh0OiAke3NlbH1gKVxuICAgIGxldCBzY3JpcHRQYXRoID0gc2NyaXB0UGF0aF9BSVxuICAgIGNvbnN0IHNjcmlwdE5hbWUgPSAnc3RhcnR1cF9zdW1tYXJpemVyX2hlbHBlci5weSdcbiAgICB2YXIgYXJncyA9IFtzZWwsIG9wZW5haUFQSUtleV1cbiAgICBuZXcgTm90aWNlKFwiU3VtbWFyaXppbmcuLi5cIilcbiAgICAvL1dlIGRlY2xhcmUgZ2V0X3NlbGVjdGVkX3RleHQgYXMgYSBmdW5jdGlvbiB0aGF0IFwiV0FJVFNcIiAoYXN5bmMpLCBhbmQgd2Ugd2FpdCBmb3IgdGhlIHJlc3VsdCBoZXJlXG4gICAgY29uc3Qgc3VtbWFyeSA9IGF3YWl0IGxhdW5jaF9weXRob24ocHl0aG9uUGF0aCwgc2NyaXB0UGF0aCwgc2NyaXB0TmFtZSwgYXJncylcblxuICAgIGxldCBuZXdfc3VtbWFyeTogc3RyaW5nID0gU3RyaW5nKHN1bW1hcnkpXG4gICAgLy9DcmVhdGUgbmV3IGxpbmVzIGluIHRoZSBzdW1tYXJ5IChzb21laG93IGl0IGdldHMgbG9zdCBiZXR3ZWVuIFB5dGhvbiBhbmQgSmF2YXNjcmlwdClcbiAgICBuZXdfc3VtbWFyeSA9IG5ld19zdW1tYXJ5LnJlcGxhY2UoLywtL2csICdcXG4tJylcbiAgICBjb25zb2xlLmxvZyhgVGhlIHN0YXJ0dXAgc3VtbWFyeTpcXG4gJHtuZXdfc3VtbWFyeX1gKVxuXG4gICAgY29uc3QgcmVwbGFjZW1lbnQgPSAnI2dwdF9zdW1tYXJpemVkLCAjcmV2aWV3X3N0YXJ0dXAgXFxuJysgbmV3X3N1bW1hcnkgKyAnXFxuJyArICcjIFN0b3AgSW5kZXhpbmcgXFxuIyMgTm90ZXNcXG4nICsgc2VsXG4gICAgZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24ocmVwbGFjZW1lbnQpXG5cbn1cblxuYXN5bmMgZnVuY3Rpb24gbGF1bmNoX3B5dGhvbihweXRob25QYXRoOiBzdHJpbmcsIHNjcmlwdFBhdGg6IHN0cmluZywgc2NyaXB0TmFtZTogc3RyaW5nLCBhcmdzOiBhbnkpe1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gbGF1bmNoZXMgYSBweXRob24gc2NyaXB0IHdpdGggdGhlIGNvcnJlY3QgcHl0aG9uIHZpcnR1YWwgZW52aXJvbm1lbnQgYW5kIHJldHVybnMgd2hhdGV2ZXIgdGhlIHB5dGhvbiBzY3JpcHQgcHJpbnRzISEgKG5vIHZhbHVlIHBhc3NpbmcsIHRha2UgY2FyZSlcbiAgICAgKi9cbiAgICBsZXQge1B5dGhvblNoZWxsfSA9IHJlcXVpcmUoJ3B5dGhvbi1zaGVsbCcpXG4gICAgY29uc3Qgb3B0aW9ucyA9IHttb2RlOiAndGV4dCcsIHB5dGhvblBhdGg6IHB5dGhvblBhdGgsIHNjcmlwdFBhdGg6IHNjcmlwdFBhdGgsIGFyZ3M6IGFyZ3N9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgUHl0aG9uU2hlbGwucnVuKHNjcmlwdE5hbWUsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnI6IEVycm9yLCByZXN1bHRzOiBhbnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdFxuXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHN1bW1hcml6ZV92Y190ZXh0KHRleHQ6IHN0cmluZyl7XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhlIGZ1bGwgdGV4dCBpbiBhIFZDIG5vdGUsIHRoaXMgZnVuY3Rpb24gc3VtbWFyaXplcyB0aGUgaW1wb3J0YW50IHBhcnQgKGJlZm9yZSAjIFN0b3AgSW5kZXhpbmcpIGFuZCByZXR1cm5zIHRoZSBuZXcgZnVsbCB0ZXh0IHRoYXQgc2hvdWxkIGJlIHdyaXR0ZW4gdG8gdGhlIGZpbGVcbiAgICAgKiBUaGUgZnVsbCB0ZXh0IGluY2x1ZGVzIHRoZSBtZXRhIGRhdGEgYW5kIHRhZ3MgaW5mb3JtYXRpb24gYmVmb3JlIHRoZSB0aXRsZSwgdGhlIHRpdGxlLCB0aGUgc3VtbWFyeSwgYW5kIGFkZHMgdGhlIGNvcmUgZGF0YSBhZnRlciB0aGUgaGVhZGluZyBcIiMgU3RvcCBJbmRleGluZ1wiXG4gICAgICovXG4gICAgY29uc3Qgc2NyaXB0UGF0aCA9IHNjcmlwdFBhdGhfQUlcbiAgICBjb25zdCBzY3JpcHROYW1lID0gJ3ZjX3N1bW1hcml6ZXJfaGVscGVyLnB5J1xuXG4gICAgLy8gV2Ugc2hvdWxkIHN1bW1hcml6ZSBvbmx5IGluZm9ybWF0aW9uIHRoYXQgaXMgYmVmb3JlICcjIFN0b3AgSW5kZXhpbmcnXG4gICAgbGV0IFt0aXRsZSwgc3Vic3RyaW5nc10gPSBleHRyYWN0X3RpdGxlX2FuZF9ub3RlKHRleHQpXG4gICAgbGV0IHRleHRfdG9fc3VtbWFyaXplID0gc3Vic3RyaW5nc1swXSArICdcXG4nICsgc3Vic3RyaW5nc1sxXVxuXG4gICAgY29uc29sZS5sb2coYFN1bW1hcml6aW5nOiAke3RpdGxlfWApXG4gICAgLy9jb25zb2xlLmxvZyhcIlRleHQgdG8gc3VtbWFyaXplOiBcIilcbiAgICAvL2NvbnNvbGUubG9nKHRleHRfdG9fc3VtbWFyaXplKVxuXG4gICAgdmFyIGFyZ3MgPSBbJ05vdGVzOlxcbicgKyB0ZXh0X3RvX3N1bW1hcml6ZSArICdTdW1tYXJ5OlxcbicsIG9wZW5haUFQSUtleV0gLy90ZXh0XG4gICAgLy9XZSBkZWNsYXJlIGdldF9zZWxlY3RlZF90ZXh0IGFzIGEgZnVuY3Rpb24gdGhhdCBcIldBSVRTXCIgKGFzeW5jKSwgYW5kIHdlIHdhaXQgZm9yIHRoZSByZXN1bHQgaGVyZVxuICAgIFxuICAgIGNvbnN0IHN1bW1hcnkgPSBhd2FpdCBsYXVuY2hfcHl0aG9uKHB5dGhvblBhdGgsIHNjcmlwdFBhdGgsIHNjcmlwdE5hbWUsIGFyZ3MpXG4gICAgbGV0IG5ld19zdW1tYXJ5OiBzdHJpbmcgPSBTdHJpbmcoc3VtbWFyeSlcbiAgICAvL1NlcGFyYXRlIGRpZmZlcmVudCBidWxsZXQgcG9pbnRzXG4gICAgbmV3X3N1bW1hcnkgPSBuZXdfc3VtbWFyeS5yZXBsYWNlKC8sLS9nLCAnXFxuLScpXG5cbiAgICBcbiAgICB0aXRsZSA9IHRpdGxlLnRvU3RyaW5nKClcbiAgICBsZXQgbGVhZGluZ190ZXh0ID0gJydcbiAgICBsZXQgcmVwbGFjZW1lbnQgPSAnJ1xuICAgIGxldCB0YWlsaW5nX3RleHQgPSAnJ1xuXG4gICAgLypjb25zb2xlLmxvZyhgVGl0bGU6ICR7dGl0bGV9YClcbiAgICBjb25zb2xlLmxvZyhgQmVmb3JlIHRoZSB0aXRsZTpcXG4ke3N1YnN0cmluZ3NbMF19YClcbiAgICBjb25zb2xlLmxvZyhgQWZ0ZXIgdGhlIHRpdGxlOiAke3N1YnN0cmluZ3NbMV19YCkqL1xuXG4gICAgaWYoc3Vic3RyaW5ncyl7XG4gICAgICAgIGxlYWRpbmdfdGV4dCA9IHN1YnN0cmluZ3NbMF0gKyAnXFxuJyArIHRpdGxlICsgJ1xcbidcbiAgICAgICAgZm9yIChsZXQgc3Vic3RyaW5nIG9mIHN1YnN0cmluZ3Muc2xpY2UoMSkpe1xuICAgICAgICAgICAgdGFpbGluZ190ZXh0ID0gdGFpbGluZ190ZXh0ICsgJ1xcbicgKyBzdWJzdHJpbmdcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlbWVudCA9IGxlYWRpbmdfdGV4dCArICcjZ3B0X3N1bW1hcml6ZWQsICNyZXZpZXcgXFxuJysgbmV3X3N1bW1hcnkgKyAnXFxuJyArICcjIFN0b3AgSW5kZXhpbmcgXFxuIyMgTm90ZXNcXG4nICsgdGFpbGluZ190ZXh0XG4gICAgICAgIHJldHVybiBbcmVwbGFjZW1lbnQsIG5ld19zdW1tYXJ5LCB0aXRsZV1cbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgcmV0dXJuIFt0ZXh0LCB0ZXh0LCAnJ11cblxuICAgIH1cblxuICAgIFxufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9ub3RpY2UoKXtcbiAgICBuZXcgTm90aWNlKFwiTmljZSB0byBtZWV0IHlvdSFcIilcbn1cblxuZnVuY3Rpb24gZXh0cmFjdF90aXRsZV9hbmRfbm90ZSh0ZXh0OiBzdHJpbmcpe1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgYWxsIHRoZSB0ZXh0IGluIHRoZSBmaWxlIGFuZCByZXR1cm5zIHRoZSB0aXRsZSBhbmQgdGhlIGJvZHkgb2YgdGhlIG5vdGUuXG4gICAgICogVGhlIHNwbGl0IGhhcHBlbnMgYmFzZWQgb24gaDEgaGVhZGVyLiBcbiAgICAgKiBUaGlzIG1lYW5zIHN1YnN0cmluZ3NbMF0gaXMgdXN1YWxseSB0aGUgZGF0YSBiZWZvcmUgdGhlIHRpdGxlLlxuICAgICAqIHN1YnN0cmluZ3NbMV0gaXMgdXN1YWxseSB0aGUgYm9keSBvZiB0aGUgbm90ZVxuICAgICAqIGlmIHRoZXJlIGlzIHN1YnN0cmluZyBbMl0sIHRoaXMgbWVhbnMgdGhlcmUgaXMgYW5vdGhlciBoMSBoZWFkZXIgKHVzdWFsbHkgIyBTdG9wIEluZGV4aW5nKVxuICAgICAqIERvd25zdHJlYW0gdGFza3Mgb25seSBkZWFscyB3aXRoIHN1YnN0cmluZ1sxXSBhcyB0aGUgbm90ZTsgaS5lIGluZm9ybWF0aW9uIGFmdGVyIHRoZSBTdG9wIEluZGV4aW5nIGFyZSBleGVjbHVkZWRcbiAgICAgKi9cblxuICAgICAgICAvLz9nbSBtZWFucyBzdHJpbmcgaXMgbXVsdGlsaW5lcywgYW5kIF4gd291bGQgY2F0Y2ggYmVnaW5uaW5nIG9mIGV2ZXJ5IGxpbmUgbm90IGp1c3QgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmchXG4gICAgICAgIGxldCBwYXR0ZXJuID0gL14jIC4qXFxuL2dtO1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IHRleHQubWF0Y2gocGF0dGVybik7XG4gICAgICAgIGxldCB0aXRsZSA9ICcnXG4gICAgICAgIGlmKG1hdGNoZXMpe1xuICAgICAgICAgICAgdGl0bGUgPSBtYXRjaGVzWzBdXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YnN0cmluZ3MgPSB0ZXh0LnNwbGl0KHBhdHRlcm4pXG4gICAgICAgIGNvbnNvbGUubG9nKGBUaXRsZTogJHt0aXRsZX1gKVxuICAgICAgICBjb25zb2xlLmxvZyhzdWJzdHJpbmdzKVxuXG4gICAgICAgIHJldHVybiBbdGl0bGUsIHN1YnN0cmluZ3NdXG5cbn1cblxuZnVuY3Rpb24gZXh0cmFjdF9zdW1tYXJ5KGZ1bGxfbm90ZTpzdHJpbmcpe1xuICAgIC8vV2hlbiBhIG5vdGUgaXMgcmVhZHkgKGhhcyBncHRfc3VtbWFyaXplZCBhbmQgQWZmaW5pdHkgdGFncyksIGV4dHJhY3QgdGhlIHN1bW1hcnkgZnJvbSBmdWxsIHRleHRcbiAgICBsZXQgc3Vic3RyaW5ncyA9IGZ1bGxfbm90ZS5zcGxpdCgnIyBTdG9wIEluZGV4aW5nJylcbiAgICBsZXQgc3VtbWFyeSA9IHN1YnN0cmluZ3NbMF1cbiAgICAvL2NvbnNvbGUubG9nKGBTdW1tYXJ5OiAke3N1bW1hcnl9YClcbiAgICByZXR1cm4gc3VtbWFyeVxufVxuXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVfYWZmaW5pdHkobm90ZTogc3RyaW5nLCBlbnRpdHlfbmFtZTpzdHJpbmcsIHNjcmlwdE5hbWU6IHN0cmluZyl7XG4gICAgY29uc3Qgc2NyaXB0UGF0aCA9IHNjcmlwdFBhdGhfQUlcbiAgICBpZiAoc2NyaXB0TmFtZSA9PSAnYWZmaW5pdHlfdmNfaGVscGVyLnB5Jyl7XG4gICAgICAgIHZhciBhcmdzID0gW2VudGl0eV9uYW1lLCBub3RlLCBhZmZpbml0eUFQSUtleSwgb3duZXJfdmFsdWUsIGNvbm5lY3Rpb25fb3duZXJfZmllbGQsIHZlbnR1cmVfbmV0d29ya19saXN0XVxuXG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIHZhciBhcmdzID0gW2VudGl0eV9uYW1lLCBub3RlLCBhZmZpbml0eUFQSUtleSwgb3duZXJfdmFsdWVdXG5cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coXCJVcGRhdGUgQWZmaW5pdHlcIilcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGxhdW5jaF9weXRob24ocHl0aG9uUGF0aCwgc2NyaXB0UGF0aCwgc2NyaXB0TmFtZSwgYXJncylcblxuICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKVxuICAgIHJldHVybiByZXNwb25zZVxuXG59XG5cbmZ1bmN0aW9uIHZjX3JlYWR5X2Zvcl9hZmZpbml0eShmaWxlX2NvbnRlbnQ6IHN0cmluZyl7XG4gICAgcmV0dXJuIGZpbGVfY29udGVudC5pbmNsdWRlcygnI2dwdF9zdW1tYXJpemVkJykgJiYgZmlsZV9jb250ZW50LmluY2x1ZGVzKCcjQWZmaW5pdHknKVxufVxuXG5mdW5jdGlvbiBzdGFydHVwX3JlYWR5X2Zvcl9hZmZpbml0eShmaWxlX2NvbnRlbnQ6IHN0cmluZyl7XG4gICAgcmV0dXJuIChmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNzdGFydHVwcy9zY3JlZW5lZCcpICYmIGZpbGVfY29udGVudC5pbmNsdWRlcygnI0FmZmluaXR5JykpXG59XG5cbmZ1bmN0aW9uIG5vdGlmeV9mb3JfbWlzc2luZ19wZW9wbGUocGVyc29uX25hbWU6IHN0cmluZywgcmVzcG9uc2U6IGFueSl7XG4gICAgLyoqXG4gICAgICogSWYgYSBwZXJzb24gaXMgbm90IGZvdW5kIGluIGFmZmluaXR5LCBzZW5kIGEgbm90aWZpY2F0aW9uIGFuZCByZXR1cm4gZmFsc2VcbiAgICAgKi9cbiAgICBmb3IgKGxldCBpdGVtIG9mIHJlc3BvbnNlKXtcbiAgICAgICAgaWYgKGl0ZW0uaW5jbHVkZXMoJ09vcHMnKSl7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBQZXJzb246ICR7cGVyc29uX25hbWV9IHdhcyBub3QgZm91bmRgLCAzNjAwMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cblxuICAgIH0gICBcbiAgICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gbm90aWZ5X2Zvcl9taXNzaW5nX3N0YXJ0dXBzKHN0YXJ0dXBfbmFtZTogc3RyaW5nLCByZXNwb25zZTogYW55KXtcbiAgICBmb3IgKGxldCBpdGVtIG9mIHJlc3BvbnNlKXtcbiAgICAgICAgaWYoaXRlbS5pbmNsdWRlcygnRXJyb3InKSl7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBTdGFydHVwOiAke3N0YXJ0dXBfbmFtZX0gd2FzIGZvdW5kIGJ1dCBjb3VsZCBub3QgYmUgdXBkYXRlZGAsIDM2MDAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpdGVtLmluY2x1ZGVzKCdTdGFydHVwJykpe1xuICAgICAgICAgICAgbmV3IE5vdGljZShgU3RhcnR1cDogJHtzdGFydHVwX25hbWV9IGNvdWxkIG5vdCBiZSBmb3VuZGAsIDM2MDAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2Vcbn1cblxuYXN5bmMgZnVuY3Rpb24gcHVzaF92Y3NfdG9fYWZmaW5pdHkoKXtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHB1c2hlcyBhbGwgcmVhZHkgVkNzIHRvIGFmZmluaXR5LCBpdCBhbHNvIG5vdGlmaWVzIHVzIGlmIGEgcGVyc29uIGNhbiBub3QgYmUgZm91bmQgb24gYWZmaW5pdHlcbiAgICAgKi9cbiAgICBjb25zdCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKVxuICAgIGZvciAobGV0IGl0ZW0gb2YgZmlsZXMpe1xuICAgICAgICBsZXQgZmlsZV9jb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChpdGVtKVxuICAgICAgICBpZiAodmNfcmVhZHlfZm9yX2FmZmluaXR5KGZpbGVfY29udGVudCkpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgW3RpdGxlLCBzdWJzdHJpbmdzXSA9IGV4dHJhY3RfdGl0bGVfYW5kX25vdGUoZmlsZV9jb250ZW50KVxuICAgICAgICAgICAgbGV0IHN1bW1hcnkgPSBzdWJzdHJpbmdzWzFdIC8vZXh0cmFjdF9zdW1tYXJ5KHN1YnN0cmluZ3NbMV0pXG4gICAgICAgICAgICBsZXQgcGVyc29uX25hbWUgPSBTdHJpbmcodGl0bGUpXG4gICAgICAgICAgICBsZXQgc2NyaXB0TmFtZSA9ICdhZmZpbml0eV92Y19oZWxwZXIucHknXG4gICAgICAgICAgICBsZXQgcmVzcG9uc2U6IGFueSA9IGF3YWl0IHVwZGF0ZV9hZmZpbml0eShzdW1tYXJ5LCBwZXJzb25fbmFtZSwgc2NyaXB0TmFtZSlcbiAgICAgICAgICAgIGlmICghbm90aWZ5X2Zvcl9taXNzaW5nX3Blb3BsZShwZXJzb25fbmFtZSwgcmVzcG9uc2UpKXtcbiAgICAgICAgICAgICAgICAvL2lmIHRoZSBwZXJzb24gd2FzIHVwZGF0ZWQgb24gYWZmaW5pdHkgc3VjY2Vzc2Z1bHkgYW5kIG5vdCBtaXNzaW5nIGZyb20gZGF0YWJhc2UsIHJlbW92ZSAjQWZmaW5pdHkgZnJvbSB0ZXh0XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShgVkM6ICR7cGVyc29uX25hbWV9IHdhcyB1cGRhdGVkIG9uIEFmZmluaXR5YClcbiAgICAgICAgICAgICAgICBmaWxlX2NvbnRlbnQgPSBmaWxlX2NvbnRlbnQucmVwbGFjZSgvI0FmZmluaXR5L2csICcnKVxuICAgICAgICAgICAgICAgIHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShpdGVtLCBmaWxlX2NvbnRlbnQpXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgXG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cblxuYXN5bmMgZnVuY3Rpb24gcHVzaF9zdGFydHVwc190b19hZmZpbml0eSgpe1xuICAgIC8qKlxuICAgICAqIFB1c2ggYWxsIGVsaWdpYmxlIHN0YXJ0dXBzIHRvIGFmZmluaXR5IChub3RpZnkgbWUgb3RoZXJ3aXNlKVxuICAgICAqL1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpXG4gICAgZm9yIChsZXQgaXRlbSBvZiBmaWxlcyl7XG4gICAgICAgIGxldCBmaWxlX2NvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGl0ZW0pXG4gICAgICAgIGlmIChzdGFydHVwX3JlYWR5X2Zvcl9hZmZpbml0eShmaWxlX2NvbnRlbnQpKXtcbiAgICAgICAgICAgIGxldCBbdGl0bGUsIHN1YnN0cmluZ3NdID0gZXh0cmFjdF90aXRsZV9hbmRfbm90ZShmaWxlX2NvbnRlbnQpXG4gICAgICAgICAgICBsZXQgc3RhcnR1cF9uYW1lID0gU3RyaW5nKHRpdGxlKVxuICAgICAgICAgICAgbGV0IG5vdGUgPSBzdWJzdHJpbmdzWzFdXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGBTdGFydHVwIG5hbWU6ICR7c3RhcnR1cF9uYW1lfWApXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGBOb3RlOiAke25vdGV9YClcbiAgICAgICAgICAgIGxldCBzY3JpcHROYW1lID0gJ2FmZmluaXR5X3N0YXJ0dXBfaGVscGVyLnB5J1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlOiBhbnkgPSBhd2FpdCB1cGRhdGVfYWZmaW5pdHkobm90ZSwgc3RhcnR1cF9uYW1lLCBzY3JpcHROYW1lKVxuXG4gICAgICAgICAgICBpZiAoIW5vdGlmeV9mb3JfbWlzc2luZ19zdGFydHVwcyhzdGFydHVwX25hbWUsIHJlc3BvbnNlKSl7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShgU3RhcnR1cDogJHtzdGFydHVwX25hbWV9IHdhcyB1cGRhdGVkIG9uIEFmZmluaXR5YClcbiAgICAgICAgICAgICAgICBmaWxlX2NvbnRlbnQgPSBmaWxlX2NvbnRlbnQucmVwbGFjZSgvI0FmZmluaXR5L2csICcnKVxuICAgICAgICAgICAgICAgIHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShpdGVtLCBmaWxlX2NvbnRlbnQpXG4gICAgICAgICAgICB9XG5cblxuXG4gICAgICAgIH1cblxuICAgIH1cbiAgICBuZXcgTm90aWNlKCdEb25lIScpXG59XG5cbmZ1bmN0aW9uIGlzX3N1bW1hcml6YWJsZShmaWxlX2NvbnRlbnQ6IHN0cmluZyl7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIFZDIGlzIHRvIGJlIHN1bW1hcml6ZWQgKEkgYW0gY29ubmVjdGVkIHdpdGggdGhlbSBhbmQgdGhleSBhcmUgbm90IGFscmVhZHkgc3VtbWFyaXplZClcbiAgICAgKi9cbiAgICByZXR1cm4gZmlsZV9jb250ZW50LmluY2x1ZGVzKCcjbmV0d29yay9jb25uZWN0ZWQnKSAmJiAoIGZpbGVfY29udGVudC5pbmNsdWRlcygnI0VudGl0eS9WQycpIHx8IGZpbGVfY29udGVudC5pbmNsdWRlcygnI1BlcnNvbi9WQycpICkgJiYgKGZpbGVfY29udGVudC5pbmNsdWRlcygnI2dwdF9zdW1tYXJpemVkJykgIT0gdHJ1ZSkgJiYgKGZpbGVfY29udGVudC5pbmNsdWRlcygnZGF0YXZpZXcnKSAhPSB0cnVlKVxuXG59XG5cbmludGVyZmFjZSBCdXRsZXJTZXR0aW5ncyB7XG5cdHZhdWx0UGF0aDogc3RyaW5nO1xuICAgIGFmZmluaXR5S2V5OiBzdHJpbmc7XG4gICAgb3BlbkFJS2V5OiBzdHJpbmc7XG4gICAgb3duZXJfcGVyc29uX3ZhbHVlOiBzdHJpbmc7XG4gICAgY29ubmVjdGlvbl9vd25lcl9maWVsZF9pZDogc3RyaW5nO1xuICAgIHZlbnR1cmVfbmV0d29ya19saXN0X2lkOiBzdHJpbmc7XG4gICAgcHl0aG9uUGF0aDogc3RyaW5nXG5cbn1cblxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogQnV0bGVyU2V0dGluZ3MgPSB7XG5cdHZhdWx0UGF0aDogJ2RlZmF1bHQnLFxuICAgIGFmZmluaXR5S2V5OiAnZGVmYXVsdCcsXG4gICAgb3BlbkFJS2V5OiAnZGVmYXVsdCcsXG4gICAgb3duZXJfcGVyc29uX3ZhbHVlOiAnMTAnLFxuICAgIGNvbm5lY3Rpb25fb3duZXJfZmllbGRfaWQ6ICcxMDAnLFxuICAgIHZlbnR1cmVfbmV0d29ya19saXN0X2lkOiAnNTAwJyxcbiAgICBweXRob25QYXRoOiAnPHBhdGgtdG8tdmlydHVhbC1lbnY+J1xuXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZDV2l6YXJkUGx1Z2luIGV4dGVuZHMgUGx1Z2lue1xuICAgIHNldHRpbmdzOiBCdXRsZXJTZXR0aW5ncztcbiAgICBhc3luYyBvbmxvYWQoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG4gICAgICAgIFxuXG4gICAgICAgIHRoaXMuYWRkUmliYm9uSWNvbignc3VuJywgJ09tYXIgUGx1Z2luJywgY3JlYXRlX25vdGljZSlcbiAgICAgICAgICAgIFxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe2lkOiAnc3VtbWFyaXplLXN0YXJ0dXAtY29tbWFuZCcsIG5hbWU6ICdTdW1tYXJpemUgVGhpcyBTdGFydHVwJywgZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3IsIHZpZXcpID0+IHN1bW1hcml6ZV9zZWxlY3RlZF9zdGFydHVwX3RleHQoZWRpdG9yLCB2aWV3KX0pXG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtpZDogJ3N1bW1hcml6ZS1hbGwtdmMtY29tbWFuZCcsIG5hbWU6ICdTdW1tYXJpemUgQWxsIFZDIE5vdGVzJywgY2FsbGJhY2s6ICgpID0+IHRoaXMuc3VtbWFyaXplX2FsbF92YygpfSlcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe2lkOiAnYWZmaW5pdHktdmMnLCBuYW1lOiAnUHVzaCBWQ3MgdG8gQWZmaW5pdHknLCBjYWxsYmFjazogKCkgPT4gcHVzaF92Y3NfdG9fYWZmaW5pdHkoKX0pXG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtpZDogJ2FmZmluaXR5LXN0YXJ0dXAnLCBuYW1lOiAnUHVzaCBTdGFydHVwcyB0byBBZmZpbml0eScsIGNhbGxiYWNrOiAoKSA9PiBwdXNoX3N0YXJ0dXBzX3RvX2FmZmluaXR5KCl9KVxuXG4gICAgICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU2FtcGxlU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuICAgIFxuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuXG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFNldHRpbmdzKCl7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgICAgICBzY3JpcHRQYXRoX0FJID0gdGhpcy5zZXR0aW5ncy52YXVsdFBhdGggKyAnLm9ic2lkaWFuL3BsdWdpbnMvdmNfd2l6YXJkJ1xuICAgICAgICBvcGVuYWlBUElLZXkgPSB0aGlzLnNldHRpbmdzLm9wZW5BSUtleVxuICAgICAgICBhZmZpbml0eUFQSUtleSA9IHRoaXMuc2V0dGluZ3MuYWZmaW5pdHlLZXlcbiAgICAgICAgb3duZXJfdmFsdWUgPSB0aGlzLnNldHRpbmdzLm93bmVyX3BlcnNvbl92YWx1ZVxuICAgICAgICBjb25uZWN0aW9uX293bmVyX2ZpZWxkID0gdGhpcy5zZXR0aW5ncy5jb25uZWN0aW9uX293bmVyX2ZpZWxkX2lkXG4gICAgICAgIHZlbnR1cmVfbmV0d29ya19saXN0ID0gdGhpcy5zZXR0aW5ncy52ZW50dXJlX25ldHdvcmtfbGlzdF9pZFxuICAgICAgICBweXRob25QYXRoID0gdGhpcy5zZXR0aW5ncy5weXRob25QYXRoXG4gICAgfVxuXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCl7XG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncylcbiAgICAgICAgc2NyaXB0UGF0aF9BSSA9IHRoaXMuc2V0dGluZ3MudmF1bHRQYXRoICsgJy5vYnNpZGlhbi9wbHVnaW5zL3ZjX3dpemFyZCdcbiAgICAgICAgb3BlbmFpQVBJS2V5ID0gdGhpcy5zZXR0aW5ncy5vcGVuQUlLZXlcbiAgICAgICAgYWZmaW5pdHlBUElLZXkgPSB0aGlzLnNldHRpbmdzLmFmZmluaXR5S2V5XG4gICAgICAgIG93bmVyX3ZhbHVlID0gdGhpcy5zZXR0aW5ncy5vd25lcl9wZXJzb25fdmFsdWVcbiAgICAgICAgY29ubmVjdGlvbl9vd25lcl9maWVsZCA9IHRoaXMuc2V0dGluZ3MuY29ubmVjdGlvbl9vd25lcl9maWVsZF9pZFxuICAgICAgICB2ZW50dXJlX25ldHdvcmtfbGlzdCA9IHRoaXMuc2V0dGluZ3MudmVudHVyZV9uZXR3b3JrX2xpc3RfaWRcbiAgICAgICAgcHl0aG9uUGF0aCA9IHRoaXMuc2V0dGluZ3MucHl0aG9uUGF0aFxuICAgIH1cblxuICAgIGFzeW5jIHN1bW1hcml6ZV9hbGxfdmMoKXtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gc3VtbWFyaXplZCBhbGwgVkMgbm90ZXMgdGhhdCBhcmUgZWxpZ2libGUgZm9yIHN1bW1hcml6YXRpb24gKHBlb3BsZSBvciBlbnRpdGllcyBJIGFtIGNvbm5lY3RlZCB3aXRoKVxuICAgICAgICAgKi9cblxuICAgICAgICBjb25zdCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKVxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGZpbGVzKXtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coaXRlbS5uYW1lKVxuICAgICAgICAgICAgbGV0IGZpbGVfY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoaXRlbSlcbiAgICAgICAgICAgIGlmIChpc19zdW1tYXJpemFibGUoZmlsZV9jb250ZW50KSl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFdlIGFyZSBjaGFuZ2luZyBmaWxlOiAke2l0ZW0ubmFtZX1gKVxuICAgICAgICAgICAgICAgIC8vV2Ugc2hvdWxkIHN1bW1hcml6ZSB0aGlzIGZpbGUgdGhlblxuICAgICAgICAgICAgICAgIGxldCBbbmV3X3RleHQsIHN1bW1hcnksIHRpdGxlXSA9IGF3YWl0IHN1bW1hcml6ZV92Y190ZXh0KGZpbGVfY29udGVudClcbiAgICAgICAgICAgICAgICBpZiAodGl0bGUgIT0gJycpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC52YXVsdC5tb2RpZnkoaXRlbSwgbmV3X3RleHQpXG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYCR7dGl0bGV9IGhhcyBiZWVuIHN1bW1hcml6ZWRgKVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuXG4gICAgICAgIC8vdmF1bHQuXG5cbiAgICAgICAgXG5cbiAgICB9XG59XG5cbmNsYXNzIFNhbXBsZVNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFie1xuICAgIHBsdWdpbjogVkNXaXphcmRQbHVnaW5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBWQ1dpemFyZFBsdWdpbil7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKVxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpblxuICAgIH1cbiAgICBkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHt0ZXh0OiAnU2V0dGluZ3MgZm9yIHlvdXIgYnV0bGVyJ30pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnT2JzaWRpYW4gVmF1bHQgUGF0aCcpXG5cdFx0XHQuc2V0RGVzYygnVGhlIHBhdGggdG8gdGhlIHZhdWx0IHdoZXJlIHlvdSB3aXNoIHRvIHVzZSB0aGUgcGx1Z2luJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHBhdGgnKVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudmF1bHRQYXRoKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ3BhdGg6ICcgKyB2YWx1ZSk7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MudmF1bHRQYXRoID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdH0pKTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKCdPcGVuQUkgQVBJIEtleScpXG4gICAgICAgIC5zZXREZXNjKCdZb3VyIE9wZW5BSSBBUEkgS2V5JylcbiAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIGtleScpXG4gICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mub3BlbkFJS2V5KVxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdPcGVuIEFJIGtleTogJyArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vcGVuQUlLZXkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKCdBZmZpbml0eTogQVBJIEtleScpXG4gICAgICAgIC5zZXREZXNjKCdZb3VyIEFmZmluaXR5IEFQSSBLZXknKVxuICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignRW50ZXIga2V5JylcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hZmZpbml0eUtleSlcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygna2V5OiAnICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmFmZmluaXR5S2V5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZSgnQWZmaW5pdHk6IE93bmVyIFZhbHVlJylcbiAgICAgICAgLnNldERlc2MoJ0V2ZXJ5IHBlcnNvbiBoYXMgYSBjb2RlIG9uIEFmZmluaXR5LiBQbGVhc2UgZ2l2ZSBpbiB0aGUgY29kZSBmb3IgdGhlIHBlcnNvbiB0aGF0IHNob3VsZCBiZSBhZGRlZCBhcyBvd25lciBvZiBzdGFydHVwcyBhbmQgVkNzIHRoYXQgZ2V0cyBwdXNoZWQnKVxuICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignRW50ZXIgdmFsdWUnKVxuICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm93bmVyX3BlcnNvbl92YWx1ZSlcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnT3duZXIgdmFsdWU6ICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3duZXJfcGVyc29uX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZSgnQWZmaW5pdHk6IENvbm5lY3Rpb24gT3duZXIgRmllbGQgSUQnKVxuICAgICAgICAuc2V0RGVzYygnRGVwZW5kaW5nIG9uIHRoZSBsaXN0IHlvdSBzYXZlIGZlbGxvdyBWQ3MgaW4sIHRoZXJlIGlzIGEgZmllbGQgdGhhdCByZXByZXNlbnQgdGhlIFxcJ2Nvbm5lY3Rpb24gb3duZXIgd2l0aCB0aGUgZnVuZFxcJywgZW50ZXIgdGhlIGZpZWxkIGlkIGhlcmUnKVxuICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignRW50ZXIgdmFsdWUnKVxuICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbm5lY3Rpb25fb3duZXJfZmllbGRfaWQpXG4gICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24gT3duZXIgRmllbGQgSUQgdmFsdWU6ICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29ubmVjdGlvbl9vd25lcl9maWVsZF9pZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoJ0FmZmluaXR5OiBWZW50dXJlIE5ldHdvcmsgTGlzdCBJRCcpXG4gICAgICAgIC5zZXREZXNjKCdQbGVhc2UgZW50ZXIgdGhlIGxpc3QgaWQgZm9yIHRoZSBsaXN0IHlvdSBzYXZlIHlvdXIgcmVsYXRpb25zaGlwcyB3aXRoIFZDcyBpbicpXG4gICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdFbnRlciB2YWx1ZScpXG4gICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudmVudHVyZV9uZXR3b3JrX2xpc3RfaWQpXG4gICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1ZlbnR1cmUgbmV0d29yayBsaXN0IGlkOiAnICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnZlbnR1cmVfbmV0d29ya19saXN0X2lkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZSgnUHl0aG9uIFZpcnR1YWwgRW52aXJvbm1lbnQgUGF0aCcpXG4gICAgICAgIC5zZXREZXNjKCdUaGUgcGF0aCB0byBweXRob24gdmlydHVhbCBlbnZpcm9ubWVudCcpXG4gICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdFbnRlciBwYXRoJylcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5weXRob25QYXRoKVxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQeXRob25QYXRoOiAnICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnB5dGhvblBhdGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgIH0pKTtcblx0fVxuXG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxRQUFBLFdBQUEsUUFBQTtBQUNBLFFBQUEsa0JBQUEsUUFBQTtBQUNBLFFBQUEsT0FBQSxRQUFBO0FBQ0EsUUFBQSxT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
