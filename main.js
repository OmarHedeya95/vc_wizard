/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/python-shell/index.js
var require_python_shell = __commonJS({
  "node_modules/python-shell/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PythonShell = exports.NewlineTransformer = exports.PythonShellError = void 0;
    var events_1 = require("events");
    var child_process_1 = require("child_process");
    var os_1 = require("os");
    var path_1 = require("path");
    var stream_1 = require("stream");
    var fs_1 = require("fs");
    var util_1 = require("util");
    function toArray(source) {
      if (typeof source === "undefined" || source === null) {
        return [];
      } else if (!Array.isArray(source)) {
        return [source];
      }
      return source;
    }
    function extend(obj, ...args) {
      Array.prototype.slice.call(arguments, 1).forEach(function(source) {
        if (source) {
          for (let key in source) {
            obj[key] = source[key];
          }
        }
      });
      return obj;
    }
    function getRandomInt() {
      return Math.floor(Math.random() * 1e10);
    }
    var execPromise = (0, util_1.promisify)(child_process_1.exec);
    var PythonShellError = class extends Error {
    };
    exports.PythonShellError = PythonShellError;
    var NewlineTransformer = class extends stream_1.Transform {
      _transform(chunk, encoding, callback) {
        let data = chunk.toString();
        if (this._lastLineData)
          data = this._lastLineData + data;
        const lines = data.split(os_1.EOL);
        this._lastLineData = lines.pop();
        lines.forEach(this.push.bind(this));
        callback();
      }
      _flush(done) {
        if (this._lastLineData)
          this.push(this._lastLineData);
        this._lastLineData = null;
        done();
      }
    };
    exports.NewlineTransformer = NewlineTransformer;
    var PythonShell = class extends events_1.EventEmitter {
      constructor(scriptPath, options, stdoutSplitter = null, stderrSplitter = null) {
        super();
        function resolve(type, val) {
          if (typeof val === "string") {
            return PythonShell[type][val];
          } else if (typeof val === "function") {
            return val;
          }
        }
        if (scriptPath.trim().length == 0)
          throw Error("scriptPath cannot be empty! You must give a script for python to run");
        let self = this;
        let errorData = "";
        events_1.EventEmitter.call(this);
        options = extend({}, PythonShell.defaultOptions, options);
        let pythonPath2;
        if (!options.pythonPath) {
          pythonPath2 = PythonShell.defaultPythonPath;
        } else
          pythonPath2 = options.pythonPath;
        let pythonOptions = toArray(options.pythonOptions);
        let scriptArgs = toArray(options.args);
        this.scriptPath = (0, path_1.join)(options.scriptPath || "", scriptPath);
        this.command = pythonOptions.concat(this.scriptPath, scriptArgs);
        this.mode = options.mode || "text";
        this.formatter = resolve("format", options.formatter || this.mode);
        this.parser = resolve("parse", options.parser || this.mode);
        this.stderrParser = resolve("parse", options.stderrParser || "text");
        this.terminated = false;
        this.childProcess = (0, child_process_1.spawn)(pythonPath2, this.command, options);
        ["stdout", "stdin", "stderr"].forEach(function(name) {
          self[name] = self.childProcess[name];
          self.parser && self[name] && self[name].setEncoding(options.encoding || "utf8");
        });
        if (this.parser && this.stdout) {
          if (!stdoutSplitter)
            stdoutSplitter = new NewlineTransformer();
          stdoutSplitter.setEncoding(options.encoding || "utf8");
          this.stdout.pipe(stdoutSplitter).on("data", (chunk) => {
            this.emit("message", self.parser(chunk));
          });
        }
        if (this.stderrParser && this.stderr) {
          if (!stderrSplitter)
            stderrSplitter = new NewlineTransformer();
          stderrSplitter.setEncoding(options.encoding || "utf8");
          this.stderr.pipe(stderrSplitter).on("data", (chunk) => {
            this.emit("stderr", self.stderrParser(chunk));
          });
        }
        if (this.stderr) {
          this.stderr.on("data", function(data) {
            errorData += "" + data;
          });
          this.stderr.on("end", function() {
            self.stderrHasEnded = true;
            terminateIfNeeded();
          });
        } else {
          self.stderrHasEnded = true;
        }
        if (this.stdout) {
          this.stdout.on("end", function() {
            self.stdoutHasEnded = true;
            terminateIfNeeded();
          });
        } else {
          self.stdoutHasEnded = true;
        }
        this.childProcess.on("error", function(err) {
          self.emit("error", err);
        });
        this.childProcess.on("exit", function(code, signal) {
          self.exitCode = code;
          self.exitSignal = signal;
          terminateIfNeeded();
        });
        function terminateIfNeeded() {
          if (!self.stderrHasEnded || !self.stdoutHasEnded || self.exitCode == null && self.exitSignal == null)
            return;
          let err;
          if (self.exitCode && self.exitCode !== 0) {
            if (errorData) {
              err = self.parseError(errorData);
            } else {
              err = new PythonShellError("process exited with code " + self.exitCode);
            }
            err = extend(err, {
              executable: pythonPath2,
              options: pythonOptions.length ? pythonOptions : null,
              script: self.scriptPath,
              args: scriptArgs.length ? scriptArgs : null,
              exitCode: self.exitCode
            });
            if (self.listeners("pythonError").length || !self._endCallback) {
              self.emit("pythonError", err);
            }
          }
          self.terminated = true;
          self.emit("close");
          self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);
        }
        ;
      }
      static checkSyntax(code) {
        return __awaiter(this, void 0, void 0, function* () {
          const randomInt = getRandomInt();
          const filePath = (0, os_1.tmpdir)() + path_1.sep + `pythonShellSyntaxCheck${randomInt}.py`;
          const writeFilePromise = (0, util_1.promisify)(fs_1.writeFile);
          return writeFilePromise(filePath, code).then(() => {
            return this.checkSyntaxFile(filePath);
          });
        });
      }
      static getPythonPath() {
        return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;
      }
      static checkSyntaxFile(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
          const pythonPath2 = this.getPythonPath();
          let compileCommand = `${pythonPath2} -m py_compile ${filePath}`;
          return execPromise(compileCommand);
        });
      }
      static run(scriptPath, options, callback) {
        let pyshell = new PythonShell(scriptPath, options);
        let output = [];
        return pyshell.on("message", function(message) {
          output.push(message);
        }).end(function(err) {
          return callback(err ? err : null, output.length ? output : null);
        });
      }
      static runString(code, options, callback) {
        const randomInt = getRandomInt();
        const filePath = os_1.tmpdir + path_1.sep + `pythonShellFile${randomInt}.py`;
        (0, fs_1.writeFileSync)(filePath, code);
        return PythonShell.run(filePath, options, callback);
      }
      static getVersion(pythonPath2) {
        if (!pythonPath2)
          pythonPath2 = this.getPythonPath();
        return execPromise(pythonPath2 + " --version");
      }
      static getVersionSync(pythonPath2) {
        if (!pythonPath2)
          pythonPath2 = this.getPythonPath();
        return (0, child_process_1.execSync)(pythonPath2 + " --version").toString();
      }
      parseError(data) {
        let text = "" + data;
        let error;
        if (/^Traceback/.test(text)) {
          let lines = text.trim().split(os_1.EOL);
          let exception = lines.pop();
          error = new PythonShellError(exception);
          error.traceback = data;
          error.stack += os_1.EOL + "    ----- Python Traceback -----" + os_1.EOL + "  ";
          error.stack += lines.slice(1).join(os_1.EOL + "  ");
        } else {
          error = new PythonShellError(text);
        }
        return error;
      }
      send(message) {
        if (!this.stdin)
          throw new Error("stdin not open for writing");
        let data = this.formatter ? this.formatter(message) : message;
        if (this.mode !== "binary")
          data += os_1.EOL;
        this.stdin.write(data);
        return this;
      }
      end(callback) {
        if (this.childProcess.stdin) {
          this.childProcess.stdin.end();
        }
        this._endCallback = callback;
        return this;
      }
      kill(signal) {
        this.terminated = this.childProcess.kill(signal);
        return this;
      }
      terminate(signal) {
        return this.kill(signal);
      }
    };
    exports.PythonShell = PythonShell;
    PythonShell.defaultPythonPath = process.platform != "win32" ? "python3" : "python";
    PythonShell.defaultOptions = {};
    PythonShell.format = {
      text: function toText(data) {
        if (!data)
          return "";
        else if (typeof data !== "string")
          return data.toString();
        return data;
      },
      json: function toJson(data) {
        return JSON.stringify(data);
      }
    };
    PythonShell.parse = {
      text: function asText(data) {
        return data;
      },
      json: function asJson(data) {
        return JSON.parse(data);
      }
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VCWizardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// view.ts
var import_obsidian = require("obsidian");
var WIZARD_VIEW = "wizard-view";
var WizardView = class extends import_obsidian.ItemView {
  constructor(leaf) {
    super(leaf);
    this.icon = "sun";
  }
  getViewType() {
    return WIZARD_VIEW;
  }
  getDisplayText() {
    return "Example view";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("h4", { text: "Related Ideas", cls: "heading" });
  }
  async update(search_results) {
    const container = this.containerEl.children[1];
    container.empty();
    const outerDiv = container.createEl("h4", { text: "Related Ideas\n", cls: "heading" });
    for (const key in search_results) {
      let source_name = key;
      let source_path = search_results[key]["source_path"];
      let text = search_results[key]["text"];
      const quote = container.createEl("blockquote", { text, cls: "quote" });
      const link = quote.createEl("a", { href: source_path, attr: { "data-path": source_path } });
      link.createEl("span", {
        text: "\n--" + source_name
      });
    }
  }
  async onClose() {
  }
};

// main.ts
var fs = __toESM(require("fs"));
var pythonPath = "";
var scriptPath_AI = "";
var affinityAPIKey = "";
var openaiAPIKey = "";
var owner_value = "10";
var connection_owner_field = "10";
var venture_network_list = "500";
async function summarize_selected_startup_text(editor, view) {
  const sel = editor.getSelection();
  let scriptPath = scriptPath_AI;
  const scriptName = "startup_summarizer_helper.py";
  var args = [sel, openaiAPIKey];
  new import_obsidian2.Notice("Summarizing...");
  const summary = await launch_python(pythonPath, scriptPath, scriptName, args);
  let new_summary = String(summary);
  new_summary = new_summary.replace(/,-/g, "\n-");
  console.log(`The startup summary:
 ${new_summary}`);
  const replacement = "#gpt_summarized, #review_startup \n" + new_summary + "\n# Stop Indexing \n## Notes\n" + sel;
  editor.replaceSelection(replacement);
}
async function launch_python(pythonPath2, scriptPath, scriptName, args) {
  let { PythonShell } = require_python_shell();
  const options = { mode: "text", pythonPath: pythonPath2, scriptPath, args };
  const result = await new Promise((resolve, reject) => {
    PythonShell.run(scriptName, options, function(err, results) {
      if (err)
        throw err;
      return resolve(results);
    });
  });
  return result;
}
async function summarize_vc_text(text) {
  const scriptPath = scriptPath_AI;
  const scriptName = "vc_summarizer_helper.py";
  let [title, substrings] = extract_title_and_note(text);
  let text_to_summarize = substrings[0] + "\n" + substrings[1];
  console.log(`Summarizing: ${title}`);
  var args = ["Notes:\n" + text_to_summarize + "Summary:\n", openaiAPIKey];
  const summary = await launch_python(pythonPath, scriptPath, scriptName, args);
  let new_summary = String(summary);
  new_summary = new_summary.replace(/,-/g, "\n-");
  title = title.toString();
  let leading_text = "";
  let replacement = "";
  let tailing_text = "";
  if (substrings) {
    leading_text = substrings[0] + "\n" + title + "\n";
    for (let substring of substrings.slice(1)) {
      tailing_text = tailing_text + "\n" + substring;
    }
    replacement = leading_text + "#gpt_summarized, #review \n" + new_summary + "\n# Stop Indexing \n## Notes\n" + tailing_text;
    return [replacement, new_summary, title];
  } else {
    return [text, text, ""];
  }
}
function create_notice() {
  new import_obsidian2.Notice("Nice to meet you!");
}
function extract_title_and_note(text) {
  let pattern = /^# .*\n/gm;
  let matches = text.match(pattern);
  let title = "";
  if (matches) {
    title = matches[0];
  }
  let substrings = text.split(pattern);
  console.log(`Title: ${title}`);
  console.log(substrings);
  return [title, substrings];
}
async function update_affinity(note, entity_name, scriptName) {
  const scriptPath = scriptPath_AI;
  if (scriptName == "affinity_vc_helper.py") {
    var args = [entity_name, note, affinityAPIKey, owner_value, connection_owner_field, venture_network_list];
  } else {
    var args = [entity_name, note, affinityAPIKey, owner_value];
  }
  console.log("Update Affinity");
  const response = await launch_python(pythonPath, scriptPath, scriptName, args);
  console.log(response);
  return response;
}
function vc_ready_for_affinity(file_content) {
  return file_content.includes("#gpt_summarized") && file_content.includes("#Affinity");
}
function startup_ready_for_affinity(file_content) {
  return file_content.includes("#startups/screened") && file_content.includes("#Affinity");
}
function notify_for_missing_people(person_name, response) {
  for (let item of response) {
    if (item.includes("Oops")) {
      new import_obsidian2.Notice(`Person: ${person_name} was not found`, 36e3);
      return true;
    }
  }
  return false;
}
function notify_for_missing_startups(startup_name, response) {
  for (let item of response) {
    if (item.includes("Error")) {
      new import_obsidian2.Notice(`Startup: ${startup_name} was found but could not be updated`, 36e3);
      return true;
    } else if (item.includes("Startup")) {
      new import_obsidian2.Notice(`Startup: ${startup_name} could not be found`, 36e3);
      return true;
    }
  }
  return false;
}
async function push_vcs_to_affinity() {
  const files = this.app.vault.getMarkdownFiles();
  for (let item of files) {
    let file_content = await this.app.vault.read(item);
    if (vc_ready_for_affinity(file_content)) {
      let [title, substrings] = extract_title_and_note(file_content);
      let summary = substrings[1];
      let person_name = String(title);
      let scriptName = "affinity_vc_helper.py";
      let response = await update_affinity(summary, person_name, scriptName);
      if (!notify_for_missing_people(person_name, response)) {
        new import_obsidian2.Notice(`VC: ${person_name} was updated on Affinity`);
        file_content = file_content.replace(/#Affinity/g, "");
        this.app.vault.modify(item, file_content);
      }
    }
  }
}
async function push_startups_to_affinity() {
  const files = this.app.vault.getMarkdownFiles();
  for (let item of files) {
    let file_content = await this.app.vault.read(item);
    if (startup_ready_for_affinity(file_content)) {
      let [title, substrings] = extract_title_and_note(file_content);
      let startup_name = String(title);
      let note = substrings[1];
      let scriptName = "affinity_startup_helper.py";
      let response = await update_affinity(note, startup_name, scriptName);
      if (!notify_for_missing_startups(startup_name, response)) {
        new import_obsidian2.Notice(`Startup: ${startup_name} was updated on Affinity`);
        file_content = file_content.replace(/#Affinity/g, "");
        this.app.vault.modify(item, file_content);
      }
    }
  }
  new import_obsidian2.Notice("Done!");
}
function is_summarizable(file_content) {
  return file_content.includes("#network/connected") && (file_content.includes("#Entity/VC") || file_content.includes("#Person/VC")) && file_content.includes("#gpt_summarized") != true && file_content.includes("dataview") != true;
}
function save_json(file_path, content) {
  const jsonString = JSON.stringify(content);
  fs.writeFile(file_path, jsonString, (err) => {
    if (err) {
      console.error(`Error saving the file: ${err}`);
      return;
    }
    console.log("File has been created");
  });
}
function append_to_json(file_path, key, value) {
  fs.readFile(file_path, (err, data) => {
    if (err) {
      throw err;
    }
    let oldData;
    try {
      oldData = JSON.parse(data);
    } catch (e) {
      oldData = {};
    }
    oldData[key] = value;
    const updatedJson = JSON.stringify(oldData);
    fs.writeFile(file_path, updatedJson, (err2) => {
      if (err2)
        throw err2;
      console.log("Data appended to file");
    });
  });
}
var DEFAULT_SETTINGS = {
  vaultPath: "default",
  affinityKey: "default",
  openAIKey: "default",
  owner_person_value: "10",
  connection_owner_field_id: "100",
  venture_network_list_id: "500",
  pythonPath: "<path-to-virtual-env>"
};
var VCWizardPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.status = this.addStatusBarItem();
    this.registerView(WIZARD_VIEW, (leaf) => new WizardView(leaf));
    this.app.workspace.onLayoutReady(() => {
      this.activateView();
      this.updateView([]);
    });
    this.registerEvent(this.app.vault.on("modify", (file) => this.register_file_change(file, "modified" /* modified */)));
    this.registerEvent(this.app.vault.on("delete", (file) => this.register_file_change(file, "deleted" /* deleted */)));
    this.addRibbonIcon("sun", "Omar Plugin", create_notice);
    this.addCommand({ id: "summarize-startup-command", name: "Summarize This Startup", editorCallback: (editor, view) => summarize_selected_startup_text(editor, view) });
    this.addCommand({ id: "index-vault", name: "Index Vault", callback: () => this.index_vault() });
    this.addCommand({ id: "index-changed-files", name: "Reindex New/Changed Files Only", callback: () => this.index_new_and_modified_files() });
    this.addCommand({ id: "find-similar-ideas", name: "Find Similar Ideas", editorCallback: (editor, view) => this.find_similar_ideas(editor, view) });
    this.addCommand({ id: "summarize-all-vc-command", name: "Summarize All VC Notes", callback: () => this.summarize_all_vc() });
    this.addCommand({ id: "affinity-vc", name: "Push VCs to Affinity", callback: () => push_vcs_to_affinity() });
    this.addCommand({ id: "affinity-startup", name: "Push Startups to Affinity", callback: () => push_startups_to_affinity() });
    this.addSettingTab(new SampleSettingTab(this.app, this));
    this.status.setText("\u{1F9D9}: VC Wizard ready");
    this.status.setAttr("title", "Wizard is ready");
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(WIZARD_VIEW);
    this.status.setText("\u{1F9D9}: VC Wizard left");
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(WIZARD_VIEW);
    await this.app.workspace.getRightLeaf(false).setViewState({
      type: WIZARD_VIEW,
      active: true
    });
    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(WIZARD_VIEW)[0]);
  }
  async updateView(results) {
    var _a;
    const view = (_a = this.app.workspace.getLeavesOfType(WIZARD_VIEW)[0]) == null ? void 0 : _a.view;
    if (view instanceof WizardView) {
      view.update(results);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    scriptPath_AI = this.settings.vaultPath + ".obsidian/plugins/vc_wizard";
    openaiAPIKey = this.settings.openAIKey;
    affinityAPIKey = this.settings.affinityKey;
    owner_value = this.settings.owner_person_value;
    connection_owner_field = this.settings.connection_owner_field_id;
    venture_network_list = this.settings.venture_network_list_id;
    pythonPath = this.settings.pythonPath;
  }
  async saveSettings() {
    await this.saveData(this.settings);
    scriptPath_AI = this.settings.vaultPath + ".obsidian/plugins/vc_wizard";
    openaiAPIKey = this.settings.openAIKey;
    affinityAPIKey = this.settings.affinityKey;
    owner_value = this.settings.owner_person_value;
    connection_owner_field = this.settings.connection_owner_field_id;
    venture_network_list = this.settings.venture_network_list_id;
    pythonPath = this.settings.pythonPath;
  }
  async summarize_all_vc() {
    const files = this.app.vault.getMarkdownFiles();
    for (let item of files) {
      let file_content = await this.app.vault.read(item);
      if (is_summarizable(file_content)) {
        console.log(`We are changing file: ${item.name}`);
        let [new_text, summary, title] = await summarize_vc_text(file_content);
        if (title != "") {
          this.app.vault.modify(item, new_text);
          new import_obsidian2.Notice(`${title} has been summarized`);
        }
      }
    }
  }
  async find_similar_ideas(editor, view) {
    const sel = editor.getSelection();
    new import_obsidian2.Notice("Search in progress...");
    let scriptPath = scriptPath_AI;
    const scriptName = "similar_ideas.py";
    var args = [sel, openaiAPIKey, this.settings.vaultPath];
    const similar_ideas = await launch_python(pythonPath, scriptPath, scriptName, args);
    let search_results = await this.extract_title_and_path(similar_ideas);
    this.updateView(search_results);
  }
  async register_file_change(file, type) {
    let scriptPath = scriptPath_AI;
    const scriptName = "index_vault.py";
    const plugin_path = scriptPath_AI;
    let base_name = file.name.split(".md")[0];
    let file_path = this.settings.vaultPath + file.path;
    let storage_path = plugin_path + "/modified_paths.json";
    if (type == "modified" /* modified */) {
      let value = { "change_type": "modified" /* modified */, "full_path": file_path };
      append_to_json(storage_path, base_name, value);
    } else if (type == "deleted" /* deleted */) {
      new import_obsidian2.Notice(`${base_name} has been deleted`);
      let value = { "change_type": "deleted" /* deleted */, "full_path": file_path };
      append_to_json(storage_path, base_name, value);
    } else if (type == "new" /* new */) {
      new import_obsidian2.Notice(`${base_name} has been created`);
      let value = { "change_type": "new" /* new */, "full_path": file_path };
      append_to_json(storage_path, base_name, value);
    }
  }
  async index_new_and_modified_files() {
    const plugin_path = scriptPath_AI;
    let storage_path = plugin_path + "/modified_paths.json";
    fs.readFile(storage_path, async (err, data) => {
      if (err) {
        throw err;
      }
      let files_to_modify;
      new import_obsidian2.Notice("Will read changed files now..");
      this.status.setText("\u{1F9D9}: VC Wizard indexing...");
      this.status.setAttr("title", "Wizard is indexing your vault...");
      try {
        files_to_modify = JSON.parse(data);
        console.log(files_to_modify);
      } catch (e) {
        new import_obsidian2.Notice("No new notes to index");
        this.status.setText("\u{1F9D9}: VC Wizard ready");
        this.status.setAttr("title", "VC Wizard is ready");
        return;
      }
      if (Object.keys(files_to_modify).length < 1) {
        new import_obsidian2.Notice("No new notes to index");
        this.status.setText("\u{1F9D9}: VC Wizard ready");
        this.status.setAttr("title", "VC Wizard is ready");
        return;
      }
      try {
        await this.index_files(storage_path);
      } catch (e) {
        new import_obsidian2.Notice("There was an error while indexing!");
        this.status.setText("\u{1F9D9}: VC Wizard ready");
        this.status.setAttr("title", "VC Wizard is ready");
        return;
      }
      new import_obsidian2.Notice("Finished indexing!");
      this.status.setText("\u{1F9D9}: VC Wizard ready");
      this.status.setAttr("title", "VC Wizard is ready");
      save_json(storage_path, {});
    });
  }
  async index_vault() {
    let files = this.app.vault.getMarkdownFiles();
    let file_paths = {};
    let vault_path = this.settings.vaultPath;
    const plugin_path = scriptPath_AI;
    new import_obsidian2.Notice("Started indexing the full vault!");
    this.status.setText("\u{1F9D9}: VC Wizard indexing...");
    this.status.setAttr("title", "Wizard is indexing your vault...");
    for (let file of files) {
      if (file.path.includes("Readwise")) {
        file_paths[file.basename] = { "change_type": "new" /* new */, "full_path": vault_path + file.path };
      }
    }
    console.log(`Files length: ${file_paths.length}`);
    const json_path = plugin_path + "/file_paths.json";
    save_json(json_path, file_paths);
    try {
      await this.index_files(json_path);
    } catch (e) {
      new import_obsidian2.Notice("There was an error while indexing!");
      return;
    }
    new import_obsidian2.Notice("Finished indexing!");
    this.status.setText("\u{1F9D9}: VC Wizard ready");
    this.status.setAttr("title", "VC Wizard is ready");
    save_json(json_path, {});
  }
  async index_files(json_path) {
    let scriptPath = scriptPath_AI;
    const scriptName = "index_vault.py";
    const plugin_path = scriptPath_AI;
    var args = [json_path, openaiAPIKey, plugin_path];
    let results = await launch_python(pythonPath, scriptPath, scriptName, args);
    console.log(results);
    this.status.setText("\u{1F9D9}: VC Wizard ready");
    this.status.setAttr("title", "VC Wizard is ready");
    return results;
  }
  async extract_title_and_path(results) {
    var _a;
    let counter = 0;
    let search_results = {};
    let current_filename = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.basename;
    console.log(`current filename: ${current_filename}`);
    for (let result of results) {
      if (counter % 3 == 0 && counter != 0) {
        let sentence = '"' + results.at(counter) + '"';
        let source = results.at(counter + 2);
        source = source == null ? void 0 : source.split(":")[1].trim();
        console.log(`counter: ${counter}, This source: ${source}`);
        if (source == current_filename) {
          counter = counter + 1;
          continue;
        }
        let source_file = await this.get_path_by_name(source);
        console.log(source_file);
        if (source_file != null && source != null) {
          let obsidian_path = "obsidian://advanced-uri?vault=";
          obsidian_path = obsidian_path + this.app.vault.getName() + "&filepath=";
          obsidian_path = obsidian_path + source_file.path;
          console.log(`my source path: ${obsidian_path}`);
          search_results[source] = { "source_path": obsidian_path, "text": sentence };
        }
      }
      counter = counter + 1;
    }
    return search_results;
  }
  async get_path_by_name(source) {
    let all_files = this.app.vault.getMarkdownFiles();
    for (let file of all_files) {
      let filename = file.basename;
      if (filename == source) {
        return file;
      }
    }
    return null;
  }
};
var SampleSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for your butler" });
    new import_obsidian2.Setting(containerEl).setName("Obsidian Vault Path").setDesc("The path to the vault where you wish to use the plugin").addText((text) => text.setPlaceholder("Enter path").setValue(this.plugin.settings.vaultPath).onChange(async (value) => {
      console.log("path: " + value);
      this.plugin.settings.vaultPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API Key").addText((text) => text.setPlaceholder("Enter key").setValue(this.plugin.settings.openAIKey).onChange(async (value) => {
      console.log("Open AI key: " + value);
      this.plugin.settings.openAIKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Affinity: API Key").setDesc("Your Affinity API Key").addText((text) => text.setPlaceholder("Enter key").setValue(this.plugin.settings.affinityKey).onChange(async (value) => {
      console.log("key: " + value);
      this.plugin.settings.affinityKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Affinity: Owner Value").setDesc("Every person has a code on Affinity. Please give in the code for the person that should be added as owner of startups and VCs that gets pushed").addText((text) => text.setPlaceholder("Enter value").setValue(this.plugin.settings.owner_person_value).onChange(async (value) => {
      console.log("Owner value: " + value);
      this.plugin.settings.owner_person_value = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Affinity: Connection Owner Field ID").setDesc("Depending on the list you save fellow VCs in, there is a field that represent the 'connection owner with the fund', enter the field id here").addText((text) => text.setPlaceholder("Enter value").setValue(this.plugin.settings.connection_owner_field_id).onChange(async (value) => {
      console.log("Connection Owner Field ID value: " + value);
      this.plugin.settings.connection_owner_field_id = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Affinity: Venture Network List ID").setDesc("Please enter the list id for the list you save your relationships with VCs in").addText((text) => text.setPlaceholder("Enter value").setValue(this.plugin.settings.venture_network_list_id).onChange(async (value) => {
      console.log("Venture network list id: " + value);
      this.plugin.settings.venture_network_list_id = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Python Virtual Environment Path").setDesc("The path to python virtual environment").addText((text) => text.setPlaceholder("Enter path").setValue(this.plugin.settings.pythonPath).onChange(async (value) => {
      console.log("PythonPath: " + value);
      this.plugin.settings.pythonPath = value;
      await this.plugin.saveSettings();
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL3B5dGhvbi1zaGVsbC9pbmRleC50cyIsICJtYWluLnRzIiwgInZpZXcudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbbnVsbCwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBNYXJrZG93blZpZXcsIE1vZGFsLCBOb3RpY2UsIFBsdWdpbiwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgTWVudSwgTWVudUl0ZW0sIE1hcmtkb3duRmlsZUluZm8sIFRGaWxlLCBUQWJzdHJhY3RGaWxlfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBXaXphcmRWaWV3LCBXSVpBUkRfVklFVyB9IGZyb20gJ3ZpZXcnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuXG5sZXQgcHl0aG9uUGF0aCA9ICcnXG5sZXQgc2NyaXB0UGF0aF9BSSA9ICcnXG5sZXQgYWZmaW5pdHlBUElLZXkgPSAnJ1xubGV0IG9wZW5haUFQSUtleSA9ICcnXG5sZXQgb3duZXJfdmFsdWUgPSAnMTAnXG5sZXQgY29ubmVjdGlvbl9vd25lcl9maWVsZCA9ICcxMCdcbmxldCB2ZW50dXJlX25ldHdvcmtfbGlzdCA9ICc1MDAnXG5cblxuXG5hc3luYyBmdW5jdGlvbiBzdW1tYXJpemVfc2VsZWN0ZWRfc3RhcnR1cF90ZXh0KGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXd8TWFya2Rvd25GaWxlSW5mbyl7XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyB0aGUgc2VsZWN0ZWQgdGV4dCBmcm9tIGEgc3RhcnR1cCwgc3VtbWFyaXplcyBpdCwgYW5kIHRoZW4gcHV0cyBpdCBiYWNrIGluIHRoZSBmaWxlXG4gICAgICogVGhlIFwiZnVsbC10ZXh0XCIgZ2V0cyBhcHBlbmVkIGFmdGVyIHRoZSBoZWFkaW5nICcjIFN0b3AgSW5kZXhpbmcnIHN1Y2ggdGhhdCBpdCBpcyBub3QgaW5kZXhlZCBhbnltb3JlIGJ5IHRoZSBlbWJlZGRpbmcgZW5naW5lXG4gICAgICogVGhpcyBhbHNvIGhlbHBzIHRvIGF2b2lkIHB1c2hpbmcgYWxsIG9mIHRoZSBjb252b2x1dGVkIHRleHQgaW50byBBZmZpbml0eSBsYXRlciBvblxuICAgICAqL1xuICAgIGNvbnN0IHNlbCA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKVxuICAgIC8vY29uc29sZS5sb2coYFlvdXIgVGV4dDogJHtzZWx9YClcbiAgICBsZXQgc2NyaXB0UGF0aCA9IHNjcmlwdFBhdGhfQUlcbiAgICBjb25zdCBzY3JpcHROYW1lID0gJ3N0YXJ0dXBfc3VtbWFyaXplcl9oZWxwZXIucHknXG4gICAgdmFyIGFyZ3MgPSBbc2VsLCBvcGVuYWlBUElLZXldXG4gICAgbmV3IE5vdGljZShcIlN1bW1hcml6aW5nLi4uXCIpXG4gICAgLy9XZSBkZWNsYXJlIGdldF9zZWxlY3RlZF90ZXh0IGFzIGEgZnVuY3Rpb24gdGhhdCBcIldBSVRTXCIgKGFzeW5jKSwgYW5kIHdlIHdhaXQgZm9yIHRoZSByZXN1bHQgaGVyZVxuICAgIGNvbnN0IHN1bW1hcnkgPSBhd2FpdCBsYXVuY2hfcHl0aG9uKHB5dGhvblBhdGgsIHNjcmlwdFBhdGgsIHNjcmlwdE5hbWUsIGFyZ3MpXG5cbiAgICBsZXQgbmV3X3N1bW1hcnk6IHN0cmluZyA9IFN0cmluZyhzdW1tYXJ5KVxuICAgIC8vQ3JlYXRlIG5ldyBsaW5lcyBpbiB0aGUgc3VtbWFyeSAoc29tZWhvdyBpdCBnZXRzIGxvc3QgYmV0d2VlbiBQeXRob24gYW5kIEphdmFzY3JpcHQpXG4gICAgbmV3X3N1bW1hcnkgPSBuZXdfc3VtbWFyeS5yZXBsYWNlKC8sLS9nLCAnXFxuLScpXG4gICAgY29uc29sZS5sb2coYFRoZSBzdGFydHVwIHN1bW1hcnk6XFxuICR7bmV3X3N1bW1hcnl9YClcblxuICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gJyNncHRfc3VtbWFyaXplZCwgI3Jldmlld19zdGFydHVwIFxcbicrIG5ld19zdW1tYXJ5ICsgJ1xcbicgKyAnIyBTdG9wIEluZGV4aW5nIFxcbiMjIE5vdGVzXFxuJyArIHNlbFxuICAgIGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKHJlcGxhY2VtZW50KVxuXG59XG5cblxuXG5hc3luYyBmdW5jdGlvbiBsYXVuY2hfcHl0aG9uKHB5dGhvblBhdGg6IHN0cmluZywgc2NyaXB0UGF0aDogc3RyaW5nLCBzY3JpcHROYW1lOiBzdHJpbmcsIGFyZ3M6IGFueSl7XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBsYXVuY2hlcyBhIHB5dGhvbiBzY3JpcHQgd2l0aCB0aGUgY29ycmVjdCBweXRob24gdmlydHVhbCBlbnZpcm9ubWVudCBhbmQgcmV0dXJucyB3aGF0ZXZlciB0aGUgcHl0aG9uIHNjcmlwdCBwcmludHMhISAobm8gdmFsdWUgcGFzc2luZywgdGFrZSBjYXJlKVxuICAgICAqL1xuICAgIGxldCB7UHl0aG9uU2hlbGx9ID0gcmVxdWlyZSgncHl0aG9uLXNoZWxsJylcbiAgICBjb25zdCBvcHRpb25zID0ge21vZGU6ICd0ZXh0JywgcHl0aG9uUGF0aDogcHl0aG9uUGF0aCwgc2NyaXB0UGF0aDogc2NyaXB0UGF0aCwgYXJnczogYXJnc31cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBQeXRob25TaGVsbC5ydW4oc2NyaXB0TmFtZSwgb3B0aW9ucywgZnVuY3Rpb24gKGVycjogRXJyb3IsIHJlc3VsdHM6IGFueSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0XG5cbn1cblxuXG5hc3luYyBmdW5jdGlvbiBzdW1tYXJpemVfdmNfdGV4dCh0ZXh0OiBzdHJpbmcpe1xuICAgIC8qKlxuICAgICAqIEdpdmVuIHRoZSBmdWxsIHRleHQgaW4gYSBWQyBub3RlLCB0aGlzIGZ1bmN0aW9uIHN1bW1hcml6ZXMgdGhlIGltcG9ydGFudCBwYXJ0IChiZWZvcmUgIyBTdG9wIEluZGV4aW5nKSBhbmQgcmV0dXJucyB0aGUgbmV3IGZ1bGwgdGV4dCB0aGF0IHNob3VsZCBiZSB3cml0dGVuIHRvIHRoZSBmaWxlXG4gICAgICogVGhlIGZ1bGwgdGV4dCBpbmNsdWRlcyB0aGUgbWV0YSBkYXRhIGFuZCB0YWdzIGluZm9ybWF0aW9uIGJlZm9yZSB0aGUgdGl0bGUsIHRoZSB0aXRsZSwgdGhlIHN1bW1hcnksIGFuZCBhZGRzIHRoZSBjb3JlIGRhdGEgYWZ0ZXIgdGhlIGhlYWRpbmcgXCIjIFN0b3AgSW5kZXhpbmdcIlxuICAgICAqL1xuICAgIGNvbnN0IHNjcmlwdFBhdGggPSBzY3JpcHRQYXRoX0FJXG4gICAgY29uc3Qgc2NyaXB0TmFtZSA9ICd2Y19zdW1tYXJpemVyX2hlbHBlci5weSdcblxuICAgIC8vIFdlIHNob3VsZCBzdW1tYXJpemUgb25seSBpbmZvcm1hdGlvbiB0aGF0IGlzIGJlZm9yZSAnIyBTdG9wIEluZGV4aW5nJ1xuICAgIGxldCBbdGl0bGUsIHN1YnN0cmluZ3NdID0gZXh0cmFjdF90aXRsZV9hbmRfbm90ZSh0ZXh0KVxuICAgIGxldCB0ZXh0X3RvX3N1bW1hcml6ZSA9IHN1YnN0cmluZ3NbMF0gKyAnXFxuJyArIHN1YnN0cmluZ3NbMV1cblxuICAgIGNvbnNvbGUubG9nKGBTdW1tYXJpemluZzogJHt0aXRsZX1gKVxuICAgIC8vY29uc29sZS5sb2coXCJUZXh0IHRvIHN1bW1hcml6ZTogXCIpXG4gICAgLy9jb25zb2xlLmxvZyh0ZXh0X3RvX3N1bW1hcml6ZSlcblxuICAgIHZhciBhcmdzID0gWydOb3RlczpcXG4nICsgdGV4dF90b19zdW1tYXJpemUgKyAnU3VtbWFyeTpcXG4nLCBvcGVuYWlBUElLZXldIC8vdGV4dFxuICAgIC8vV2UgZGVjbGFyZSBnZXRfc2VsZWN0ZWRfdGV4dCBhcyBhIGZ1bmN0aW9uIHRoYXQgXCJXQUlUU1wiIChhc3luYyksIGFuZCB3ZSB3YWl0IGZvciB0aGUgcmVzdWx0IGhlcmVcbiAgICBcbiAgICBjb25zdCBzdW1tYXJ5ID0gYXdhaXQgbGF1bmNoX3B5dGhvbihweXRob25QYXRoLCBzY3JpcHRQYXRoLCBzY3JpcHROYW1lLCBhcmdzKVxuICAgIGxldCBuZXdfc3VtbWFyeTogc3RyaW5nID0gU3RyaW5nKHN1bW1hcnkpXG4gICAgLy9TZXBhcmF0ZSBkaWZmZXJlbnQgYnVsbGV0IHBvaW50c1xuICAgIG5ld19zdW1tYXJ5ID0gbmV3X3N1bW1hcnkucmVwbGFjZSgvLC0vZywgJ1xcbi0nKVxuXG4gICAgXG4gICAgdGl0bGUgPSB0aXRsZS50b1N0cmluZygpXG4gICAgbGV0IGxlYWRpbmdfdGV4dCA9ICcnXG4gICAgbGV0IHJlcGxhY2VtZW50ID0gJydcbiAgICBsZXQgdGFpbGluZ190ZXh0ID0gJydcblxuICAgIC8qY29uc29sZS5sb2coYFRpdGxlOiAke3RpdGxlfWApXG4gICAgY29uc29sZS5sb2coYEJlZm9yZSB0aGUgdGl0bGU6XFxuJHtzdWJzdHJpbmdzWzBdfWApXG4gICAgY29uc29sZS5sb2coYEFmdGVyIHRoZSB0aXRsZTogJHtzdWJzdHJpbmdzWzFdfWApKi9cblxuICAgIGlmKHN1YnN0cmluZ3Mpe1xuICAgICAgICBsZWFkaW5nX3RleHQgPSBzdWJzdHJpbmdzWzBdICsgJ1xcbicgKyB0aXRsZSArICdcXG4nXG4gICAgICAgIGZvciAobGV0IHN1YnN0cmluZyBvZiBzdWJzdHJpbmdzLnNsaWNlKDEpKXtcbiAgICAgICAgICAgIHRhaWxpbmdfdGV4dCA9IHRhaWxpbmdfdGV4dCArICdcXG4nICsgc3Vic3RyaW5nXG4gICAgICAgIH1cbiAgICAgICAgcmVwbGFjZW1lbnQgPSBsZWFkaW5nX3RleHQgKyAnI2dwdF9zdW1tYXJpemVkLCAjcmV2aWV3IFxcbicrIG5ld19zdW1tYXJ5ICsgJ1xcbicgKyAnIyBTdG9wIEluZGV4aW5nIFxcbiMjIE5vdGVzXFxuJyArIHRhaWxpbmdfdGV4dFxuICAgICAgICByZXR1cm4gW3JlcGxhY2VtZW50LCBuZXdfc3VtbWFyeSwgdGl0bGVdXG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIHJldHVybiBbdGV4dCwgdGV4dCwgJyddXG5cbiAgICB9XG5cbiAgICBcbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVfbm90aWNlKCl7XG4gICAgbmV3IE5vdGljZShcIk5pY2UgdG8gbWVldCB5b3UhXCIpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RfdGl0bGVfYW5kX25vdGUodGV4dDogc3RyaW5nKXtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFsbCB0aGUgdGV4dCBpbiB0aGUgZmlsZSBhbmQgcmV0dXJucyB0aGUgdGl0bGUgYW5kIHRoZSBib2R5IG9mIHRoZSBub3RlLlxuICAgICAqIFRoZSBzcGxpdCBoYXBwZW5zIGJhc2VkIG9uIGgxIGhlYWRlci4gXG4gICAgICogVGhpcyBtZWFucyBzdWJzdHJpbmdzWzBdIGlzIHVzdWFsbHkgdGhlIGRhdGEgYmVmb3JlIHRoZSB0aXRsZS5cbiAgICAgKiBzdWJzdHJpbmdzWzFdIGlzIHVzdWFsbHkgdGhlIGJvZHkgb2YgdGhlIG5vdGVcbiAgICAgKiBpZiB0aGVyZSBpcyBzdWJzdHJpbmcgWzJdLCB0aGlzIG1lYW5zIHRoZXJlIGlzIGFub3RoZXIgaDEgaGVhZGVyICh1c3VhbGx5ICMgU3RvcCBJbmRleGluZylcbiAgICAgKiBEb3duc3RyZWFtIHRhc2tzIG9ubHkgZGVhbHMgd2l0aCBzdWJzdHJpbmdbMV0gYXMgdGhlIG5vdGU7IGkuZSBpbmZvcm1hdGlvbiBhZnRlciB0aGUgU3RvcCBJbmRleGluZyBhcmUgZXhlY2x1ZGVkXG4gICAgICovXG5cbiAgICAgICAgLy8/Z20gbWVhbnMgc3RyaW5nIGlzIG11bHRpbGluZXMsIGFuZCBeIHdvdWxkIGNhdGNoIGJlZ2lubmluZyBvZiBldmVyeSBsaW5lIG5vdCBqdXN0IGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nIVxuICAgICAgICBsZXQgcGF0dGVybiA9IC9eIyAuKlxcbi9nbTtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSB0ZXh0Lm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICBsZXQgdGl0bGUgPSAnJ1xuICAgICAgICBpZihtYXRjaGVzKXtcbiAgICAgICAgICAgIHRpdGxlID0gbWF0Y2hlc1swXVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJzdHJpbmdzID0gdGV4dC5zcGxpdChwYXR0ZXJuKVxuICAgICAgICBjb25zb2xlLmxvZyhgVGl0bGU6ICR7dGl0bGV9YClcbiAgICAgICAgY29uc29sZS5sb2coc3Vic3RyaW5ncylcblxuICAgICAgICByZXR1cm4gW3RpdGxlLCBzdWJzdHJpbmdzXVxuXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3Rfc3VtbWFyeShmdWxsX25vdGU6c3RyaW5nKXtcbiAgICAvL1doZW4gYSBub3RlIGlzIHJlYWR5IChoYXMgZ3B0X3N1bW1hcml6ZWQgYW5kIEFmZmluaXR5IHRhZ3MpLCBleHRyYWN0IHRoZSBzdW1tYXJ5IGZyb20gZnVsbCB0ZXh0XG4gICAgbGV0IHN1YnN0cmluZ3MgPSBmdWxsX25vdGUuc3BsaXQoJyMgU3RvcCBJbmRleGluZycpXG4gICAgbGV0IHN1bW1hcnkgPSBzdWJzdHJpbmdzWzBdXG4gICAgLy9jb25zb2xlLmxvZyhgU3VtbWFyeTogJHtzdW1tYXJ5fWApXG4gICAgcmV0dXJuIHN1bW1hcnlcbn1cblxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlX2FmZmluaXR5KG5vdGU6IHN0cmluZywgZW50aXR5X25hbWU6c3RyaW5nLCBzY3JpcHROYW1lOiBzdHJpbmcpe1xuICAgIGNvbnN0IHNjcmlwdFBhdGggPSBzY3JpcHRQYXRoX0FJXG4gICAgaWYgKHNjcmlwdE5hbWUgPT0gJ2FmZmluaXR5X3ZjX2hlbHBlci5weScpe1xuICAgICAgICB2YXIgYXJncyA9IFtlbnRpdHlfbmFtZSwgbm90ZSwgYWZmaW5pdHlBUElLZXksIG93bmVyX3ZhbHVlLCBjb25uZWN0aW9uX293bmVyX2ZpZWxkLCB2ZW50dXJlX25ldHdvcmtfbGlzdF1cblxuICAgIH1cbiAgICBlbHNle1xuICAgICAgICB2YXIgYXJncyA9IFtlbnRpdHlfbmFtZSwgbm90ZSwgYWZmaW5pdHlBUElLZXksIG93bmVyX3ZhbHVlXVxuXG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiVXBkYXRlIEFmZmluaXR5XCIpXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBsYXVuY2hfcHl0aG9uKHB5dGhvblBhdGgsIHNjcmlwdFBhdGgsIHNjcmlwdE5hbWUsIGFyZ3MpXG5cbiAgICBjb25zb2xlLmxvZyhyZXNwb25zZSlcbiAgICByZXR1cm4gcmVzcG9uc2VcblxufVxuXG5mdW5jdGlvbiB2Y19yZWFkeV9mb3JfYWZmaW5pdHkoZmlsZV9jb250ZW50OiBzdHJpbmcpe1xuICAgIHJldHVybiBmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNncHRfc3VtbWFyaXplZCcpICYmIGZpbGVfY29udGVudC5pbmNsdWRlcygnI0FmZmluaXR5Jylcbn1cblxuZnVuY3Rpb24gc3RhcnR1cF9yZWFkeV9mb3JfYWZmaW5pdHkoZmlsZV9jb250ZW50OiBzdHJpbmcpe1xuICAgIHJldHVybiAoZmlsZV9jb250ZW50LmluY2x1ZGVzKCcjc3RhcnR1cHMvc2NyZWVuZWQnKSAmJiBmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNBZmZpbml0eScpKVxufVxuXG5mdW5jdGlvbiBub3RpZnlfZm9yX21pc3NpbmdfcGVvcGxlKHBlcnNvbl9uYW1lOiBzdHJpbmcsIHJlc3BvbnNlOiBhbnkpe1xuICAgIC8qKlxuICAgICAqIElmIGEgcGVyc29uIGlzIG5vdCBmb3VuZCBpbiBhZmZpbml0eSwgc2VuZCBhIG5vdGlmaWNhdGlvbiBhbmQgcmV0dXJuIGZhbHNlXG4gICAgICovXG4gICAgZm9yIChsZXQgaXRlbSBvZiByZXNwb25zZSl7XG4gICAgICAgIGlmIChpdGVtLmluY2x1ZGVzKCdPb3BzJykpe1xuICAgICAgICAgICAgbmV3IE5vdGljZShgUGVyc29uOiAke3BlcnNvbl9uYW1lfSB3YXMgbm90IGZvdW5kYCwgMzYwMDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICB9ICAgXG4gICAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIG5vdGlmeV9mb3JfbWlzc2luZ19zdGFydHVwcyhzdGFydHVwX25hbWU6IHN0cmluZywgcmVzcG9uc2U6IGFueSl7XG4gICAgZm9yIChsZXQgaXRlbSBvZiByZXNwb25zZSl7XG4gICAgICAgIGlmKGl0ZW0uaW5jbHVkZXMoJ0Vycm9yJykpe1xuICAgICAgICAgICAgbmV3IE5vdGljZShgU3RhcnR1cDogJHtzdGFydHVwX25hbWV9IHdhcyBmb3VuZCBidXQgY291bGQgbm90IGJlIHVwZGF0ZWRgLCAzNjAwMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXRlbS5pbmNsdWRlcygnU3RhcnR1cCcpKXtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFN0YXJ0dXA6ICR7c3RhcnR1cF9uYW1lfSBjb3VsZCBub3QgYmUgZm91bmRgLCAzNjAwMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHB1c2hfdmNzX3RvX2FmZmluaXR5KCl7XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBwdXNoZXMgYWxsIHJlYWR5IFZDcyB0byBhZmZpbml0eSwgaXQgYWxzbyBub3RpZmllcyB1cyBpZiBhIHBlcnNvbiBjYW4gbm90IGJlIGZvdW5kIG9uIGFmZmluaXR5XG4gICAgICovXG4gICAgY29uc3QgZmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKClcbiAgICBmb3IgKGxldCBpdGVtIG9mIGZpbGVzKXtcbiAgICAgICAgbGV0IGZpbGVfY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoaXRlbSlcbiAgICAgICAgaWYgKHZjX3JlYWR5X2Zvcl9hZmZpbml0eShmaWxlX2NvbnRlbnQpKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IFt0aXRsZSwgc3Vic3RyaW5nc10gPSBleHRyYWN0X3RpdGxlX2FuZF9ub3RlKGZpbGVfY29udGVudClcbiAgICAgICAgICAgIGxldCBzdW1tYXJ5ID0gc3Vic3RyaW5nc1sxXSAvL2V4dHJhY3Rfc3VtbWFyeShzdWJzdHJpbmdzWzFdKVxuICAgICAgICAgICAgbGV0IHBlcnNvbl9uYW1lID0gU3RyaW5nKHRpdGxlKVxuICAgICAgICAgICAgbGV0IHNjcmlwdE5hbWUgPSAnYWZmaW5pdHlfdmNfaGVscGVyLnB5J1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlOiBhbnkgPSBhd2FpdCB1cGRhdGVfYWZmaW5pdHkoc3VtbWFyeSwgcGVyc29uX25hbWUsIHNjcmlwdE5hbWUpXG4gICAgICAgICAgICBpZiAoIW5vdGlmeV9mb3JfbWlzc2luZ19wZW9wbGUocGVyc29uX25hbWUsIHJlc3BvbnNlKSl7XG4gICAgICAgICAgICAgICAgLy9pZiB0aGUgcGVyc29uIHdhcyB1cGRhdGVkIG9uIGFmZmluaXR5IHN1Y2Nlc3NmdWx5IGFuZCBub3QgbWlzc2luZyBmcm9tIGRhdGFiYXNlLCByZW1vdmUgI0FmZmluaXR5IGZyb20gdGV4dFxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYFZDOiAke3BlcnNvbl9uYW1lfSB3YXMgdXBkYXRlZCBvbiBBZmZpbml0eWApXG4gICAgICAgICAgICAgICAgZmlsZV9jb250ZW50ID0gZmlsZV9jb250ZW50LnJlcGxhY2UoLyNBZmZpbml0eS9nLCAnJylcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC52YXVsdC5tb2RpZnkoaXRlbSwgZmlsZV9jb250ZW50KVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIFxuXG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIHB1c2hfc3RhcnR1cHNfdG9fYWZmaW5pdHkoKXtcbiAgICAvKipcbiAgICAgKiBQdXNoIGFsbCBlbGlnaWJsZSBzdGFydHVwcyB0byBhZmZpbml0eSAobm90aWZ5IG1lIG90aGVyd2lzZSlcbiAgICAgKi9cbiAgICBjb25zdCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKVxuICAgIGZvciAobGV0IGl0ZW0gb2YgZmlsZXMpe1xuICAgICAgICBsZXQgZmlsZV9jb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChpdGVtKVxuICAgICAgICBpZiAoc3RhcnR1cF9yZWFkeV9mb3JfYWZmaW5pdHkoZmlsZV9jb250ZW50KSl7XG4gICAgICAgICAgICBsZXQgW3RpdGxlLCBzdWJzdHJpbmdzXSA9IGV4dHJhY3RfdGl0bGVfYW5kX25vdGUoZmlsZV9jb250ZW50KVxuICAgICAgICAgICAgbGV0IHN0YXJ0dXBfbmFtZSA9IFN0cmluZyh0aXRsZSlcbiAgICAgICAgICAgIGxldCBub3RlID0gc3Vic3RyaW5nc1sxXVxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhgU3RhcnR1cCBuYW1lOiAke3N0YXJ0dXBfbmFtZX1gKVxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhgTm90ZTogJHtub3RlfWApXG4gICAgICAgICAgICBsZXQgc2NyaXB0TmFtZSA9ICdhZmZpbml0eV9zdGFydHVwX2hlbHBlci5weSdcbiAgICAgICAgICAgIGxldCByZXNwb25zZTogYW55ID0gYXdhaXQgdXBkYXRlX2FmZmluaXR5KG5vdGUsIHN0YXJ0dXBfbmFtZSwgc2NyaXB0TmFtZSlcblxuICAgICAgICAgICAgaWYgKCFub3RpZnlfZm9yX21pc3Npbmdfc3RhcnR1cHMoc3RhcnR1cF9uYW1lLCByZXNwb25zZSkpe1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYFN0YXJ0dXA6ICR7c3RhcnR1cF9uYW1lfSB3YXMgdXBkYXRlZCBvbiBBZmZpbml0eWApXG4gICAgICAgICAgICAgICAgZmlsZV9jb250ZW50ID0gZmlsZV9jb250ZW50LnJlcGxhY2UoLyNBZmZpbml0eS9nLCAnJylcbiAgICAgICAgICAgICAgICB0aGlzLmFwcC52YXVsdC5tb2RpZnkoaXRlbSwgZmlsZV9jb250ZW50KVxuICAgICAgICAgICAgfVxuXG5cblxuICAgICAgICB9XG5cbiAgICB9XG4gICAgbmV3IE5vdGljZSgnRG9uZSEnKVxufVxuXG5mdW5jdGlvbiBpc19zdW1tYXJpemFibGUoZmlsZV9jb250ZW50OiBzdHJpbmcpe1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBWQyBpcyB0byBiZSBzdW1tYXJpemVkIChJIGFtIGNvbm5lY3RlZCB3aXRoIHRoZW0gYW5kIHRoZXkgYXJlIG5vdCBhbHJlYWR5IHN1bW1hcml6ZWQpXG4gICAgICovXG4gICAgcmV0dXJuIGZpbGVfY29udGVudC5pbmNsdWRlcygnI25ldHdvcmsvY29ubmVjdGVkJykgJiYgKCBmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNFbnRpdHkvVkMnKSB8fCBmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNQZXJzb24vVkMnKSApICYmIChmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNncHRfc3VtbWFyaXplZCcpICE9IHRydWUpICYmIChmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJ2RhdGF2aWV3JykgIT0gdHJ1ZSlcblxufVxuXG5mdW5jdGlvbiBzYXZlX2pzb24oZmlsZV9wYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IGFueSl7XG4gICAgY29uc3QganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpXG4gICAgZnMud3JpdGVGaWxlKGZpbGVfcGF0aCwganNvblN0cmluZywgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2F2aW5nIHRoZSBmaWxlOiAke2Vycn1gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ0ZpbGUgaGFzIGJlZW4gY3JlYXRlZCcpO1xuICAgICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZF90b19qc29uKGZpbGVfcGF0aDogc3RyaW5nLCBrZXk6IGFueSwgdmFsdWU6YW55KXtcbiAgICBmcy5yZWFkRmlsZShmaWxlX3BhdGgsIChlcnIsIGRhdGE6IGFueSkgPT4ge1xuICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9sZERhdGEgXG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgb2xkRGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSl7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGZpbGUgaXMgZW1wdHksIGRhdGEgd2lsbCBiZSBhbiBlbXB0eSBzdHJpbmcsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSBKU09OLnBhcnNlKCkgdG8gdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBzZXQgb2xkRGF0YSB0byBhbiBlbXB0eSBvYmplY3QuXG4gICAgICAgICAgICAgICAgb2xkRGF0YSA9IHt9XG4gICAgICAgIH1cbiAgICAgICAgb2xkRGF0YVtrZXldID0gdmFsdWUgLy97J2NoYW5nZV90eXBlJzogRmlsZVR5cGUubW9kaWZpZWQsICdmdWxsX3BhdGgnOiBmaWxlX3BhdGh9IFxuICAgICAgICBjb25zdCB1cGRhdGVkSnNvbiA9IEpTT04uc3RyaW5naWZ5KG9sZERhdGEpXG4gICAgICAgIGZzLndyaXRlRmlsZShmaWxlX3BhdGgsIHVwZGF0ZWRKc29uLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB0aHJvdyBlcnI7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRGF0YSBhcHBlbmRlZCB0byBmaWxlJylcbiAgICAgICAgfSlcblxuXG4gICAgfSk7XG5cbn1cblxuaW50ZXJmYWNlIEJ1dGxlclNldHRpbmdzIHtcblx0dmF1bHRQYXRoOiBzdHJpbmc7XG4gICAgYWZmaW5pdHlLZXk6IHN0cmluZztcbiAgICBvcGVuQUlLZXk6IHN0cmluZztcbiAgICBvd25lcl9wZXJzb25fdmFsdWU6IHN0cmluZztcbiAgICBjb25uZWN0aW9uX293bmVyX2ZpZWxkX2lkOiBzdHJpbmc7XG4gICAgdmVudHVyZV9uZXR3b3JrX2xpc3RfaWQ6IHN0cmluZztcbiAgICBweXRob25QYXRoOiBzdHJpbmdcblxufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBCdXRsZXJTZXR0aW5ncyA9IHtcblx0dmF1bHRQYXRoOiAnZGVmYXVsdCcsXG4gICAgYWZmaW5pdHlLZXk6ICdkZWZhdWx0JyxcbiAgICBvcGVuQUlLZXk6ICdkZWZhdWx0JyxcbiAgICBvd25lcl9wZXJzb25fdmFsdWU6ICcxMCcsXG4gICAgY29ubmVjdGlvbl9vd25lcl9maWVsZF9pZDogJzEwMCcsXG4gICAgdmVudHVyZV9uZXR3b3JrX2xpc3RfaWQ6ICc1MDAnLFxuICAgIHB5dGhvblBhdGg6ICc8cGF0aC10by12aXJ0dWFsLWVudj4nXG5cbn1cblxuZW51bSBGaWxlVHlwZSB7XG4gICAgbW9kaWZpZWQgPSAnbW9kaWZpZWQnLFxuICAgIGRlbGV0ZWQgPSAnZGVsZXRlZCcsXG4gICAgbmV3ID0gJ25ldydcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVkNXaXphcmRQbHVnaW4gZXh0ZW5kcyBQbHVnaW57XG4gICAgc2V0dGluZ3M6IEJ1dGxlclNldHRpbmdzO1xuICAgIHN0YXR1czogSFRNTEVsZW1lbnQ7XG4gICAgYXN5bmMgb25sb2FkKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHRoaXMuYWRkU3RhdHVzQmFySXRlbSgpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5yZWdpc3RlclZpZXcoV0laQVJEX1ZJRVcsIChsZWFmKT0+IG5ldyBXaXphcmRWaWV3KGxlYWYpKVxuICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub25MYXlvdXRSZWFkeSgoKSA9PiB7XG5cdFx0XHR0aGlzLmFjdGl2YXRlVmlldygpO1xuXHRcdFx0dGhpcy51cGRhdGVWaWV3KFtdKTtcblx0XHR9KTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQodGhpcy5hcHAudmF1bHQub24oJ21vZGlmeScsIChmaWxlKSA9PiB0aGlzLnJlZ2lzdGVyX2ZpbGVfY2hhbmdlKGZpbGUsIEZpbGVUeXBlLm1vZGlmaWVkKSkpXG5cbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KHRoaXMuYXBwLnZhdWx0Lm9uKCdkZWxldGUnLCAoZmlsZSkgPT4gdGhpcy5yZWdpc3Rlcl9maWxlX2NoYW5nZShmaWxlLCBGaWxlVHlwZS5kZWxldGVkKSkpXG4gICAgICAgIHRoaXMuYWRkUmliYm9uSWNvbignc3VuJywgJ09tYXIgUGx1Z2luJywgY3JlYXRlX25vdGljZSlcbiAgICAgICAgICAgIFxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe2lkOiAnc3VtbWFyaXplLXN0YXJ0dXAtY29tbWFuZCcsIG5hbWU6ICdTdW1tYXJpemUgVGhpcyBTdGFydHVwJywgZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3IsIHZpZXcpID0+IHN1bW1hcml6ZV9zZWxlY3RlZF9zdGFydHVwX3RleHQoZWRpdG9yLCB2aWV3KX0pXG4gICAgICAgIFxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe2lkOiAnaW5kZXgtdmF1bHQnLCBuYW1lOiAnSW5kZXggVmF1bHQnLCBjYWxsYmFjazogKCkgPT4gdGhpcy5pbmRleF92YXVsdCgpfSlcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe2lkOiAnaW5kZXgtY2hhbmdlZC1maWxlcycsIG5hbWU6ICdSZWluZGV4IE5ldy9DaGFuZ2VkIEZpbGVzIE9ubHknLCBjYWxsYmFjazogKCkgPT4gdGhpcy5pbmRleF9uZXdfYW5kX21vZGlmaWVkX2ZpbGVzKCl9KVxuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7aWQ6ICdmaW5kLXNpbWlsYXItaWRlYXMnLCBuYW1lOiAnRmluZCBTaW1pbGFyIElkZWFzJywgZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3IsIHZpZXcpID0+IHRoaXMuZmluZF9zaW1pbGFyX2lkZWFzKGVkaXRvciwgdmlldyl9KVxuICAgIFxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe2lkOiAnc3VtbWFyaXplLWFsbC12Yy1jb21tYW5kJywgbmFtZTogJ1N1bW1hcml6ZSBBbGwgVkMgTm90ZXMnLCBjYWxsYmFjazogKCkgPT4gdGhpcy5zdW1tYXJpemVfYWxsX3ZjKCl9KVxuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7aWQ6ICdhZmZpbml0eS12YycsIG5hbWU6ICdQdXNoIFZDcyB0byBBZmZpbml0eScsIGNhbGxiYWNrOiAoKSA9PiBwdXNoX3Zjc190b19hZmZpbml0eSgpfSlcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe2lkOiAnYWZmaW5pdHktc3RhcnR1cCcsIG5hbWU6ICdQdXNoIFN0YXJ0dXBzIHRvIEFmZmluaXR5JywgY2FsbGJhY2s6ICgpID0+IHB1c2hfc3RhcnR1cHNfdG9fYWZmaW5pdHkoKX0pXG5cbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTYW1wbGVTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG4gICAgICAgIHRoaXMuc3RhdHVzLnNldFRleHQoJ1x1RDgzRVx1REREOTogVkMgV2l6YXJkIHJlYWR5JylcbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cigndGl0bGUnLCAnV2l6YXJkIGlzIHJlYWR5JylcblxuICAgIFxuICAgIH1cblxuICAgIG9udW5sb2FkKCkge1xuICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2UuZGV0YWNoTGVhdmVzT2ZUeXBlKFdJWkFSRF9WSUVXKVxuICAgICAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KCdcdUQ4M0VcdURERDk6IFZDIFdpemFyZCBsZWZ0JylcblxuICAgIH1cblxuICAgIGFzeW5jIGFjdGl2YXRlVmlldygpIHtcblx0XHR0aGlzLmFwcC53b3Jrc3BhY2UuZGV0YWNoTGVhdmVzT2ZUeXBlKFdJWkFSRF9WSUVXKTtcblx0XHRcblx0XHRhd2FpdCB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0UmlnaHRMZWFmKGZhbHNlKS5zZXRWaWV3U3RhdGUoe1xuXHRcdCAgdHlwZTogV0laQVJEX1ZJRVcsXG5cdFx0ICBhY3RpdmU6IHRydWUsXG5cdFx0fSk7XG5cdFxuXHRcdHRoaXMuYXBwLndvcmtzcGFjZS5yZXZlYWxMZWFmKFxuXHRcdCAgdGhpcy5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZShXSVpBUkRfVklFVylbMF1cblx0XHQpO1xuXHR9XG4gICAgYXN5bmMgdXBkYXRlVmlldyhyZXN1bHRzOiBhbnkpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoV0laQVJEX1ZJRVcpWzBdPy52aWV3O1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIFdpemFyZFZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlKHJlc3VsdHMpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFNldHRpbmdzKCl7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgICAgICBzY3JpcHRQYXRoX0FJID0gdGhpcy5zZXR0aW5ncy52YXVsdFBhdGggKyAnLm9ic2lkaWFuL3BsdWdpbnMvdmNfd2l6YXJkJ1xuICAgICAgICBvcGVuYWlBUElLZXkgPSB0aGlzLnNldHRpbmdzLm9wZW5BSUtleVxuICAgICAgICBhZmZpbml0eUFQSUtleSA9IHRoaXMuc2V0dGluZ3MuYWZmaW5pdHlLZXlcbiAgICAgICAgb3duZXJfdmFsdWUgPSB0aGlzLnNldHRpbmdzLm93bmVyX3BlcnNvbl92YWx1ZVxuICAgICAgICBjb25uZWN0aW9uX293bmVyX2ZpZWxkID0gdGhpcy5zZXR0aW5ncy5jb25uZWN0aW9uX293bmVyX2ZpZWxkX2lkXG4gICAgICAgIHZlbnR1cmVfbmV0d29ya19saXN0ID0gdGhpcy5zZXR0aW5ncy52ZW50dXJlX25ldHdvcmtfbGlzdF9pZFxuICAgICAgICBweXRob25QYXRoID0gdGhpcy5zZXR0aW5ncy5weXRob25QYXRoXG4gICAgfVxuXG4gICAgYXN5bmMgc2F2ZVNldHRpbmdzKCl7XG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncylcbiAgICAgICAgc2NyaXB0UGF0aF9BSSA9IHRoaXMuc2V0dGluZ3MudmF1bHRQYXRoICsgJy5vYnNpZGlhbi9wbHVnaW5zL3ZjX3dpemFyZCdcbiAgICAgICAgb3BlbmFpQVBJS2V5ID0gdGhpcy5zZXR0aW5ncy5vcGVuQUlLZXlcbiAgICAgICAgYWZmaW5pdHlBUElLZXkgPSB0aGlzLnNldHRpbmdzLmFmZmluaXR5S2V5XG4gICAgICAgIG93bmVyX3ZhbHVlID0gdGhpcy5zZXR0aW5ncy5vd25lcl9wZXJzb25fdmFsdWVcbiAgICAgICAgY29ubmVjdGlvbl9vd25lcl9maWVsZCA9IHRoaXMuc2V0dGluZ3MuY29ubmVjdGlvbl9vd25lcl9maWVsZF9pZFxuICAgICAgICB2ZW50dXJlX25ldHdvcmtfbGlzdCA9IHRoaXMuc2V0dGluZ3MudmVudHVyZV9uZXR3b3JrX2xpc3RfaWRcbiAgICAgICAgcHl0aG9uUGF0aCA9IHRoaXMuc2V0dGluZ3MucHl0aG9uUGF0aFxuICAgIH1cblxuICAgIGFzeW5jIHN1bW1hcml6ZV9hbGxfdmMoKXtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gc3VtbWFyaXplZCBhbGwgVkMgbm90ZXMgdGhhdCBhcmUgZWxpZ2libGUgZm9yIHN1bW1hcml6YXRpb24gKHBlb3BsZSBvciBlbnRpdGllcyBJIGFtIGNvbm5lY3RlZCB3aXRoKVxuICAgICAgICAgKi9cblxuICAgICAgICBjb25zdCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKVxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGZpbGVzKXtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coaXRlbS5uYW1lKVxuICAgICAgICAgICAgbGV0IGZpbGVfY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoaXRlbSlcbiAgICAgICAgICAgIGlmIChpc19zdW1tYXJpemFibGUoZmlsZV9jb250ZW50KSl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFdlIGFyZSBjaGFuZ2luZyBmaWxlOiAke2l0ZW0ubmFtZX1gKVxuICAgICAgICAgICAgICAgIC8vV2Ugc2hvdWxkIHN1bW1hcml6ZSB0aGlzIGZpbGUgdGhlblxuICAgICAgICAgICAgICAgIGxldCBbbmV3X3RleHQsIHN1bW1hcnksIHRpdGxlXSA9IGF3YWl0IHN1bW1hcml6ZV92Y190ZXh0KGZpbGVfY29udGVudClcbiAgICAgICAgICAgICAgICBpZiAodGl0bGUgIT0gJycpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC52YXVsdC5tb2RpZnkoaXRlbSwgbmV3X3RleHQpXG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYCR7dGl0bGV9IGhhcyBiZWVuIHN1bW1hcml6ZWRgKVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuXG4gICAgICAgIC8vdmF1bHQuXG5cbiAgICAgICAgXG5cbiAgICB9XG4gICAgYXN5bmMgZmluZF9zaW1pbGFyX2lkZWFzKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXd8TWFya2Rvd25GaWxlSW5mbyl7XG4gICAgICAgIGNvbnN0IHNlbCA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKVxuICAgICAgICBuZXcgTm90aWNlKFwiU2VhcmNoIGluIHByb2dyZXNzLi4uXCIpXG4gICAgICAgIGxldCBzY3JpcHRQYXRoID0gc2NyaXB0UGF0aF9BSVxuICAgICAgICBjb25zdCBzY3JpcHROYW1lID0gJ3NpbWlsYXJfaWRlYXMucHknXG4gICAgICAgIHZhciBhcmdzID0gW3NlbCwgb3BlbmFpQVBJS2V5LCB0aGlzLnNldHRpbmdzLnZhdWx0UGF0aF1cbiAgICAgICAgY29uc3Qgc2ltaWxhcl9pZGVhcyA9IGF3YWl0IGxhdW5jaF9weXRob24ocHl0aG9uUGF0aCwgc2NyaXB0UGF0aCwgc2NyaXB0TmFtZSwgYXJncykgYXMgc3RyaW5nIFtdICAgICAgICBcbiAgICAgICAgLy9jb25zb2xlLmxvZyhzaW1pbGFyX2lkZWFzKVxuICAgICAgICBsZXQgc2VhcmNoX3Jlc3VsdHMgPSBhd2FpdCB0aGlzLmV4dHJhY3RfdGl0bGVfYW5kX3BhdGgoc2ltaWxhcl9pZGVhcylcbiAgICAgICAgLy9jb25zb2xlLmxvZygnU2VhcmNoIHJlc3VsdHM6XFxuJylcbiAgICAgICAgLy9jb25zb2xlLmxvZyhzZWFyY2hfcmVzdWx0cylcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3KHNlYXJjaF9yZXN1bHRzKVxuICAgIFxuICAgIFxuICAgIH1cblxuICAgIGFzeW5jIHJlZ2lzdGVyX2ZpbGVfY2hhbmdlKGZpbGU6IFRBYnN0cmFjdEZpbGUsIHR5cGU6RmlsZVR5cGUpe1xuICAgICAgICBsZXQgc2NyaXB0UGF0aCA9IHNjcmlwdFBhdGhfQUlcbiAgICAgICAgY29uc3Qgc2NyaXB0TmFtZSA9ICdpbmRleF92YXVsdC5weSdcbiAgICAgICAgY29uc3QgcGx1Z2luX3BhdGggPSBzY3JpcHRQYXRoX0FJXG4gICAgICAgIGxldCBiYXNlX25hbWUgPSBmaWxlLm5hbWUuc3BsaXQoJy5tZCcpWzBdXG4gICAgICAgIGxldCBmaWxlX3BhdGggPSB0aGlzLnNldHRpbmdzLnZhdWx0UGF0aCArIGZpbGUucGF0aFxuICAgICAgICBsZXQgc3RvcmFnZV9wYXRoID0gcGx1Z2luX3BhdGggKyAnL21vZGlmaWVkX3BhdGhzLmpzb24nXG4gICAgICAgIGlmICh0eXBlID09IEZpbGVUeXBlLm1vZGlmaWVkKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IHZhbHVlID0geydjaGFuZ2VfdHlwZSc6IEZpbGVUeXBlLm1vZGlmaWVkLCAnZnVsbF9wYXRoJzogZmlsZV9wYXRofSBcbiAgICAgICAgICAgIGFwcGVuZF90b19qc29uKHN0b3JhZ2VfcGF0aCwgYmFzZV9uYW1lLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09IEZpbGVUeXBlLmRlbGV0ZWQpe1xuXG4gICAgICAgICAgICBuZXcgTm90aWNlKGAke2Jhc2VfbmFtZX0gaGFzIGJlZW4gZGVsZXRlZGApXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB7J2NoYW5nZV90eXBlJzogRmlsZVR5cGUuZGVsZXRlZCwgJ2Z1bGxfcGF0aCc6IGZpbGVfcGF0aH0gXG4gICAgICAgICAgICBhcHBlbmRfdG9fanNvbihzdG9yYWdlX3BhdGgsIGJhc2VfbmFtZSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgLy90b2RvIG5vIG5lZWQgdG8gdHJhY2sgbmV3IGZpbGVzIHNpbmNlIHRoZXkgb25seSBjb3VudCB3aGVuIG1vZGlmaWVkIGFueXdheXM/XG4gICAgICAgIC8vdG9kbyBjb3VsZCBiZSB1c2VmdWwgb25seSwgaWYgSSBtYWtlIHN1cmUgbm90IHRvIG92ZXJ3cml0ZSAnbW9kaWZpZWRfcGF0aHMnIGJ5IG1vZGlmaWVkIGlmIG5ldyBhbHJlYWR5IGV4aXN0cy4gVGhlbiB1c2UgdGhhdCB0byBhdm9pZCB1c2VsZXNzIHNlYXJjaCBpZiBhIG5ldyBmaWxlIGV4aXN0IGFscmVhZHkgaW4gb3VyIGluZGV4ZWQgZGF0YWJhc2VcbiAgICAgICAgLy90b2RvIGlmIEkgZGVjaWRlZCBmb3IgeWVzLCBhZGQgYW4gZXZlbnRsaXN0ZW50IGluIG9ubG9hZFxuICAgICAgICBlbHNlIGlmICh0eXBlID09IEZpbGVUeXBlLm5ldyl7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGAke2Jhc2VfbmFtZX0gaGFzIGJlZW4gY3JlYXRlZGApXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB7J2NoYW5nZV90eXBlJzogRmlsZVR5cGUubmV3LCAnZnVsbF9wYXRoJzogZmlsZV9wYXRofVxuICAgICAgICAgICAgYXBwZW5kX3RvX2pzb24oc3RvcmFnZV9wYXRoLCBiYXNlX25hbWUsIHZhbHVlKVxuXG4gICAgICAgIH1cblxuXG4gICAgfVxuICAgIGFzeW5jIGluZGV4X25ld19hbmRfbW9kaWZpZWRfZmlsZXMoKXtcbiAgICAgICAgY29uc3QgcGx1Z2luX3BhdGggPSBzY3JpcHRQYXRoX0FJXG4gICAgICAgIGxldCBzdG9yYWdlX3BhdGggPSBwbHVnaW5fcGF0aCArICcvbW9kaWZpZWRfcGF0aHMuanNvbidcbiAgICAgICAgZnMucmVhZEZpbGUoc3RvcmFnZV9wYXRoLCBhc3luYyAoZXJyLCBkYXRhOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGlmKGVycikge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgbGV0IGZpbGVzX3RvX21vZGlmeSBcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJXaWxsIHJlYWQgY2hhbmdlZCBmaWxlcyBub3cuLlwiKVxuICAgICAgICAgICAgdGhpcy5zdGF0dXMuc2V0VGV4dCgnXHVEODNFXHVEREQ5OiBWQyBXaXphcmQgaW5kZXhpbmcuLi4nKVxuICAgICAgICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cigndGl0bGUnLCAnV2l6YXJkIGlzIGluZGV4aW5nIHlvdXIgdmF1bHQuLi4nKVxuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgZmlsZXNfdG9fbW9kaWZ5ID0gSlNPTi5wYXJzZShkYXRhKVxuICAgICAgICAgICAgICAgY29uc29sZS5sb2coZmlsZXNfdG9fbW9kaWZ5KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpe1xuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiTm8gbmV3IG5vdGVzIHRvIGluZGV4XCIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzLnNldFRleHQoJ1x1RDgzRVx1REREOTogVkMgV2l6YXJkIHJlYWR5JylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cigndGl0bGUnLCAnVkMgV2l6YXJkIGlzIHJlYWR5JylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGZpbGVzX3RvX21vZGlmeSkubGVuZ3RoIDwgMSl7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIk5vIG5ldyBub3RlcyB0byBpbmRleFwiKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzLnNldFRleHQoJ1x1RDgzRVx1REREOTogVkMgV2l6YXJkIHJlYWR5JylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cy5zZXRBdHRyKCd0aXRsZScsICdWQyBXaXphcmQgaXMgcmVhZHknKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5pbmRleF9maWxlcyhzdG9yYWdlX3BhdGgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSl7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBpbmRleGluZyFcIilcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KCdcdUQ4M0VcdURERDk6IFZDIFdpemFyZCByZWFkeScpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cigndGl0bGUnLCAnVkMgV2l6YXJkIGlzIHJlYWR5JylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL0VtcHR5IHRoZSBtb2RpZmllZCBmaWxlXG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiRmluaXNoZWQgaW5kZXhpbmchXCIpXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHN0b3JhZ2VfcGF0aClcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzLnNldFRleHQoJ1x1RDgzRVx1REREOTogVkMgV2l6YXJkIHJlYWR5JylcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoJ3RpdGxlJywgJ1ZDIFdpemFyZCBpcyByZWFkeScpXG4gICAgICAgICAgICBzYXZlX2pzb24oc3RvcmFnZV9wYXRoLCB7fSlcblxuICAgICAgICB9KVxuICAgIFxuICAgIH1cblxuICAgIGFzeW5jIGluZGV4X3ZhdWx0KCl7XG4gICAgICAgIGxldCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKVxuICAgICAgICBsZXQgZmlsZV9wYXRoczogYW55ID0ge31cbiAgICAgICAgbGV0IHZhdWx0X3BhdGggPSB0aGlzLnNldHRpbmdzLnZhdWx0UGF0aFxuICAgICAgICBjb25zdCBwbHVnaW5fcGF0aCA9IHNjcmlwdFBhdGhfQUlcbiAgICAgICAgbmV3IE5vdGljZShcIlN0YXJ0ZWQgaW5kZXhpbmcgdGhlIGZ1bGwgdmF1bHQhXCIpXG4gICAgICAgIHRoaXMuc3RhdHVzLnNldFRleHQoJ1x1RDgzRVx1REREOTogVkMgV2l6YXJkIGluZGV4aW5nLi4uJylcbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cigndGl0bGUnLCAnV2l6YXJkIGlzIGluZGV4aW5nIHlvdXIgdmF1bHQuLi4nKVxuICAgICAgICBmb3IobGV0IGZpbGUgb2YgZmlsZXMpe1xuICAgICAgICAgICAgaWYgKGZpbGUucGF0aC5pbmNsdWRlcygnUmVhZHdpc2UnKSl7ICBcbiAgICAgICAgICAgICAgICBmaWxlX3BhdGhzW2ZpbGUuYmFzZW5hbWVdID0geydjaGFuZ2VfdHlwZSc6IEZpbGVUeXBlLm5ldywnZnVsbF9wYXRoJzogdmF1bHRfcGF0aCArIGZpbGUucGF0aH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhgRmlsZXMgbGVuZ3RoOiAke2ZpbGVfcGF0aHMubGVuZ3RofWApXG4gICAgICAgIGNvbnN0IGpzb25fcGF0aCA9IHBsdWdpbl9wYXRoICsgJy8nICsgJ2ZpbGVfcGF0aHMuanNvbidcbiAgICAgICAgc2F2ZV9qc29uKGpzb25fcGF0aCwgZmlsZV9wYXRocylcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5pbmRleF9maWxlcyhqc29uX3BhdGgpXG5cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSl7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGluZGV4aW5nIVwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5ldyBOb3RpY2UoXCJGaW5pc2hlZCBpbmRleGluZyFcIilcbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0VGV4dCgnXHVEODNFXHVEREQ5OiBWQyBXaXphcmQgcmVhZHknKVxuICAgICAgICB0aGlzLnN0YXR1cy5zZXRBdHRyKCd0aXRsZScsICdWQyBXaXphcmQgaXMgcmVhZHknKVxuICAgICAgICBzYXZlX2pzb24oanNvbl9wYXRoLCB7fSlcblxuICAgICAgICBcbiAgICAgICAgXG5cbiAgICB9XG5cbiAgICBhc3luYyBpbmRleF9maWxlcyhqc29uX3BhdGg6IHN0cmluZyl7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRleCBhbGwgdGhlIGZpbGVzIHdobyBwYXRocyBpcyBzYXZlZCBpbiBqc29uX3BhdGhcbiAgICAgICAgICovXG4gICAgICAgIFxuICAgICAgICBsZXQgc2NyaXB0UGF0aCA9IHNjcmlwdFBhdGhfQUlcbiAgICAgICAgY29uc3Qgc2NyaXB0TmFtZSA9ICdpbmRleF92YXVsdC5weSdcbiAgICAgICAgY29uc3QgcGx1Z2luX3BhdGggPSBzY3JpcHRQYXRoX0FJXG4gICAgICAgIFxuICAgICAgICB2YXIgYXJncyA9IFtqc29uX3BhdGgsIG9wZW5haUFQSUtleSwgcGx1Z2luX3BhdGhdXG5cblxuICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGxhdW5jaF9weXRob24ocHl0aG9uUGF0aCwgc2NyaXB0UGF0aCwgc2NyaXB0TmFtZSwgYXJncylcbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cylcbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0VGV4dCgnXHVEODNFXHVEREQ5OiBWQyBXaXphcmQgcmVhZHknKVxuICAgICAgICB0aGlzLnN0YXR1cy5zZXRBdHRyKCd0aXRsZScsICdWQyBXaXphcmQgaXMgcmVhZHknKVxuICAgICAgICByZXR1cm4gcmVzdWx0c1xuICAgIH1cbiAgICBhc3luYyBleHRyYWN0X3RpdGxlX2FuZF9wYXRoKHJlc3VsdHM6IHN0cmluZ1tdKXtcbiAgICAgICAgXG4gICAgICAgIC8vY29uc29sZS5sb2coYWxsX2ZpbGVzKVxuICAgICAgICBsZXQgY291bnRlciA9IDBcbiAgICAgICAgbGV0IHNlYXJjaF9yZXN1bHRzOiBhbnkgPSB7fSAvL3snc2VudGVuY2VzJzogW10sICdzb3VyY2VfbmFtZSc6IFtdLCAnc291cmNlX3BhdGgnOiBbXX1cbiAgICAgICAgbGV0IGN1cnJlbnRfZmlsZW5hbWUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpPy5iYXNlbmFtZVxuICAgICAgICBjb25zb2xlLmxvZyhgY3VycmVudCBmaWxlbmFtZTogJHtjdXJyZW50X2ZpbGVuYW1lfWApXG4gICAgICAgIGZvciAobGV0IHJlc3VsdCBvZiByZXN1bHRzKXtcbiAgICAgICAgICBpZiAoY291bnRlciAlIDMgPT0gMCAmJiBjb3VudGVyIT0gMClcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsZXQgc2VudGVuY2UgPSAnXFxcIicgKyByZXN1bHRzLmF0KGNvdW50ZXIpICsgJ1xcXCInXG4gICAgICAgICAgICBsZXQgc291cmNlID0gcmVzdWx0cy5hdChjb3VudGVyKzIpXG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2U/LnNwbGl0KCc6JylbMV0udHJpbSgpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBjb3VudGVyOiAke2NvdW50ZXJ9LCBUaGlzIHNvdXJjZTogJHtzb3VyY2V9YClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoc291cmNlID09IGN1cnJlbnRfZmlsZW5hbWUpe1xuICAgICAgICAgICAgICAgIC8vRG8gbm90IGFkZCByZXN1bHRzIGZyb20gdGhlIGN1cnJlbnQgZmlsZVxuICAgICAgICAgICAgICAgIGNvdW50ZXIgPSBjb3VudGVyICsgMVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc291cmNlX2ZpbGUgPSBhd2FpdCB0aGlzLmdldF9wYXRoX2J5X25hbWUoc291cmNlKVxuICAgICAgICAgICAgY29uc29sZS5sb2coc291cmNlX2ZpbGUpXG4gICAgICAgICAgICBpZiAoc291cmNlX2ZpbGUgIT0gbnVsbCAmJiBzb3VyY2UgIT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JzaWRpYW5fcGF0aCA9ICdvYnNpZGlhbjovL2FkdmFuY2VkLXVyaT92YXVsdD0nIC8vb3BlbiAtIGFkdmFuY2VkLXVyaVxuICAgICAgICAgICAgICAgIG9ic2lkaWFuX3BhdGggPSBvYnNpZGlhbl9wYXRoICsgdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpICsgJyZmaWxlcGF0aD0nIC8vZmlsZSAtIGZpbGVwYXRoXG4gICAgICAgICAgICAgICAgLy9sZXQgc291cmNlX3BhdGggPSBzb3VyY2VfZmlsZS5wYXRoIC8vdGhpcy5hcHAudmF1bHQuZ2V0UmVzb3VyY2VQYXRoKHNvdXJjZV9maWxlKVxuICAgICAgICAgICAgICAgIG9ic2lkaWFuX3BhdGggPSBvYnNpZGlhbl9wYXRoICsgc291cmNlX2ZpbGUucGF0aFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBteSBzb3VyY2UgcGF0aDogJHtvYnNpZGlhbl9wYXRofWApXG4gICAgICAgICAgICAgICAgc2VhcmNoX3Jlc3VsdHNbc291cmNlXSA9IHsnc291cmNlX3BhdGgnOm9ic2lkaWFuX3BhdGgsICd0ZXh0Jzogc2VudGVuY2V9IFxuXG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgXG5cbiAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgY291bnRlciA9IGNvdW50ZXIgKyAxXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlYXJjaF9yZXN1bHRzXG4gICAgfVxuICAgIGFzeW5jIGdldF9wYXRoX2J5X25hbWUoc291cmNlOiBzdHJpbmd8dW5kZWZpbmVkKXtcbiAgICAgICAgbGV0IGFsbF9maWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKVxuICAgICAgICBmb3IgKGxldCBmaWxlIG9mIGFsbF9maWxlcyl7XG4gICAgICAgICAgICBsZXQgZmlsZW5hbWUgPSBmaWxlLmJhc2VuYW1lXG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUgPT0gc291cmNlKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsXG5cblxuICAgIH1cbn1cblxuY2xhc3MgU2FtcGxlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWJ7XG4gICAgcGx1Z2luOiBWQ1dpemFyZFBsdWdpblxuICAgIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IFZDV2l6YXJkUGx1Z2luKXtcbiAgICAgICAgc3VwZXIoYXBwLCBwbHVnaW4pXG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luXG4gICAgfVxuICAgIGRpc3BsYXkoKTogdm9pZCB7XG5cdFx0Y29uc3Qge2NvbnRhaW5lckVsfSA9IHRoaXM7XG5cblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywge3RleHQ6ICdTZXR0aW5ncyBmb3IgeW91ciBidXRsZXInfSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdPYnNpZGlhbiBWYXVsdCBQYXRoJylcblx0XHRcdC5zZXREZXNjKCdUaGUgcGF0aCB0byB0aGUgdmF1bHQgd2hlcmUgeW91IHdpc2ggdG8gdXNlIHRoZSBwbHVnaW4nKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRW50ZXIgcGF0aCcpXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy52YXVsdFBhdGgpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZygncGF0aDogJyArIHZhbHVlKTtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy52YXVsdFBhdGggPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpO1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoJ09wZW5BSSBBUEkgS2V5JylcbiAgICAgICAgLnNldERlc2MoJ1lvdXIgT3BlbkFJIEFQSSBLZXknKVxuICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignRW50ZXIga2V5JylcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5vcGVuQUlLZXkpXG4gICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ09wZW4gQUkga2V5OiAnICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm9wZW5BSUtleSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoJ0FmZmluaXR5OiBBUEkgS2V5JylcbiAgICAgICAgLnNldERlc2MoJ1lvdXIgQWZmaW5pdHkgQVBJIEtleScpXG4gICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdFbnRlciBrZXknKVxuICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmFmZmluaXR5S2V5KVxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdrZXk6ICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuYWZmaW5pdHlLZXkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKCdBZmZpbml0eTogT3duZXIgVmFsdWUnKVxuICAgICAgICAuc2V0RGVzYygnRXZlcnkgcGVyc29uIGhhcyBhIGNvZGUgb24gQWZmaW5pdHkuIFBsZWFzZSBnaXZlIGluIHRoZSBjb2RlIGZvciB0aGUgcGVyc29uIHRoYXQgc2hvdWxkIGJlIGFkZGVkIGFzIG93bmVyIG9mIHN0YXJ0dXBzIGFuZCBWQ3MgdGhhdCBnZXRzIHB1c2hlZCcpXG4gICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdFbnRlciB2YWx1ZScpXG4gICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mub3duZXJfcGVyc29uX3ZhbHVlKVxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdPd25lciB2YWx1ZTogJyArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vd25lcl9wZXJzb25fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKCdBZmZpbml0eTogQ29ubmVjdGlvbiBPd25lciBGaWVsZCBJRCcpXG4gICAgICAgIC5zZXREZXNjKCdEZXBlbmRpbmcgb24gdGhlIGxpc3QgeW91IHNhdmUgZmVsbG93IFZDcyBpbiwgdGhlcmUgaXMgYSBmaWVsZCB0aGF0IHJlcHJlc2VudCB0aGUgXFwnY29ubmVjdGlvbiBvd25lciB3aXRoIHRoZSBmdW5kXFwnLCBlbnRlciB0aGUgZmllbGQgaWQgaGVyZScpXG4gICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdFbnRlciB2YWx1ZScpXG4gICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuY29ubmVjdGlvbl9vd25lcl9maWVsZF9pZClcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ29ubmVjdGlvbiBPd25lciBGaWVsZCBJRCB2YWx1ZTogJyArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb25uZWN0aW9uX293bmVyX2ZpZWxkX2lkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZSgnQWZmaW5pdHk6IFZlbnR1cmUgTmV0d29yayBMaXN0IElEJylcbiAgICAgICAgLnNldERlc2MoJ1BsZWFzZSBlbnRlciB0aGUgbGlzdCBpZCBmb3IgdGhlIGxpc3QgeW91IHNhdmUgeW91ciByZWxhdGlvbnNoaXBzIHdpdGggVkNzIGluJylcbiAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHZhbHVlJylcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy52ZW50dXJlX25ldHdvcmtfbGlzdF9pZClcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVmVudHVyZSBuZXR3b3JrIGxpc3QgaWQ6ICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudmVudHVyZV9uZXR3b3JrX2xpc3RfaWQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKCdQeXRob24gVmlydHVhbCBFbnZpcm9ubWVudCBQYXRoJylcbiAgICAgICAgLnNldERlc2MoJ1RoZSBwYXRoIHRvIHB5dGhvbiB2aXJ0dWFsIGVudmlyb25tZW50JylcbiAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHBhdGgnKVxuICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnB5dGhvblBhdGgpXG4gICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1B5dGhvblBhdGg6ICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucHl0aG9uUGF0aCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgfSkpO1xuXHR9XG5cbn0iLCAiaW1wb3J0IHsgSXRlbVZpZXcsIFdvcmtzcGFjZUxlYWYgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGNvbnN0IFdJWkFSRF9WSUVXID0gXCJ3aXphcmQtdmlld1wiO1xuXG5leHBvcnQgY2xhc3MgV2l6YXJkVmlldyBleHRlbmRzIEl0ZW1WaWV3IHtcbiAgY29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZikge1xuICAgIHN1cGVyKGxlYWYpO1xuICAgIHRoaXMuaWNvbiA9ICdzdW4nXG4gIH1cblxuICBnZXRWaWV3VHlwZSgpIHtcbiAgICByZXR1cm4gV0laQVJEX1ZJRVc7XG4gIH1cblxuICBnZXREaXNwbGF5VGV4dCgpIHtcbiAgICByZXR1cm4gXCJFeGFtcGxlIHZpZXdcIjtcbiAgfVxuXG4gIGFzeW5jIG9uT3BlbigpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lckVsLmNoaWxkcmVuWzFdO1xuICAgIGNvbnRhaW5lci5lbXB0eSgpO1xuICAgIGNvbnRhaW5lci5jcmVhdGVFbChcImg0XCIsIHt0ZXh0OiBcIlJlbGF0ZWQgSWRlYXNcIiwgY2xzOiBcImhlYWRpbmdcIn0pO1xuICB9XG5cbiAgYXN5bmMgdXBkYXRlKHNlYXJjaF9yZXN1bHRzOiBhbnkpeyAvL1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyRWwuY2hpbGRyZW5bMV07XG4gICAgLy9jb250YWluZXIuY3JlYXRlRWwoXCJkaXZcIiwge3RleHQ6IFwiSGVsbG8gV29ybGRcIn0pXG4gICAgY29udGFpbmVyLmVtcHR5KClcbiAgICBjb25zdCBvdXRlckRpdiA9IGNvbnRhaW5lci5jcmVhdGVFbChcImg0XCIsIHt0ZXh0OiBcIlJlbGF0ZWQgSWRlYXNcXG5cIiwgY2xzOiBcImhlYWRpbmdcIn0pO1xuICAgIFxuICAgIGZvciAoY29uc3Qga2V5IGluIHNlYXJjaF9yZXN1bHRzKXtcblxuICAgICAgbGV0IHNvdXJjZV9uYW1lID0ga2V5XG4gICAgICBsZXQgc291cmNlX3BhdGggPSBzZWFyY2hfcmVzdWx0c1trZXldWydzb3VyY2VfcGF0aCddXG4gICAgICBsZXQgdGV4dCA9IHNlYXJjaF9yZXN1bHRzW2tleV1bJ3RleHQnXVxuICAgICAgY29uc3QgcXVvdGUgPSBjb250YWluZXIuY3JlYXRlRWwoXCJibG9ja3F1b3RlXCIsIHt0ZXh0OiB0ZXh0LCBjbHM6IFwicXVvdGVcIn0pXG4gICAgICBjb25zdCBsaW5rID0gcXVvdGUuY3JlYXRlRWwoXCJhXCIsIHsgaHJlZjogc291cmNlX3BhdGgsIGF0dHI6IHsgXCJkYXRhLXBhdGhcIjogc291cmNlX3BhdGggfSB9KTtcbiAgICAgIGxpbmsuY3JlYXRlRWwoXCJzcGFuXCIsIHsgICBcbiAgICAgICAgICAgICAgICAgIHRleHQ6ICdcXG4tLScgKyBzb3VyY2VfbmFtZSBcbiAgICAgICAgICB9XG4gICAgICApO1xuXG5cblxuICAgIH1cblxuICAgIC8vY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHt0ZXh0OiByZXN1bHRzLmF0KDApfSlcbiAgICAvL291dGVyRGl2LmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogXCJcIiB9KTtcbiAgICAvL291dGVyRGl2LmNyZWF0ZUVsKFwiZGl2XCIsIHsgY2xzOiBcIm91dGdvaW5nLWxpbmstaGVhZGVyXCIsIHRleHQ6IFwiXHUyNkYwXCIgfSk7XG4gICAgXG5cbiAgfVxuXG4gIGFzeW5jIG9uQ2xvc2UoKSB7XG4gICAgLy8gTm90aGluZyB0byBjbGVhbiB1cC5cbiAgfVxufSJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsUUFBQSxXQUFBLFFBQUE7QUFDQSxRQUFBLGtCQUFBLFFBQUE7QUFDQSxRQUFBLE9BQUEsUUFBQTtBQUNBLFFBQUEsU0FBQSxRQUFBO0FBQ0EsUUFBQSxXQUFBLFFBQUE7QUFDQSxRQUFBLE9BQUEsUUFBQTtBQUNBLFFBQUEsU0FBQSxRQUFBO0FBRUEscUJBQW9CLFFBQWdCO0FBQ2hDLFVBQUksT0FBTyxXQUFXLGVBQWUsV0FBVyxNQUFNO0FBQ2xELGVBQU8sQ0FBQTtpQkFDQSxDQUFDLE1BQU0sUUFBUSxNQUFNLEdBQUc7QUFDL0IsZUFBTyxDQUFDLE1BQU07O0FBRWxCLGFBQU87SUFDWDtBQUtBLG9CQUFnQixRQUFZLE1BQUk7QUFDNUIsWUFBTSxVQUFVLE1BQU0sS0FBSyxXQUFXLENBQUMsRUFBRSxRQUFRLFNBQVUsUUFBTTtBQUM3RCxZQUFJLFFBQVE7QUFDUixtQkFBUyxPQUFPLFFBQVE7QUFDcEIsZ0JBQUksT0FBTyxPQUFPOzs7TUFHOUIsQ0FBQztBQUNELGFBQU87SUFDWDtBQUtBLDRCQUFxQjtBQUNqQixhQUFPLEtBQUssTUFBTSxLQUFLLE9BQU0sSUFBSyxJQUFXO0lBQ2pEO0FBRUEsUUFBTSxjQUFjLElBQUEsT0FBQSxXQUFVLGdCQUFBLElBQUk7QUEwQmxDLFFBQWEsbUJBQWIsY0FBc0MsTUFBSzs7QUFBM0MsWUFBQSxtQkFBQTtBQVFBLFFBQWEscUJBQWIsY0FBd0MsU0FBQSxVQUFTO01BRzdDLFdBQVcsT0FBWSxVQUFrQixVQUEyQjtBQUNoRSxZQUFJLE9BQWUsTUFBTSxTQUFRO0FBQ2pDLFlBQUksS0FBSztBQUFlLGlCQUFPLEtBQUssZ0JBQWdCO0FBQ3BELGNBQU0sUUFBUSxLQUFLLE1BQU0sS0FBQSxHQUFPO0FBQ2hDLGFBQUssZ0JBQWdCLE1BQU0sSUFBRztBQUU5QixjQUFNLFFBQVEsS0FBSyxLQUFLLEtBQUssSUFBSSxDQUFDO0FBQ2xDLGlCQUFRO01BQ1o7TUFDQSxPQUFPLE1BQXVCO0FBQzFCLFlBQUksS0FBSztBQUFlLGVBQUssS0FBSyxLQUFLLGFBQWE7QUFDcEQsYUFBSyxnQkFBZ0I7QUFDckIsYUFBSTtNQUNSOztBQWhCSixZQUFBLHFCQUFBO0FBMkJBLFFBQWEsY0FBYixjQUFpQyxTQUFBLGFBQVk7TUErQnpDLFlBQVksWUFBb0IsU0FBbUIsaUJBQTRCLE1BQU0saUJBQTRCLE1BQUk7QUFDakgsY0FBSztBQUtMLHlCQUFpQixNQUFNLEtBQXNCO0FBQ3pDLGNBQUksT0FBTyxRQUFRLFVBQVU7QUFFekIsbUJBQU8sWUFBWSxNQUFNO3FCQUNsQixPQUFPLFFBQVEsWUFBWTtBQUVsQyxtQkFBTzs7UUFFZjtBQUVBLFlBQUksV0FBVyxLQUFJLEVBQUcsVUFBVTtBQUFHLGdCQUFNLE1BQU0sc0VBQXNFO0FBRXJILFlBQUksT0FBTztBQUNYLFlBQUksWUFBWTtBQUNoQixpQkFBQSxhQUFhLEtBQUssSUFBSTtBQUV0QixrQkFBbUIsT0FBTyxDQUFBLEdBQUksWUFBWSxnQkFBZ0IsT0FBTztBQUNqRSxZQUFJO0FBQ0osWUFBSSxDQUFDLFFBQVEsWUFBWTtBQUNyQix3QkFBYSxZQUFZOztBQUN0Qix3QkFBYSxRQUFRO0FBQzVCLFlBQUksZ0JBQWdCLFFBQVEsUUFBUSxhQUFhO0FBQ2pELFlBQUksYUFBYSxRQUFRLFFBQVEsSUFBSTtBQUVyQyxhQUFLLGFBQWEsSUFBQSxPQUFBLE1BQUssUUFBUSxjQUFjLElBQUksVUFBVTtBQUMzRCxhQUFLLFVBQVUsY0FBYyxPQUFPLEtBQUssWUFBWSxVQUFVO0FBQy9ELGFBQUssT0FBTyxRQUFRLFFBQVE7QUFDNUIsYUFBSyxZQUFZLFFBQVEsVUFBVSxRQUFRLGFBQWEsS0FBSyxJQUFJO0FBQ2pFLGFBQUssU0FBUyxRQUFRLFNBQVMsUUFBUSxVQUFVLEtBQUssSUFBSTtBQUUxRCxhQUFLLGVBQWUsUUFBUSxTQUFTLFFBQVEsZ0JBQWdCLE1BQU07QUFDbkUsYUFBSyxhQUFhO0FBQ2xCLGFBQUssZUFBZSxJQUFBLGdCQUFBLE9BQU0sYUFBWSxLQUFLLFNBQVMsT0FBTztBQUUzRCxTQUFDLFVBQVUsU0FBUyxRQUFRLEVBQUUsUUFBUSxTQUFVLE1BQUk7QUFDaEQsZUFBSyxRQUFRLEtBQUssYUFBYTtBQUMvQixlQUFLLFVBQVUsS0FBSyxTQUFTLEtBQUssTUFBTSxZQUFZLFFBQVEsWUFBWSxNQUFNO1FBQ2xGLENBQUM7QUFNRCxZQUFJLEtBQUssVUFBVSxLQUFLLFFBQVE7QUFDNUIsY0FBRyxDQUFDO0FBQWdCLDZCQUFpQixJQUFJLG1CQUFrQjtBQUUzRCx5QkFBZSxZQUFZLFFBQVEsWUFBWSxNQUFNO0FBQ3JELGVBQUssT0FBTyxLQUFLLGNBQWMsRUFBRSxHQUFHLFFBQVEsQ0FBQyxVQUFpQjtBQUMxRCxpQkFBSyxLQUFLLFdBQVcsS0FBSyxPQUFPLEtBQUssQ0FBQztVQUMzQyxDQUFDOztBQUlMLFlBQUksS0FBSyxnQkFBZ0IsS0FBSyxRQUFRO0FBQ2xDLGNBQUcsQ0FBQztBQUFnQiw2QkFBaUIsSUFBSSxtQkFBa0I7QUFFM0QseUJBQWUsWUFBWSxRQUFRLFlBQVksTUFBTTtBQUNyRCxlQUFLLE9BQU8sS0FBSyxjQUFjLEVBQUUsR0FBRyxRQUFRLENBQUMsVUFBaUI7QUFDMUQsaUJBQUssS0FBSyxVQUFVLEtBQUssYUFBYSxLQUFLLENBQUM7VUFDaEQsQ0FBQzs7QUFHTCxZQUFJLEtBQUssUUFBUTtBQUNiLGVBQUssT0FBTyxHQUFHLFFBQVEsU0FBVSxNQUFJO0FBQ2pDLHlCQUFhLEtBQUs7VUFDdEIsQ0FBQztBQUNELGVBQUssT0FBTyxHQUFHLE9BQU8sV0FBQTtBQUNsQixpQkFBSyxpQkFBaUI7QUFDdEIsOEJBQWlCO1VBQ3JCLENBQUM7ZUFDRTtBQUNILGVBQUssaUJBQWlCOztBQUcxQixZQUFJLEtBQUssUUFBUTtBQUNiLGVBQUssT0FBTyxHQUFHLE9BQU8sV0FBQTtBQUNsQixpQkFBSyxpQkFBaUI7QUFDdEIsOEJBQWlCO1VBQ3JCLENBQUM7ZUFDRTtBQUNILGVBQUssaUJBQWlCOztBQUcxQixhQUFLLGFBQWEsR0FBRyxTQUFTLFNBQVUsS0FBMEI7QUFDOUQsZUFBSyxLQUFLLFNBQVMsR0FBRztRQUMxQixDQUFDO0FBQ0QsYUFBSyxhQUFhLEdBQUcsUUFBUSxTQUFVLE1BQU0sUUFBTTtBQUMvQyxlQUFLLFdBQVc7QUFDaEIsZUFBSyxhQUFhO0FBQ2xCLDRCQUFpQjtRQUNyQixDQUFDO0FBRUQscUNBQTBCO0FBQ3RCLGNBQUksQ0FBQyxLQUFLLGtCQUFrQixDQUFDLEtBQUssa0JBQW1CLEtBQUssWUFBWSxRQUFRLEtBQUssY0FBYztBQUFPO0FBRXhHLGNBQUk7QUFDSixjQUFJLEtBQUssWUFBWSxLQUFLLGFBQWEsR0FBRztBQUN0QyxnQkFBSSxXQUFXO0FBQ1gsb0JBQU0sS0FBSyxXQUFXLFNBQVM7bUJBQzVCO0FBQ0gsb0JBQU0sSUFBSSxpQkFBaUIsOEJBQThCLEtBQUssUUFBUTs7QUFFMUUsa0JBQXdCLE9BQU8sS0FBSztjQUNoQyxZQUFZO2NBQ1osU0FBUyxjQUFjLFNBQVMsZ0JBQWdCO2NBQ2hELFFBQVEsS0FBSztjQUNiLE1BQU0sV0FBVyxTQUFTLGFBQWE7Y0FDdkMsVUFBVSxLQUFLO2FBQ2xCO0FBRUQsZ0JBQUksS0FBSyxVQUFVLGFBQWEsRUFBRSxVQUFVLENBQUMsS0FBSyxjQUFjO0FBQzVELG1CQUFLLEtBQUssZUFBZSxHQUFHOzs7QUFJcEMsZUFBSyxhQUFhO0FBQ2xCLGVBQUssS0FBSyxPQUFPO0FBQ2pCLGVBQUssZ0JBQWdCLEtBQUssYUFBYSxLQUFLLEtBQUssVUFBVSxLQUFLLFVBQVU7UUFDOUU7QUFBQztNQUNMO01BNEJBLE9BQWEsWUFBWSxNQUFZOztBQUNqQyxnQkFBTSxZQUFZLGFBQVk7QUFDOUIsZ0JBQU0sV0FBVyxJQUFBLEtBQUEsUUFBTSxJQUFLLE9BQUEsTUFBTSx5QkFBeUI7QUFFM0QsZ0JBQU0sbUJBQW1CLElBQUEsT0FBQSxXQUFVLEtBQUEsU0FBUztBQUM1QyxpQkFBTyxpQkFBaUIsVUFBVSxJQUFJLEVBQUUsS0FBSyxNQUFLO0FBQzlDLG1CQUFPLEtBQUssZ0JBQWdCLFFBQVE7VUFDeEMsQ0FBQztRQUNMLENBQUM7O01BRUQsT0FBTyxnQkFBYTtBQUNoQixlQUFPLEtBQUssZUFBZSxhQUFhLEtBQUssZUFBZSxhQUFhLEtBQUs7TUFDbEY7TUFNQSxPQUFhLGdCQUFnQixVQUFnQjs7QUFDekMsZ0JBQU0sY0FBYSxLQUFLLGNBQWE7QUFDckMsY0FBSSxpQkFBaUIsR0FBRyw2QkFBNEI7QUFDcEQsaUJBQU8sWUFBWSxjQUFjO1FBQ3JDLENBQUM7O01BU0QsT0FBTyxJQUFJLFlBQW9CLFNBQW1CLFVBQTBEO0FBQ3hHLFlBQUksVUFBVSxJQUFJLFlBQVksWUFBWSxPQUFPO0FBQ2pELFlBQUksU0FBUyxDQUFBO0FBRWIsZUFBTyxRQUFRLEdBQUcsV0FBVyxTQUFVLFNBQU87QUFDMUMsaUJBQU8sS0FBSyxPQUFPO1FBQ3ZCLENBQUMsRUFBRSxJQUFJLFNBQVUsS0FBRztBQUNoQixpQkFBTyxTQUFTLE1BQU0sTUFBTSxNQUFNLE9BQU8sU0FBUyxTQUFTLElBQUk7UUFDbkUsQ0FBQztNQUNMO01BU0EsT0FBTyxVQUFVLE1BQWMsU0FBbUIsVUFBeUQ7QUFHdkcsY0FBTSxZQUFZLGFBQVk7QUFDOUIsY0FBTSxXQUFXLEtBQUEsU0FBUyxPQUFBLE1BQU0sa0JBQWtCO0FBQ2xELFFBQUEsSUFBQSxLQUFBLGVBQWMsVUFBVSxJQUFJO0FBRTVCLGVBQU8sWUFBWSxJQUFJLFVBQVUsU0FBUyxRQUFRO01BQ3REO01BRUEsT0FBTyxXQUFXLGFBQW1CO0FBQ2pDLFlBQUksQ0FBQztBQUFZLHdCQUFhLEtBQUssY0FBYTtBQUNoRCxlQUFPLFlBQVksY0FBYSxZQUFZO01BQ2hEO01BRUEsT0FBTyxlQUFlLGFBQW1CO0FBQ3JDLFlBQUksQ0FBQztBQUFZLHdCQUFhLEtBQUssY0FBYTtBQUNoRCxlQUFPLElBQUEsZ0JBQUEsVUFBUyxjQUFhLFlBQVksRUFBRSxTQUFRO01BQ3ZEO01BT1EsV0FBVyxNQUFxQjtBQUNwQyxZQUFJLE9BQU8sS0FBSztBQUNoQixZQUFJO0FBRUosWUFBSSxhQUFhLEtBQUssSUFBSSxHQUFHO0FBRXpCLGNBQUksUUFBUSxLQUFLLEtBQUksRUFBRyxNQUFNLEtBQUEsR0FBTztBQUNyQyxjQUFJLFlBQVksTUFBTSxJQUFHO0FBQ3pCLGtCQUFRLElBQUksaUJBQWlCLFNBQVM7QUFDdEMsZ0JBQU0sWUFBWTtBQUVsQixnQkFBTSxTQUFTLEtBQUEsTUFBVSxxQ0FBcUMsS0FBQSxNQUFVO0FBQ3hFLGdCQUFNLFNBQVMsTUFBTSxNQUFNLENBQUMsRUFBRSxLQUFLLEtBQUEsTUFBVSxJQUFJO2VBQzlDO0FBRUgsa0JBQVEsSUFBSSxpQkFBaUIsSUFBSTs7QUFHckMsZUFBTztNQUNYO01BT0EsS0FBSyxTQUF3QjtBQUN6QixZQUFJLENBQUMsS0FBSztBQUFPLGdCQUFNLElBQUksTUFBTSw0QkFBNEI7QUFDN0QsWUFBSSxPQUFPLEtBQUssWUFBWSxLQUFLLFVBQVUsT0FBTyxJQUFJO0FBQ3RELFlBQUksS0FBSyxTQUFTO0FBQVUsa0JBQVEsS0FBQTtBQUNwQyxhQUFLLE1BQU0sTUFBTSxJQUFJO0FBQ3JCLGVBQU87TUFDWDtNQU9BLElBQUksVUFBOEU7QUFDOUUsWUFBSSxLQUFLLGFBQWEsT0FBTztBQUN6QixlQUFLLGFBQWEsTUFBTSxJQUFHOztBQUUvQixhQUFLLGVBQWU7QUFDcEIsZUFBTztNQUNYO01BTUEsS0FBSyxRQUF1QjtBQUN4QixhQUFLLGFBQWEsS0FBSyxhQUFhLEtBQUssTUFBTTtBQUMvQyxlQUFPO01BQ1g7TUFNQSxVQUFVLFFBQXVCO0FBRTdCLGVBQU8sS0FBSyxLQUFLLE1BQU07TUFDM0I7O0FBalVKLFlBQUEsY0FBQTtBQW9CVyxnQkFBQSxvQkFBb0IsUUFBUSxZQUFZLFVBQVUsWUFBWTtBQUU5RCxnQkFBQSxpQkFBMEIsQ0FBQTtBQXlJMUIsZ0JBQUEsU0FBUztNQUNaLE1BQU0sZ0JBQWdCLE1BQUk7QUFDdEIsWUFBSSxDQUFDO0FBQU0saUJBQU87aUJBQ1QsT0FBTyxTQUFTO0FBQVUsaUJBQU8sS0FBSyxTQUFRO0FBQ3ZELGVBQU87TUFDWDtNQUNBLE1BQU0sZ0JBQWdCLE1BQUk7QUFDdEIsZUFBTyxLQUFLLFVBQVUsSUFBSTtNQUM5Qjs7QUFJRyxnQkFBQSxRQUFRO01BQ1gsTUFBTSxnQkFBZ0IsTUFBSTtBQUN0QixlQUFPO01BQ1g7TUFDQSxNQUFNLGdCQUFnQixNQUFZO0FBQzlCLGVBQU8sS0FBSyxNQUFNLElBQUk7TUFDMUI7Ozs7OztBQ3BSUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsdUJBQW1KOzs7QUNBbkosc0JBQXdDO0FBRWpDLElBQU0sY0FBYztBQUVwQixJQUFNLGFBQU4sY0FBeUIseUJBQVM7QUFBQSxFQUN2QyxZQUFZLE1BQXFCO0FBQy9CLFVBQU0sSUFBSTtBQUNWLFNBQUssT0FBTztBQUFBLEVBQ2Q7QUFBQSxFQUVBLGNBQWM7QUFDWixXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsaUJBQWlCO0FBQ2YsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVBLE1BQU0sU0FBUztBQUNiLFVBQU0sWUFBWSxLQUFLLFlBQVksU0FBUztBQUM1QyxjQUFVLE1BQU07QUFDaEIsY0FBVSxTQUFTLE1BQU0sRUFBQyxNQUFNLGlCQUFpQixLQUFLLFVBQVMsQ0FBQztBQUFBLEVBQ2xFO0FBQUEsRUFFQSxNQUFNLE9BQU8sZ0JBQW9CO0FBQy9CLFVBQU0sWUFBWSxLQUFLLFlBQVksU0FBUztBQUU1QyxjQUFVLE1BQU07QUFDaEIsVUFBTSxXQUFXLFVBQVUsU0FBUyxNQUFNLEVBQUMsTUFBTSxtQkFBbUIsS0FBSyxVQUFTLENBQUM7QUFFbkYsZUFBVyxPQUFPLGdCQUFlO0FBRS9CLFVBQUksY0FBYztBQUNsQixVQUFJLGNBQWMsZUFBZSxLQUFLO0FBQ3RDLFVBQUksT0FBTyxlQUFlLEtBQUs7QUFDL0IsWUFBTSxRQUFRLFVBQVUsU0FBUyxjQUFjLEVBQUMsTUFBWSxLQUFLLFFBQU8sQ0FBQztBQUN6RSxZQUFNLE9BQU8sTUFBTSxTQUFTLEtBQUssRUFBRSxNQUFNLGFBQWEsTUFBTSxFQUFFLGFBQWEsWUFBWSxFQUFFLENBQUM7QUFDMUYsV0FBSyxTQUFTLFFBQVE7QUFBQSxRQUNWLE1BQU0sU0FBUztBQUFBLE1BQ3ZCLENBQ0o7QUFBQSxJQUlGO0FBQUEsRUFPRjtBQUFBLEVBRUEsTUFBTSxVQUFVO0FBQUEsRUFFaEI7QUFDRjs7O0FEdERBLFNBQW9CO0FBRXBCLElBQUksYUFBYTtBQUNqQixJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGlCQUFpQjtBQUNyQixJQUFJLGVBQWU7QUFDbkIsSUFBSSxjQUFjO0FBQ2xCLElBQUkseUJBQXlCO0FBQzdCLElBQUksdUJBQXVCO0FBSTNCLCtDQUErQyxRQUFnQixNQUFvQztBQU0vRixRQUFNLE1BQU0sT0FBTyxhQUFhO0FBRWhDLE1BQUksYUFBYTtBQUNqQixRQUFNLGFBQWE7QUFDbkIsTUFBSSxPQUFPLENBQUMsS0FBSyxZQUFZO0FBQzdCLE1BQUksd0JBQU8sZ0JBQWdCO0FBRTNCLFFBQU0sVUFBVSxNQUFNLGNBQWMsWUFBWSxZQUFZLFlBQVksSUFBSTtBQUU1RSxNQUFJLGNBQXNCLE9BQU8sT0FBTztBQUV4QyxnQkFBYyxZQUFZLFFBQVEsT0FBTyxLQUFLO0FBQzlDLFVBQVEsSUFBSTtBQUFBLEdBQTBCLGFBQWE7QUFFbkQsUUFBTSxjQUFjLHdDQUF1QyxjQUFjLG1DQUF3QztBQUNqSCxTQUFPLGlCQUFpQixXQUFXO0FBRXZDO0FBSUEsNkJBQTZCLGFBQW9CLFlBQW9CLFlBQW9CLE1BQVU7QUFJL0YsTUFBSSxFQUFDLGdCQUFlO0FBQ3BCLFFBQU0sVUFBVSxFQUFDLE1BQU0sUUFBUSxZQUFZLGFBQVksWUFBd0IsS0FBVTtBQUN6RixRQUFNLFNBQVMsTUFBTSxJQUFJLFFBQVEsQ0FBQyxTQUFTLFdBQVc7QUFDOUMsZ0JBQVksSUFBSSxZQUFZLFNBQVMsU0FBVSxLQUFZLFNBQWM7QUFDckUsVUFBSTtBQUNBLGNBQU07QUFDVixhQUFPLFFBQVEsT0FBTztBQUFBLElBQzlCLENBQUM7QUFBQSxFQUNMLENBQUM7QUFFRCxTQUFPO0FBRVg7QUFHQSxpQ0FBaUMsTUFBYTtBQUsxQyxRQUFNLGFBQWE7QUFDbkIsUUFBTSxhQUFhO0FBR25CLE1BQUksQ0FBQyxPQUFPLGNBQWMsdUJBQXVCLElBQUk7QUFDckQsTUFBSSxvQkFBb0IsV0FBVyxLQUFLLE9BQU8sV0FBVztBQUUxRCxVQUFRLElBQUksZ0JBQWdCLE9BQU87QUFJbkMsTUFBSSxPQUFPLENBQUMsYUFBYSxvQkFBb0IsY0FBYyxZQUFZO0FBR3ZFLFFBQU0sVUFBVSxNQUFNLGNBQWMsWUFBWSxZQUFZLFlBQVksSUFBSTtBQUM1RSxNQUFJLGNBQXNCLE9BQU8sT0FBTztBQUV4QyxnQkFBYyxZQUFZLFFBQVEsT0FBTyxLQUFLO0FBRzlDLFVBQVEsTUFBTSxTQUFTO0FBQ3ZCLE1BQUksZUFBZTtBQUNuQixNQUFJLGNBQWM7QUFDbEIsTUFBSSxlQUFlO0FBTW5CLE1BQUcsWUFBVztBQUNWLG1CQUFlLFdBQVcsS0FBSyxPQUFPLFFBQVE7QUFDOUMsYUFBUyxhQUFhLFdBQVcsTUFBTSxDQUFDLEdBQUU7QUFDdEMscUJBQWUsZUFBZSxPQUFPO0FBQUEsSUFDekM7QUFDQSxrQkFBYyxlQUFlLGdDQUErQixjQUFjLG1DQUF3QztBQUNsSCxXQUFPLENBQUMsYUFBYSxhQUFhLEtBQUs7QUFBQSxFQUMzQyxPQUNJO0FBQ0EsV0FBTyxDQUFDLE1BQU0sTUFBTSxFQUFFO0FBQUEsRUFFMUI7QUFHSjtBQUdBLHlCQUF3QjtBQUNwQixNQUFJLHdCQUFPLG1CQUFtQjtBQUNsQztBQUVBLGdDQUFnQyxNQUFhO0FBV3JDLE1BQUksVUFBVTtBQUNkLE1BQUksVUFBVSxLQUFLLE1BQU0sT0FBTztBQUNoQyxNQUFJLFFBQVE7QUFDWixNQUFHLFNBQVE7QUFDUCxZQUFRLFFBQVE7QUFBQSxFQUNwQjtBQUNBLE1BQUksYUFBYSxLQUFLLE1BQU0sT0FBTztBQUNuQyxVQUFRLElBQUksVUFBVSxPQUFPO0FBQzdCLFVBQVEsSUFBSSxVQUFVO0FBRXRCLFNBQU8sQ0FBQyxPQUFPLFVBQVU7QUFFakM7QUFVQSwrQkFBK0IsTUFBYyxhQUFvQixZQUFtQjtBQUNoRixRQUFNLGFBQWE7QUFDbkIsTUFBSSxjQUFjLHlCQUF3QjtBQUN0QyxRQUFJLE9BQU8sQ0FBQyxhQUFhLE1BQU0sZ0JBQWdCLGFBQWEsd0JBQXdCLG9CQUFvQjtBQUFBLEVBRTVHLE9BQ0k7QUFDQSxRQUFJLE9BQU8sQ0FBQyxhQUFhLE1BQU0sZ0JBQWdCLFdBQVc7QUFBQSxFQUU5RDtBQUVBLFVBQVEsSUFBSSxpQkFBaUI7QUFDN0IsUUFBTSxXQUFXLE1BQU0sY0FBYyxZQUFZLFlBQVksWUFBWSxJQUFJO0FBRTdFLFVBQVEsSUFBSSxRQUFRO0FBQ3BCLFNBQU87QUFFWDtBQUVBLCtCQUErQixjQUFxQjtBQUNoRCxTQUFPLGFBQWEsU0FBUyxpQkFBaUIsS0FBSyxhQUFhLFNBQVMsV0FBVztBQUN4RjtBQUVBLG9DQUFvQyxjQUFxQjtBQUNyRCxTQUFRLGFBQWEsU0FBUyxvQkFBb0IsS0FBSyxhQUFhLFNBQVMsV0FBVztBQUM1RjtBQUVBLG1DQUFtQyxhQUFxQixVQUFjO0FBSWxFLFdBQVMsUUFBUSxVQUFTO0FBQ3RCLFFBQUksS0FBSyxTQUFTLE1BQU0sR0FBRTtBQUN0QixVQUFJLHdCQUFPLFdBQVcsNkJBQTZCLElBQUs7QUFDeEQsYUFBTztBQUFBLElBQ1g7QUFBQSxFQUVKO0FBQ0EsU0FBTztBQUNYO0FBRUEscUNBQXFDLGNBQXNCLFVBQWM7QUFDckUsV0FBUyxRQUFRLFVBQVM7QUFDdEIsUUFBRyxLQUFLLFNBQVMsT0FBTyxHQUFFO0FBQ3RCLFVBQUksd0JBQU8sWUFBWSxtREFBbUQsSUFBSztBQUMvRSxhQUFPO0FBQUEsSUFDWCxXQUNTLEtBQUssU0FBUyxTQUFTLEdBQUU7QUFDOUIsVUFBSSx3QkFBTyxZQUFZLG1DQUFtQyxJQUFLO0FBQy9ELGFBQU87QUFBQSxJQUNYO0FBQUEsRUFDSjtBQUNBLFNBQU87QUFDWDtBQUVBLHNDQUFxQztBQUlqQyxRQUFNLFFBQVEsS0FBSyxJQUFJLE1BQU0saUJBQWlCO0FBQzlDLFdBQVMsUUFBUSxPQUFNO0FBQ25CLFFBQUksZUFBZSxNQUFNLEtBQUssSUFBSSxNQUFNLEtBQUssSUFBSTtBQUNqRCxRQUFJLHNCQUFzQixZQUFZLEdBQUU7QUFFcEMsVUFBSSxDQUFDLE9BQU8sY0FBYyx1QkFBdUIsWUFBWTtBQUM3RCxVQUFJLFVBQVUsV0FBVztBQUN6QixVQUFJLGNBQWMsT0FBTyxLQUFLO0FBQzlCLFVBQUksYUFBYTtBQUNqQixVQUFJLFdBQWdCLE1BQU0sZ0JBQWdCLFNBQVMsYUFBYSxVQUFVO0FBQzFFLFVBQUksQ0FBQywwQkFBMEIsYUFBYSxRQUFRLEdBQUU7QUFFbEQsWUFBSSx3QkFBTyxPQUFPLHFDQUFxQztBQUN2RCx1QkFBZSxhQUFhLFFBQVEsY0FBYyxFQUFFO0FBQ3BELGFBQUssSUFBSSxNQUFNLE9BQU8sTUFBTSxZQUFZO0FBQUEsTUFFNUM7QUFBQSxJQUdKO0FBQUEsRUFFSjtBQUVKO0FBR0EsMkNBQTBDO0FBSXRDLFFBQU0sUUFBUSxLQUFLLElBQUksTUFBTSxpQkFBaUI7QUFDOUMsV0FBUyxRQUFRLE9BQU07QUFDbkIsUUFBSSxlQUFlLE1BQU0sS0FBSyxJQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ2pELFFBQUksMkJBQTJCLFlBQVksR0FBRTtBQUN6QyxVQUFJLENBQUMsT0FBTyxjQUFjLHVCQUF1QixZQUFZO0FBQzdELFVBQUksZUFBZSxPQUFPLEtBQUs7QUFDL0IsVUFBSSxPQUFPLFdBQVc7QUFHdEIsVUFBSSxhQUFhO0FBQ2pCLFVBQUksV0FBZ0IsTUFBTSxnQkFBZ0IsTUFBTSxjQUFjLFVBQVU7QUFFeEUsVUFBSSxDQUFDLDRCQUE0QixjQUFjLFFBQVEsR0FBRTtBQUNyRCxZQUFJLHdCQUFPLFlBQVksc0NBQXNDO0FBQzdELHVCQUFlLGFBQWEsUUFBUSxjQUFjLEVBQUU7QUFDcEQsYUFBSyxJQUFJLE1BQU0sT0FBTyxNQUFNLFlBQVk7QUFBQSxNQUM1QztBQUFBLElBSUo7QUFBQSxFQUVKO0FBQ0EsTUFBSSx3QkFBTyxPQUFPO0FBQ3RCO0FBRUEseUJBQXlCLGNBQXFCO0FBSTFDLFNBQU8sYUFBYSxTQUFTLG9CQUFvQixLQUFPLGNBQWEsU0FBUyxZQUFZLEtBQUssYUFBYSxTQUFTLFlBQVksTUFBUSxhQUFhLFNBQVMsaUJBQWlCLEtBQUssUUFBVSxhQUFhLFNBQVMsVUFBVSxLQUFLO0FBRXhPO0FBRUEsbUJBQW1CLFdBQW1CLFNBQWE7QUFDL0MsUUFBTSxhQUFhLEtBQUssVUFBVSxPQUFPO0FBQ3pDLEVBQUcsYUFBVSxXQUFXLFlBQVksQ0FBQyxRQUFRO0FBQ3pDLFFBQUksS0FBSztBQUNQLGNBQVEsTUFBTSwwQkFBMEIsS0FBSztBQUM3QztBQUFBLElBQ0Y7QUFDQSxZQUFRLElBQUksdUJBQXVCO0FBQUEsRUFDckMsQ0FBQztBQUNQO0FBRUEsd0JBQXdCLFdBQW1CLEtBQVUsT0FBVTtBQUMzRCxFQUFHLFlBQVMsV0FBVyxDQUFDLEtBQUssU0FBYztBQUN2QyxRQUFHLEtBQUs7QUFFSixZQUFNO0FBQUEsSUFDVjtBQUVBLFFBQUk7QUFDSixRQUFHO0FBQ0EsZ0JBQVUsS0FBSyxNQUFNLElBQUk7QUFBQSxJQUM1QixTQUNPLEdBQVA7QUFJUSxnQkFBVSxDQUFDO0FBQUEsSUFDbkI7QUFDQSxZQUFRLE9BQU87QUFDZixVQUFNLGNBQWMsS0FBSyxVQUFVLE9BQU87QUFDMUMsSUFBRyxhQUFVLFdBQVcsYUFBYSxDQUFDLFNBQVE7QUFDMUMsVUFBSTtBQUFLLGNBQU07QUFDZixjQUFRLElBQUksdUJBQXVCO0FBQUEsSUFDdkMsQ0FBQztBQUFBLEVBR0wsQ0FBQztBQUVMO0FBYUEsSUFBTSxtQkFBbUM7QUFBQSxFQUN4QyxXQUFXO0FBQUEsRUFDUixhQUFhO0FBQUEsRUFDYixXQUFXO0FBQUEsRUFDWCxvQkFBb0I7QUFBQSxFQUNwQiwyQkFBMkI7QUFBQSxFQUMzQix5QkFBeUI7QUFBQSxFQUN6QixZQUFZO0FBRWhCO0FBUUEsSUFBcUIsaUJBQXJCLGNBQTRDLHdCQUFNO0FBQUEsRUFHOUMsTUFBTSxTQUFTO0FBQ1gsVUFBTSxLQUFLLGFBQWE7QUFDeEIsU0FBSyxTQUFTLEtBQUssaUJBQWlCO0FBRXBDLFNBQUssYUFBYSxhQUFhLENBQUMsU0FBUSxJQUFJLFdBQVcsSUFBSSxDQUFDO0FBQzVELFNBQUssSUFBSSxVQUFVLGNBQWMsTUFBTTtBQUM1QyxXQUFLLGFBQWE7QUFDbEIsV0FBSyxXQUFXLENBQUMsQ0FBQztBQUFBLElBQ25CLENBQUM7QUFFSyxTQUFLLGNBQWMsS0FBSyxJQUFJLE1BQU0sR0FBRyxVQUFVLENBQUMsU0FBUyxLQUFLLHFCQUFxQixNQUFNLHlCQUFpQixDQUFDLENBQUM7QUFFNUcsU0FBSyxjQUFjLEtBQUssSUFBSSxNQUFNLEdBQUcsVUFBVSxDQUFDLFNBQVMsS0FBSyxxQkFBcUIsTUFBTSx1QkFBZ0IsQ0FBQyxDQUFDO0FBQzNHLFNBQUssY0FBYyxPQUFPLGVBQWUsYUFBYTtBQUV0RCxTQUFLLFdBQVcsRUFBQyxJQUFJLDZCQUE2QixNQUFNLDBCQUEwQixnQkFBZ0IsQ0FBQyxRQUFRLFNBQVMsZ0NBQWdDLFFBQVEsSUFBSSxFQUFDLENBQUM7QUFFbEssU0FBSyxXQUFXLEVBQUMsSUFBSSxlQUFlLE1BQU0sZUFBZSxVQUFVLE1BQU0sS0FBSyxZQUFZLEVBQUMsQ0FBQztBQUU1RixTQUFLLFdBQVcsRUFBQyxJQUFJLHVCQUF1QixNQUFNLGtDQUFrQyxVQUFVLE1BQU0sS0FBSyw2QkFBNkIsRUFBQyxDQUFDO0FBRXhJLFNBQUssV0FBVyxFQUFDLElBQUksc0JBQXNCLE1BQU0sc0JBQXNCLGdCQUFnQixDQUFDLFFBQVEsU0FBUyxLQUFLLG1CQUFtQixRQUFRLElBQUksRUFBQyxDQUFDO0FBRS9JLFNBQUssV0FBVyxFQUFDLElBQUksNEJBQTRCLE1BQU0sMEJBQTBCLFVBQVUsTUFBTSxLQUFLLGlCQUFpQixFQUFDLENBQUM7QUFFekgsU0FBSyxXQUFXLEVBQUMsSUFBSSxlQUFlLE1BQU0sd0JBQXdCLFVBQVUsTUFBTSxxQkFBcUIsRUFBQyxDQUFDO0FBRXpHLFNBQUssV0FBVyxFQUFDLElBQUksb0JBQW9CLE1BQU0sNkJBQTZCLFVBQVUsTUFBTSwwQkFBMEIsRUFBQyxDQUFDO0FBRXhILFNBQUssY0FBYyxJQUFJLGlCQUFpQixLQUFLLEtBQUssSUFBSSxDQUFDO0FBQ3ZELFNBQUssT0FBTyxRQUFRLDRCQUFxQjtBQUN6QyxTQUFLLE9BQU8sUUFBUSxTQUFTLGlCQUFpQjtBQUFBLEVBR2xEO0FBQUEsRUFFQSxXQUFXO0FBQ1AsU0FBSyxJQUFJLFVBQVUsbUJBQW1CLFdBQVc7QUFDakQsU0FBSyxPQUFPLFFBQVEsMkJBQW9CO0FBQUEsRUFFNUM7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUN2QixTQUFLLElBQUksVUFBVSxtQkFBbUIsV0FBVztBQUVqRCxVQUFNLEtBQUssSUFBSSxVQUFVLGFBQWEsS0FBSyxFQUFFLGFBQWE7QUFBQSxNQUN4RCxNQUFNO0FBQUEsTUFDTixRQUFRO0FBQUEsSUFDVixDQUFDO0FBRUQsU0FBSyxJQUFJLFVBQVUsV0FDakIsS0FBSyxJQUFJLFVBQVUsZ0JBQWdCLFdBQVcsRUFBRSxFQUNsRDtBQUFBLEVBQ0Q7QUFBQSxFQUNHLE1BQU0sV0FBVyxTQUFjO0FBNVluQztBQTZZUSxVQUFNLE9BQU8sV0FBSyxJQUFJLFVBQVUsZ0JBQWdCLFdBQVcsRUFBRSxPQUFoRCxtQkFBb0Q7QUFDckQsUUFBSSxnQkFBZ0IsWUFBWTtBQUM1QixXQUFLLE9BQU8sT0FBTztBQUFBLElBQ3ZCO0FBQUEsRUFFaEI7QUFBQSxFQUVBLE1BQU0sZUFBYztBQUNoQixTQUFLLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsTUFBTSxLQUFLLFNBQVMsQ0FBQztBQUN6RSxvQkFBZ0IsS0FBSyxTQUFTLFlBQVk7QUFDMUMsbUJBQWUsS0FBSyxTQUFTO0FBQzdCLHFCQUFpQixLQUFLLFNBQVM7QUFDL0Isa0JBQWMsS0FBSyxTQUFTO0FBQzVCLDZCQUF5QixLQUFLLFNBQVM7QUFDdkMsMkJBQXVCLEtBQUssU0FBUztBQUNyQyxpQkFBYSxLQUFLLFNBQVM7QUFBQSxFQUMvQjtBQUFBLEVBRUEsTUFBTSxlQUFjO0FBQ2hCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUNqQyxvQkFBZ0IsS0FBSyxTQUFTLFlBQVk7QUFDMUMsbUJBQWUsS0FBSyxTQUFTO0FBQzdCLHFCQUFpQixLQUFLLFNBQVM7QUFDL0Isa0JBQWMsS0FBSyxTQUFTO0FBQzVCLDZCQUF5QixLQUFLLFNBQVM7QUFDdkMsMkJBQXVCLEtBQUssU0FBUztBQUNyQyxpQkFBYSxLQUFLLFNBQVM7QUFBQSxFQUMvQjtBQUFBLEVBRUEsTUFBTSxtQkFBa0I7QUFLcEIsVUFBTSxRQUFRLEtBQUssSUFBSSxNQUFNLGlCQUFpQjtBQUM5QyxhQUFTLFFBQVEsT0FBTTtBQUVuQixVQUFJLGVBQWUsTUFBTSxLQUFLLElBQUksTUFBTSxLQUFLLElBQUk7QUFDakQsVUFBSSxnQkFBZ0IsWUFBWSxHQUFFO0FBQzlCLGdCQUFRLElBQUkseUJBQXlCLEtBQUssTUFBTTtBQUVoRCxZQUFJLENBQUMsVUFBVSxTQUFTLFNBQVMsTUFBTSxrQkFBa0IsWUFBWTtBQUNyRSxZQUFJLFNBQVMsSUFBRztBQUNaLGVBQUssSUFBSSxNQUFNLE9BQU8sTUFBTSxRQUFRO0FBQ3BDLGNBQUksd0JBQU8sR0FBRywyQkFBMkI7QUFBQSxRQUU3QztBQUFBLE1BS0o7QUFBQSxJQUVKO0FBQUEsRUFPSjtBQUFBLEVBQ0EsTUFBTSxtQkFBbUIsUUFBZ0IsTUFBb0M7QUFDekUsVUFBTSxNQUFNLE9BQU8sYUFBYTtBQUNoQyxRQUFJLHdCQUFPLHVCQUF1QjtBQUNsQyxRQUFJLGFBQWE7QUFDakIsVUFBTSxhQUFhO0FBQ25CLFFBQUksT0FBTyxDQUFDLEtBQUssY0FBYyxLQUFLLFNBQVMsU0FBUztBQUN0RCxVQUFNLGdCQUFnQixNQUFNLGNBQWMsWUFBWSxZQUFZLFlBQVksSUFBSTtBQUVsRixRQUFJLGlCQUFpQixNQUFNLEtBQUssdUJBQXVCLGFBQWE7QUFHcEUsU0FBSyxXQUFXLGNBQWM7QUFBQSxFQUdsQztBQUFBLEVBRUEsTUFBTSxxQkFBcUIsTUFBcUIsTUFBYztBQUMxRCxRQUFJLGFBQWE7QUFDakIsVUFBTSxhQUFhO0FBQ25CLFVBQU0sY0FBYztBQUNwQixRQUFJLFlBQVksS0FBSyxLQUFLLE1BQU0sS0FBSyxFQUFFO0FBQ3ZDLFFBQUksWUFBWSxLQUFLLFNBQVMsWUFBWSxLQUFLO0FBQy9DLFFBQUksZUFBZSxjQUFjO0FBQ2pDLFFBQUksUUFBUSwyQkFBa0I7QUFFMUIsVUFBSSxRQUFRLEVBQUMsZUFBZSwyQkFBbUIsYUFBYSxVQUFTO0FBQ3JFLHFCQUFlLGNBQWMsV0FBVyxLQUFLO0FBQUEsSUFDakQsV0FDUyxRQUFRLHlCQUFpQjtBQUU5QixVQUFJLHdCQUFPLEdBQUcsNEJBQTRCO0FBQzFDLFVBQUksUUFBUSxFQUFDLGVBQWUseUJBQWtCLGFBQWEsVUFBUztBQUNwRSxxQkFBZSxjQUFjLFdBQVcsS0FBSztBQUFBLElBQ2pELFdBSVMsUUFBUSxpQkFBYTtBQUMxQixVQUFJLHdCQUFPLEdBQUcsNEJBQTRCO0FBQzFDLFVBQUksUUFBUSxFQUFDLGVBQWUsaUJBQWMsYUFBYSxVQUFTO0FBQ2hFLHFCQUFlLGNBQWMsV0FBVyxLQUFLO0FBQUEsSUFFakQ7QUFBQSxFQUdKO0FBQUEsRUFDQSxNQUFNLCtCQUE4QjtBQUNoQyxVQUFNLGNBQWM7QUFDcEIsUUFBSSxlQUFlLGNBQWM7QUFDakMsSUFBRyxZQUFTLGNBQWMsT0FBTyxLQUFLLFNBQWM7QUFDaEQsVUFBRyxLQUFLO0FBRUosY0FBTTtBQUFBLE1BQ1Y7QUFFQSxVQUFJO0FBQ0osVUFBSSx3QkFBTywrQkFBK0I7QUFDMUMsV0FBSyxPQUFPLFFBQVEsa0NBQTJCO0FBQy9DLFdBQUssT0FBTyxRQUFRLFNBQVMsa0NBQWtDO0FBQy9ELFVBQUc7QUFDQSwwQkFBa0IsS0FBSyxNQUFNLElBQUk7QUFDakMsZ0JBQVEsSUFBSSxlQUFlO0FBQUEsTUFDOUIsU0FDTyxHQUFQO0FBQ1EsWUFBSSx3QkFBTyx1QkFBdUI7QUFDbEMsYUFBSyxPQUFPLFFBQVEsNEJBQXFCO0FBQ3pDLGFBQUssT0FBTyxRQUFRLFNBQVMsb0JBQW9CO0FBQ2pEO0FBQUEsTUFDUjtBQUNBLFVBQUksT0FBTyxLQUFLLGVBQWUsRUFBRSxTQUFTLEdBQUU7QUFDeEMsWUFBSSx3QkFBTyx1QkFBdUI7QUFDbEMsYUFBSyxPQUFPLFFBQVEsNEJBQXFCO0FBQ3pDLGFBQUssT0FBTyxRQUFRLFNBQVMsb0JBQW9CO0FBQ2pEO0FBQUEsTUFFSjtBQUVBLFVBQUc7QUFDQyxjQUFNLEtBQUssWUFBWSxZQUFZO0FBQUEsTUFDdkMsU0FDTyxHQUFQO0FBQ0ksWUFBSSx3QkFBTyxvQ0FBb0M7QUFDL0MsYUFBSyxPQUFPLFFBQVEsNEJBQXFCO0FBQ3pDLGFBQUssT0FBTyxRQUFRLFNBQVMsb0JBQW9CO0FBQ2pEO0FBQUEsTUFDSjtBQUVBLFVBQUksd0JBQU8sb0JBQW9CO0FBRS9CLFdBQUssT0FBTyxRQUFRLDRCQUFxQjtBQUN6QyxXQUFLLE9BQU8sUUFBUSxTQUFTLG9CQUFvQjtBQUNqRCxnQkFBVSxjQUFjLENBQUMsQ0FBQztBQUFBLElBRTlCLENBQUM7QUFBQSxFQUVMO0FBQUEsRUFFQSxNQUFNLGNBQWE7QUFDZixRQUFJLFFBQVEsS0FBSyxJQUFJLE1BQU0saUJBQWlCO0FBQzVDLFFBQUksYUFBa0IsQ0FBQztBQUN2QixRQUFJLGFBQWEsS0FBSyxTQUFTO0FBQy9CLFVBQU0sY0FBYztBQUNwQixRQUFJLHdCQUFPLGtDQUFrQztBQUM3QyxTQUFLLE9BQU8sUUFBUSxrQ0FBMkI7QUFDL0MsU0FBSyxPQUFPLFFBQVEsU0FBUyxrQ0FBa0M7QUFDL0QsYUFBUSxRQUFRLE9BQU07QUFDbEIsVUFBSSxLQUFLLEtBQUssU0FBUyxVQUFVLEdBQUU7QUFDL0IsbUJBQVcsS0FBSyxZQUFZLEVBQUMsZUFBZSxpQkFBYSxhQUFhLGFBQWEsS0FBSyxLQUFJO0FBQUEsTUFDaEc7QUFBQSxJQUNKO0FBQ0EsWUFBUSxJQUFJLGlCQUFpQixXQUFXLFFBQVE7QUFDaEQsVUFBTSxZQUFZLGNBQWM7QUFDaEMsY0FBVSxXQUFXLFVBQVU7QUFDL0IsUUFBRztBQUNDLFlBQU0sS0FBSyxZQUFZLFNBQVM7QUFBQSxJQUVwQyxTQUNPLEdBQVA7QUFDSSxVQUFJLHdCQUFPLG9DQUFvQztBQUMvQztBQUFBLElBQ0o7QUFDQSxRQUFJLHdCQUFPLG9CQUFvQjtBQUMvQixTQUFLLE9BQU8sUUFBUSw0QkFBcUI7QUFDekMsU0FBSyxPQUFPLFFBQVEsU0FBUyxvQkFBb0I7QUFDakQsY0FBVSxXQUFXLENBQUMsQ0FBQztBQUFBLEVBSzNCO0FBQUEsRUFFQSxNQUFNLFlBQVksV0FBa0I7QUFLaEMsUUFBSSxhQUFhO0FBQ2pCLFVBQU0sYUFBYTtBQUNuQixVQUFNLGNBQWM7QUFFcEIsUUFBSSxPQUFPLENBQUMsV0FBVyxjQUFjLFdBQVc7QUFHaEQsUUFBSSxVQUFVLE1BQU0sY0FBYyxZQUFZLFlBQVksWUFBWSxJQUFJO0FBQzFFLFlBQVEsSUFBSSxPQUFPO0FBQ25CLFNBQUssT0FBTyxRQUFRLDRCQUFxQjtBQUN6QyxTQUFLLE9BQU8sUUFBUSxTQUFTLG9CQUFvQjtBQUNqRCxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBQ0EsTUFBTSx1QkFBdUIsU0FBa0I7QUEvbEJuRDtBQWttQlEsUUFBSSxVQUFVO0FBQ2QsUUFBSSxpQkFBc0IsQ0FBQztBQUMzQixRQUFJLG1CQUFtQixXQUFLLElBQUksVUFBVSxjQUFjLE1BQWpDLG1CQUFvQztBQUMzRCxZQUFRLElBQUkscUJBQXFCLGtCQUFrQjtBQUNuRCxhQUFTLFVBQVUsU0FBUTtBQUN6QixVQUFJLFVBQVUsS0FBSyxLQUFLLFdBQVUsR0FDbEM7QUFDRSxZQUFJLFdBQVcsTUFBTyxRQUFRLEdBQUcsT0FBTyxJQUFJO0FBQzVDLFlBQUksU0FBUyxRQUFRLEdBQUcsVUFBUSxDQUFDO0FBQ2pDLGlCQUFTLGlDQUFRLE1BQU0sS0FBSyxHQUFHO0FBRS9CLGdCQUFRLElBQUksWUFBWSx5QkFBeUIsUUFBUTtBQUV6RCxZQUFHLFVBQVUsa0JBQWlCO0FBRTFCLG9CQUFVLFVBQVU7QUFDcEI7QUFBQSxRQUNKO0FBQ0EsWUFBSSxjQUFjLE1BQU0sS0FBSyxpQkFBaUIsTUFBTTtBQUNwRCxnQkFBUSxJQUFJLFdBQVc7QUFDdkIsWUFBSSxlQUFlLFFBQVEsVUFBVSxNQUNyQztBQUNJLGNBQUksZ0JBQWdCO0FBQ3BCLDBCQUFnQixnQkFBZ0IsS0FBSyxJQUFJLE1BQU0sUUFBUSxJQUFJO0FBRTNELDBCQUFnQixnQkFBZ0IsWUFBWTtBQUM1QyxrQkFBUSxJQUFJLG1CQUFtQixlQUFlO0FBQzlDLHlCQUFlLFVBQVUsRUFBQyxlQUFjLGVBQWUsUUFBUSxTQUFRO0FBQUEsUUFFM0U7QUFBQSxNQUtGO0FBRUEsZ0JBQVUsVUFBVTtBQUFBLElBQ3RCO0FBQ0EsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUNBLE1BQU0saUJBQWlCLFFBQXlCO0FBQzVDLFFBQUksWUFBWSxLQUFLLElBQUksTUFBTSxpQkFBaUI7QUFDaEQsYUFBUyxRQUFRLFdBQVU7QUFDdkIsVUFBSSxXQUFXLEtBQUs7QUFDcEIsVUFBSSxZQUFZLFFBQU87QUFDbkIsZUFBTztBQUFBLE1BQ1g7QUFBQSxJQUNKO0FBQ0EsV0FBTztBQUFBLEVBR1g7QUFDSjtBQUVBLElBQU0sbUJBQU4sY0FBK0Isa0NBQWdCO0FBQUEsRUFFM0MsWUFBWSxLQUFVLFFBQXVCO0FBQ3pDLFVBQU0sS0FBSyxNQUFNO0FBQ2pCLFNBQUssU0FBUztBQUFBLEVBQ2xCO0FBQUEsRUFDQSxVQUFnQjtBQUNsQixVQUFNLEVBQUMsZ0JBQWU7QUFFdEIsZ0JBQVksTUFBTTtBQUVsQixnQkFBWSxTQUFTLE1BQU0sRUFBQyxNQUFNLDJCQUEwQixDQUFDO0FBRTdELFFBQUkseUJBQVEsV0FBVyxFQUNyQixRQUFRLHFCQUFxQixFQUM3QixRQUFRLHdEQUF3RCxFQUNoRSxRQUFRLFVBQVEsS0FDZixlQUFlLFlBQVksRUFDM0IsU0FBUyxLQUFLLE9BQU8sU0FBUyxTQUFTLEVBQ3ZDLFNBQVMsT0FBTyxVQUFVO0FBQzFCLGNBQVEsSUFBSSxXQUFXLEtBQUs7QUFDNUIsV0FBSyxPQUFPLFNBQVMsWUFBWTtBQUNqQyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDaEMsQ0FBQyxDQUFDO0FBQ0UsUUFBSSx5QkFBUSxXQUFXLEVBQ3RCLFFBQVEsZ0JBQWdCLEVBQ3hCLFFBQVEscUJBQXFCLEVBQzdCLFFBQVEsVUFBUSxLQUNaLGVBQWUsV0FBVyxFQUMxQixTQUFTLEtBQUssT0FBTyxTQUFTLFNBQVMsRUFDdkMsU0FBUyxPQUFPLFVBQVU7QUFDdkIsY0FBUSxJQUFJLGtCQUFrQixLQUFLO0FBQ25DLFdBQUssT0FBTyxTQUFTLFlBQVk7QUFDakMsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLElBQ25DLENBQUMsQ0FBQztBQUNOLFFBQUkseUJBQVEsV0FBVyxFQUN0QixRQUFRLG1CQUFtQixFQUMzQixRQUFRLHVCQUF1QixFQUMvQixRQUFRLFVBQVEsS0FDWixlQUFlLFdBQVcsRUFDMUIsU0FBUyxLQUFLLE9BQU8sU0FBUyxXQUFXLEVBQ3pDLFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGNBQVEsSUFBSSxVQUFVLEtBQUs7QUFDM0IsV0FBSyxPQUFPLFNBQVMsY0FBYztBQUNuQyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDbkMsQ0FBQyxDQUFDO0FBQ04sUUFBSSx5QkFBUSxXQUFXLEVBQ3RCLFFBQVEsdUJBQXVCLEVBQy9CLFFBQVEsZ0pBQWdKLEVBQ3hKLFFBQVEsVUFBUSxLQUNaLGVBQWUsYUFBYSxFQUM1QixTQUFTLEtBQUssT0FBTyxTQUFTLGtCQUFrQixFQUNoRCxTQUFTLE9BQU8sVUFBVTtBQUN2QixjQUFRLElBQUksa0JBQWtCLEtBQUs7QUFDbkMsV0FBSyxPQUFPLFNBQVMscUJBQXFCO0FBQzFDLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNuQyxDQUFDLENBQUM7QUFDTixRQUFJLHlCQUFRLFdBQVcsRUFDdEIsUUFBUSxxQ0FBcUMsRUFDN0MsUUFBUSw2SUFBK0ksRUFDdkosUUFBUSxVQUFRLEtBQ1osZUFBZSxhQUFhLEVBQzVCLFNBQVMsS0FBSyxPQUFPLFNBQVMseUJBQXlCLEVBQ3ZELFNBQVMsT0FBTyxVQUFVO0FBQ3ZCLGNBQVEsSUFBSSxzQ0FBc0MsS0FBSztBQUN2RCxXQUFLLE9BQU8sU0FBUyw0QkFBNEI7QUFDakQsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLElBQ25DLENBQUMsQ0FBQztBQUNOLFFBQUkseUJBQVEsV0FBVyxFQUN0QixRQUFRLG1DQUFtQyxFQUMzQyxRQUFRLCtFQUErRSxFQUN2RixRQUFRLFVBQVEsS0FDWixlQUFlLGFBQWEsRUFDNUIsU0FBUyxLQUFLLE9BQU8sU0FBUyx1QkFBdUIsRUFDckQsU0FBUyxPQUFPLFVBQVU7QUFDdkIsY0FBUSxJQUFJLDhCQUE4QixLQUFLO0FBQy9DLFdBQUssT0FBTyxTQUFTLDBCQUEwQjtBQUMvQyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDbkMsQ0FBQyxDQUFDO0FBQ04sUUFBSSx5QkFBUSxXQUFXLEVBQ3RCLFFBQVEsaUNBQWlDLEVBQ3pDLFFBQVEsd0NBQXdDLEVBQ2hELFFBQVEsVUFBUSxLQUNaLGVBQWUsWUFBWSxFQUMzQixTQUFTLEtBQUssT0FBTyxTQUFTLFVBQVUsRUFDeEMsU0FBUyxPQUFPLFVBQVU7QUFDdkIsY0FBUSxJQUFJLGlCQUFpQixLQUFLO0FBQ2xDLFdBQUssT0FBTyxTQUFTLGFBQWE7QUFDbEMsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLElBQ25DLENBQUMsQ0FBQztBQUFBLEVBQ2I7QUFFRDsiLAogICJuYW1lcyI6IFtdCn0K
