/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/python-shell/index.js
var require_python_shell = __commonJS({
  "node_modules/python-shell/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PythonShell = exports.NewlineTransformer = exports.PythonShellError = void 0;
    var events_1 = require("events");
    var child_process_1 = require("child_process");
    var os_1 = require("os");
    var path_1 = require("path");
    var stream_1 = require("stream");
    var fs_1 = require("fs");
    var util_1 = require("util");
    function toArray(source) {
      if (typeof source === "undefined" || source === null) {
        return [];
      } else if (!Array.isArray(source)) {
        return [source];
      }
      return source;
    }
    function extend(obj, ...args) {
      Array.prototype.slice.call(arguments, 1).forEach(function(source) {
        if (source) {
          for (let key in source) {
            obj[key] = source[key];
          }
        }
      });
      return obj;
    }
    function getRandomInt() {
      return Math.floor(Math.random() * 1e10);
    }
    var execPromise = (0, util_1.promisify)(child_process_1.exec);
    var PythonShellError = class extends Error {
    };
    exports.PythonShellError = PythonShellError;
    var NewlineTransformer = class extends stream_1.Transform {
      _transform(chunk, encoding, callback) {
        let data = chunk.toString();
        if (this._lastLineData)
          data = this._lastLineData + data;
        const lines = data.split(os_1.EOL);
        this._lastLineData = lines.pop();
        lines.forEach(this.push.bind(this));
        callback();
      }
      _flush(done) {
        if (this._lastLineData)
          this.push(this._lastLineData);
        this._lastLineData = null;
        done();
      }
    };
    exports.NewlineTransformer = NewlineTransformer;
    var PythonShell = class extends events_1.EventEmitter {
      constructor(scriptPath, options, stdoutSplitter = null, stderrSplitter = null) {
        super();
        function resolve(type, val) {
          if (typeof val === "string") {
            return PythonShell[type][val];
          } else if (typeof val === "function") {
            return val;
          }
        }
        if (scriptPath.trim().length == 0)
          throw Error("scriptPath cannot be empty! You must give a script for python to run");
        let self = this;
        let errorData = "";
        events_1.EventEmitter.call(this);
        options = extend({}, PythonShell.defaultOptions, options);
        let pythonPath2;
        if (!options.pythonPath) {
          pythonPath2 = PythonShell.defaultPythonPath;
        } else
          pythonPath2 = options.pythonPath;
        let pythonOptions = toArray(options.pythonOptions);
        let scriptArgs = toArray(options.args);
        this.scriptPath = (0, path_1.join)(options.scriptPath || "", scriptPath);
        this.command = pythonOptions.concat(this.scriptPath, scriptArgs);
        this.mode = options.mode || "text";
        this.formatter = resolve("format", options.formatter || this.mode);
        this.parser = resolve("parse", options.parser || this.mode);
        this.stderrParser = resolve("parse", options.stderrParser || "text");
        this.terminated = false;
        this.childProcess = (0, child_process_1.spawn)(pythonPath2, this.command, options);
        ["stdout", "stdin", "stderr"].forEach(function(name) {
          self[name] = self.childProcess[name];
          self.parser && self[name] && self[name].setEncoding(options.encoding || "utf8");
        });
        if (this.parser && this.stdout) {
          if (!stdoutSplitter)
            stdoutSplitter = new NewlineTransformer();
          stdoutSplitter.setEncoding(options.encoding || "utf8");
          this.stdout.pipe(stdoutSplitter).on("data", (chunk) => {
            this.emit("message", self.parser(chunk));
          });
        }
        if (this.stderrParser && this.stderr) {
          if (!stderrSplitter)
            stderrSplitter = new NewlineTransformer();
          stderrSplitter.setEncoding(options.encoding || "utf8");
          this.stderr.pipe(stderrSplitter).on("data", (chunk) => {
            this.emit("stderr", self.stderrParser(chunk));
          });
        }
        if (this.stderr) {
          this.stderr.on("data", function(data) {
            errorData += "" + data;
          });
          this.stderr.on("end", function() {
            self.stderrHasEnded = true;
            terminateIfNeeded();
          });
        } else {
          self.stderrHasEnded = true;
        }
        if (this.stdout) {
          this.stdout.on("end", function() {
            self.stdoutHasEnded = true;
            terminateIfNeeded();
          });
        } else {
          self.stdoutHasEnded = true;
        }
        this.childProcess.on("error", function(err) {
          self.emit("error", err);
        });
        this.childProcess.on("exit", function(code, signal) {
          self.exitCode = code;
          self.exitSignal = signal;
          terminateIfNeeded();
        });
        function terminateIfNeeded() {
          if (!self.stderrHasEnded || !self.stdoutHasEnded || self.exitCode == null && self.exitSignal == null)
            return;
          let err;
          if (self.exitCode && self.exitCode !== 0) {
            if (errorData) {
              err = self.parseError(errorData);
            } else {
              err = new PythonShellError("process exited with code " + self.exitCode);
            }
            err = extend(err, {
              executable: pythonPath2,
              options: pythonOptions.length ? pythonOptions : null,
              script: self.scriptPath,
              args: scriptArgs.length ? scriptArgs : null,
              exitCode: self.exitCode
            });
            if (self.listeners("pythonError").length || !self._endCallback) {
              self.emit("pythonError", err);
            }
          }
          self.terminated = true;
          self.emit("close");
          self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);
        }
        ;
      }
      static checkSyntax(code) {
        return __awaiter(this, void 0, void 0, function* () {
          const randomInt = getRandomInt();
          const filePath = (0, os_1.tmpdir)() + path_1.sep + `pythonShellSyntaxCheck${randomInt}.py`;
          const writeFilePromise = (0, util_1.promisify)(fs_1.writeFile);
          return writeFilePromise(filePath, code).then(() => {
            return this.checkSyntaxFile(filePath);
          });
        });
      }
      static getPythonPath() {
        return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;
      }
      static checkSyntaxFile(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
          const pythonPath2 = this.getPythonPath();
          let compileCommand = `${pythonPath2} -m py_compile ${filePath}`;
          return execPromise(compileCommand);
        });
      }
      static run(scriptPath, options, callback) {
        let pyshell = new PythonShell(scriptPath, options);
        let output = [];
        return pyshell.on("message", function(message) {
          output.push(message);
        }).end(function(err) {
          return callback(err ? err : null, output.length ? output : null);
        });
      }
      static runString(code, options, callback) {
        const randomInt = getRandomInt();
        const filePath = os_1.tmpdir + path_1.sep + `pythonShellFile${randomInt}.py`;
        (0, fs_1.writeFileSync)(filePath, code);
        return PythonShell.run(filePath, options, callback);
      }
      static getVersion(pythonPath2) {
        if (!pythonPath2)
          pythonPath2 = this.getPythonPath();
        return execPromise(pythonPath2 + " --version");
      }
      static getVersionSync(pythonPath2) {
        if (!pythonPath2)
          pythonPath2 = this.getPythonPath();
        return (0, child_process_1.execSync)(pythonPath2 + " --version").toString();
      }
      parseError(data) {
        let text = "" + data;
        let error;
        if (/^Traceback/.test(text)) {
          let lines = text.trim().split(os_1.EOL);
          let exception = lines.pop();
          error = new PythonShellError(exception);
          error.traceback = data;
          error.stack += os_1.EOL + "    ----- Python Traceback -----" + os_1.EOL + "  ";
          error.stack += lines.slice(1).join(os_1.EOL + "  ");
        } else {
          error = new PythonShellError(text);
        }
        return error;
      }
      send(message) {
        if (!this.stdin)
          throw new Error("stdin not open for writing");
        let data = this.formatter ? this.formatter(message) : message;
        if (this.mode !== "binary")
          data += os_1.EOL;
        this.stdin.write(data);
        return this;
      }
      end(callback) {
        if (this.childProcess.stdin) {
          this.childProcess.stdin.end();
        }
        this._endCallback = callback;
        return this;
      }
      kill(signal) {
        this.terminated = this.childProcess.kill(signal);
        return this;
      }
      terminate(signal) {
        return this.kill(signal);
      }
    };
    exports.PythonShell = PythonShell;
    PythonShell.defaultPythonPath = process.platform != "win32" ? "python3" : "python";
    PythonShell.defaultOptions = {};
    PythonShell.format = {
      text: function toText(data) {
        if (!data)
          return "";
        else if (typeof data !== "string")
          return data.toString();
        return data;
      },
      json: function toJson(data) {
        return JSON.stringify(data);
      }
    };
    PythonShell.parse = {
      text: function asText(data) {
        return data;
      },
      json: function asJson(data) {
        return JSON.parse(data);
      }
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VCWizardPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// view.ts
var import_obsidian = require("obsidian");
var WIZARD_VIEW = "wizard-view";
var WizardView = class extends import_obsidian.ItemView {
  constructor(leaf) {
    super(leaf);
    this.icon = "sun";
  }
  getViewType() {
    return WIZARD_VIEW;
  }
  getDisplayText() {
    return "Example view";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("h4", { text: "Related Ideas", cls: "heading" });
  }
  async update(search_results) {
    const container = this.containerEl.children[1];
    container.empty();
    const outerDiv = container.createEl("h4", { text: "Related Ideas\n", cls: "heading" });
    for (const key in search_results) {
      let source_name = key;
      let source_path = search_results[key]["source_path"];
      let text = search_results[key]["text"];
      const quote = container.createEl("blockquote", { text, cls: "quote" });
      const link = quote.createEl("a", { href: source_path, attr: { "data-path": source_path } });
      link.createEl("span", {
        text: "\n--" + source_name
      });
    }
  }
  async onClose() {
  }
};

// main.ts
var fs = __toESM(require("fs"));
var pythonPath = "";
var scriptPath_AI = "";
var affinityAPIKey = "";
var openaiAPIKey = "";
var owner_value = "10";
var connection_owner_field = "10";
var venture_network_list = "500";
async function summarize_selected_startup_text(editor, view, status) {
  const sel = editor.getSelection();
  let scriptPath = scriptPath_AI;
  const scriptName = "startup_summarizer_helper.py";
  var args = [sel, openaiAPIKey];
  new import_obsidian2.Notice("Summarizing...");
  status.setText("\u{1F9D9}: VC Wizard summarizing...");
  status.setAttr("title", "Wizard is summarizing...");
  const summary = await launch_python(pythonPath, scriptPath, scriptName, args);
  let new_summary = String(summary);
  new_summary = new_summary.replace(/,-/g, "\n-");
  console.log(`The startup summary:
 ${new_summary}`);
  const replacement = "#gpt_summarized, #review_startup \n" + new_summary + "\n# Stop Indexing \n## Notes\n" + sel;
  editor.replaceSelection(replacement);
  status.setText("\u{1F9D9}: VC Wizard ready");
  status.setAttr("title", "Wizard is ready");
}
async function launch_python(pythonPath2, scriptPath, scriptName, args) {
  let { PythonShell } = require_python_shell();
  const options = { mode: "text", pythonPath: pythonPath2, scriptPath, args };
  const result = await new Promise((resolve, reject) => {
    PythonShell.run(scriptName, options, function(err, results) {
      if (err)
        throw err;
      return resolve(results);
    });
  });
  return result;
}
async function summarize_vc_text(text) {
  const scriptPath = scriptPath_AI;
  const scriptName = "vc_summarizer_helper.py";
  let [title, substrings] = extract_title_and_note(text);
  let hashtags;
  try {
    hashtags = substrings[0].split("Tags:")[1];
  } catch (e) {
    hashtags = substrings[0];
    new import_obsidian2.Notice(`${title}: Does not have any guiding hashtags, this could help the summarizer understand the VC better`, 3600);
  }
  let text_to_summarize = hashtags + "\n" + substrings[1];
  console.log(`Summarizing: ${title}`);
  var args = ["Notes:\n" + text_to_summarize + "Summary:\n", openaiAPIKey];
  const summary = await launch_python(pythonPath, scriptPath, scriptName, args);
  let new_summary = String(summary);
  new_summary = new_summary.replace(/,-/g, "\n-");
  title = title.toString();
  let leading_text = "";
  let replacement = "";
  let tailing_text = hashtags;
  if (substrings) {
    leading_text = substrings[0] + "\n" + title + "\n";
    for (let substring of substrings.slice(1)) {
      tailing_text = tailing_text + "\n" + substring;
    }
    replacement = leading_text + "#gpt_summarized, #review \n" + new_summary + "\n# Stop Indexing \n## Notes\n" + tailing_text;
    return [replacement, new_summary, title];
  } else {
    return [text, text, ""];
  }
}
function create_notice() {
  new import_obsidian2.Notice("Nice to meet you!");
}
function extract_title_and_note(text) {
  let pattern = /^# .*\n/gm;
  let matches = text.match(pattern);
  let title = "";
  if (matches) {
    title = matches[0];
  }
  let substrings = text.split(pattern);
  console.log(`Title: ${title}`);
  console.log(substrings);
  return [title, substrings];
}
async function update_affinity(note, entity_name, scriptName) {
  const scriptPath = scriptPath_AI;
  if (scriptName == "affinity_vc_helper.py") {
    var args = [entity_name, note, affinityAPIKey, owner_value, connection_owner_field, venture_network_list];
  } else {
    var args = [entity_name, note, affinityAPIKey, owner_value];
  }
  console.log("Update Affinity");
  const response = await launch_python(pythonPath, scriptPath, scriptName, args);
  console.log(response);
  return response;
}
function vc_ready_for_affinity(file_content) {
  return file_content.includes("#gpt_summarized") && file_content.includes("#Affinity");
}
function startup_ready_for_affinity(file_content) {
  return file_content.includes("#startups/screened") && file_content.includes("#Affinity");
}
function is_startup_ready_for_training(file_content) {
  return file_content.includes("#startups/screened") && file_content.includes("#gpt_summarized") && !file_content.includes("#review_startup") && !file_content.includes("#saved");
}
function is_vc_ready_for_training(file_content) {
  return file_content.includes("#network/connected") && file_content.includes("#gpt_summarized") && !file_content.includes("#review") && !file_content.includes("#saved");
}
function notify_for_missing_people(person_name, response) {
  for (let item of response) {
    if (item.includes("Oops")) {
      new import_obsidian2.Notice(`Person: ${person_name} was not found`, 36e3);
      return true;
    }
  }
  return false;
}
function notify_for_missing_startups(startup_name, response) {
  for (let item of response) {
    if (item.includes("Error")) {
      new import_obsidian2.Notice(`Startup: ${startup_name} was found but could not be updated`, 36e3);
      return true;
    } else if (item.includes("Startup")) {
      new import_obsidian2.Notice(`Startup: ${startup_name} could not be found`, 36e3);
      return true;
    }
  }
  return false;
}
async function push_vcs_to_affinity(status) {
  const files = this.app.vault.getMarkdownFiles();
  status.setText("\u{1F9D9}: VC Wizard syncing with Affinity...");
  status.setAttr("title", "Wizard is pushing VCs info to Affinity...");
  for (let item of files) {
    let file_content = await this.app.vault.read(item);
    if (vc_ready_for_affinity(file_content)) {
      let [title, substrings] = extract_title_and_note(file_content);
      let summary = substrings[1];
      let person_name = String(title);
      let scriptName = "affinity_vc_helper.py";
      let response = await update_affinity(summary, person_name, scriptName);
      if (!notify_for_missing_people(person_name, response)) {
        new import_obsidian2.Notice(`VC: ${person_name} was updated on Affinity`);
        file_content = file_content.replace(/#Affinity/g, "");
        this.app.vault.modify(item, file_content);
      }
    }
  }
  status.setText("\u{1F9D9}: VC Wizard ready");
  status.setAttr("title", "Wizard is ready");
}
async function push_startups_to_affinity(status) {
  const files = this.app.vault.getMarkdownFiles();
  status.setText("\u{1F9D9}: VC Wizard syncing with Affinity...");
  status.setAttr("title", "Wizard is pushing startup info to Affinity...");
  for (let item of files) {
    let file_content = await this.app.vault.read(item);
    if (startup_ready_for_affinity(file_content)) {
      let [title, substrings] = extract_title_and_note(file_content);
      let startup_name = String(title);
      let note = substrings[1];
      let scriptName = "affinity_startup_helper.py";
      let response = await update_affinity(note, startup_name, scriptName);
      if (!notify_for_missing_startups(startup_name, response)) {
        new import_obsidian2.Notice(`Startup: ${startup_name} was updated on Affinity`);
        file_content = file_content.replace(/#Affinity/g, "");
        this.app.vault.modify(item, file_content);
      }
    }
  }
  new import_obsidian2.Notice("Done!");
  status.setText("\u{1F9D9}: VC Wizard ready");
  status.setAttr("title", "Wizard is ready");
}
function is_summarizable(file_content) {
  return file_content.includes("#network/connected") && (file_content.includes("#Entity/VC") || file_content.includes("#Person/VC")) && file_content.includes("#gpt_summarized") != true && file_content.includes("dataview") != true;
}
function save_json(file_path, content) {
  const jsonString = JSON.stringify(content);
  fs.writeFile(file_path, jsonString, (err) => {
    if (err) {
      console.error(`Error saving the file: ${err}`);
      return;
    }
    console.log("File has been created");
  });
}
function append_to_json(file_path, key, value) {
  fs.readFile(file_path, (err, data) => {
    if (err) {
      throw err;
    }
    let oldData;
    try {
      oldData = JSON.parse(data);
    } catch (e) {
      oldData = {};
    }
    oldData[key] = value;
    const updatedJson = JSON.stringify(oldData);
    fs.writeFile(file_path, updatedJson, (err2) => {
      if (err2)
        throw err2;
      console.log("Data appended to file");
    });
  });
}
var DEFAULT_SETTINGS = {
  vaultPath: "default",
  affinityKey: "default",
  openAIKey: "default",
  owner_person_value: "10",
  connection_owner_field_id: "100",
  venture_network_list_id: "500",
  pythonPath: "<path-to-virtual-env>"
};
var VCWizardPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.status = this.addStatusBarItem();
    this.registerView(WIZARD_VIEW, (leaf) => new WizardView(leaf));
    this.app.workspace.onLayoutReady(() => {
      this.activateView();
      this.updateView([]);
    });
    this.registerEvent(this.app.vault.on("modify", (file) => this.register_file_change(file, "modified" /* modified */)));
    this.registerEvent(this.app.vault.on("delete", (file) => this.register_file_change(file, "deleted" /* deleted */)));
    this.addRibbonIcon("sun", "Omar Plugin", create_notice);
    this.addCommand({ id: "summarize-startup-command", name: "Summarize This Startup", editorCallback: (editor, view) => summarize_selected_startup_text(editor, view, this.status) });
    this.addCommand({ id: "index-vault", name: "Index Vault", callback: () => this.index_vault() });
    this.addCommand({ id: "index-changed-files", name: "Reindex New/Changed Files Only", callback: () => this.index_new_and_modified_files() });
    this.addCommand({ id: "find-similar-ideas", name: "Find Similar Ideas", editorCallback: (editor, view) => this.find_similar_ideas(editor, view) });
    this.addCommand({ id: "summarize-all-vc-command", name: "Summarize All VC Notes", callback: () => this.summarize_all_vc() });
    this.addCommand({ id: "affinity-vc", name: "Push VCs to Affinity", callback: () => push_vcs_to_affinity(this.status) });
    this.addCommand({ id: "affinity-startup", name: "Push Startups to Affinity", callback: () => push_startups_to_affinity(this.status) });
    this.addCommand({ id: "save-startup-summary", name: "Training: Save All Startup Summaries", callback: () => this.save_all_approved_summaries("startup" /* startup */) });
    this.addCommand({ id: "save-vc-summary", name: "Training: Save All VCs Summaries", callback: () => this.save_all_approved_summaries("vc" /* vc */) });
    this.addSettingTab(new SampleSettingTab(this.app, this));
    this.status.setText("\u{1F9D9}: VC Wizard ready");
    this.status.setAttr("title", "Wizard is ready");
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(WIZARD_VIEW);
    this.status.setText("\u{1F9D9}: VC Wizard left");
    this.status.setAttr("title", "Wizard says \u{1F44B}");
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(WIZARD_VIEW);
    await this.app.workspace.getRightLeaf(false).setViewState({
      type: WIZARD_VIEW,
      active: true
    });
    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(WIZARD_VIEW)[0]);
  }
  async updateView(results) {
    var _a;
    const view = (_a = this.app.workspace.getLeavesOfType(WIZARD_VIEW)[0]) == null ? void 0 : _a.view;
    if (view instanceof WizardView) {
      view.update(results);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    scriptPath_AI = this.settings.vaultPath + ".obsidian/plugins/vc_wizard";
    openaiAPIKey = this.settings.openAIKey;
    affinityAPIKey = this.settings.affinityKey;
    owner_value = this.settings.owner_person_value;
    connection_owner_field = this.settings.connection_owner_field_id;
    venture_network_list = this.settings.venture_network_list_id;
    pythonPath = this.settings.pythonPath;
  }
  async saveSettings() {
    await this.saveData(this.settings);
    scriptPath_AI = this.settings.vaultPath + ".obsidian/plugins/vc_wizard";
    openaiAPIKey = this.settings.openAIKey;
    affinityAPIKey = this.settings.affinityKey;
    owner_value = this.settings.owner_person_value;
    connection_owner_field = this.settings.connection_owner_field_id;
    venture_network_list = this.settings.venture_network_list_id;
    pythonPath = this.settings.pythonPath;
  }
  async get_prompt_and_completion(file_content) {
    let [title, substrings] = extract_title_and_note(file_content);
    let startup_name = String(title);
    let note = substrings[1];
    let full_text = "";
    let first_call_notes;
    try {
      full_text = substrings.slice(2);
    } catch (e) {
      console.log(`For ${startup_name}, I could not find the text that lead to the summary`);
      new import_obsidian2.Notice(`For ${startup_name}, I could not find the text that lead to the summary`);
      return [null, null, null];
    }
    try {
      let pattern = /^## .*\n/gm;
      let substrings_2 = full_text[0].split(pattern);
      first_call_notes = substrings_2[1];
      if (first_call_notes.length < 1) {
        throw "Error";
      }
    } catch (e) {
      console.log(`${startup_name}: Does not have ##Notes underneath #StopIndexing`);
      new import_obsidian2.Notice(`${startup_name}, Does not have ##Notes underneath #StopIndexing`);
      return [null, null, null];
    }
    return [first_call_notes, note, title];
  }
  async append_training_data_to_jsonl(training_path, prompt, completion) {
    const training_example = { "prompt": prompt, "completion": completion };
    const json = JSON.stringify(training_example);
    fs.appendFileSync(training_path, json + "\n");
  }
  async mark_file_as_saved(file_content) {
    let index = file_content.indexOf("#gpt_summarized");
    if (index && index != -1) {
      let len = "#gpt_summarized".length;
      let new_string = ", #saved";
      file_content = file_content.substring(0, index + len) + new_string + file_content.substring(index + len);
    }
    return file_content;
  }
  async save_all_approved_summaries(summary_type) {
    const files = this.app.vault.getMarkdownFiles();
    this.status.setText("\u{1F9D9}: VC Wizard saving startup summaries");
    this.status.setAttr("title", "Wizard is saving data to improve");
    let judge_function;
    let training_extension;
    if (summary_type == "startup" /* startup */) {
      judge_function = is_startup_ready_for_training;
      training_extension = "/training_data/startup_summary_training/startup_summary_training.jsonl";
    } else if (summary_type == "vc" /* vc */) {
      judge_function = is_vc_ready_for_training;
      training_extension = "/training_data/vc_summary_training/vc_summary_training.jsonl";
    } else {
      new import_obsidian2.Notice("Error: Wrong type of summary selected");
      throw Error("Wrong type of summary selected");
    }
    for (let item of files) {
      let file_content = await this.app.vault.read(item);
      if (judge_function(file_content)) {
        let [first_call_notes, note, title] = await this.get_prompt_and_completion(file_content);
        if (first_call_notes && note && title) {
          const plugin_path = scriptPath_AI;
          const training_path = plugin_path + training_extension;
          await this.append_training_data_to_jsonl(training_path, first_call_notes, note);
          file_content = await this.mark_file_as_saved(file_content);
          this.app.vault.modify(item, file_content);
          new import_obsidian2.Notice(`${title} has been saved`);
        }
      }
    }
  }
  async summarize_all_vc() {
    const files = this.app.vault.getMarkdownFiles();
    this.status.setText("\u{1F9D9}: VC Wizard summarizing...");
    this.status.setAttr("title", "Wizard is summarizing all your VC connections...");
    for (let item of files) {
      let file_content = await this.app.vault.read(item);
      if (is_summarizable(file_content)) {
        console.log(`We are changing file: ${item.name}`);
        let [new_text, summary, title] = await summarize_vc_text(file_content);
        if (title != "") {
          this.app.vault.modify(item, new_text);
          new import_obsidian2.Notice(`${title} has been summarized`);
        }
      }
    }
    this.status.setText("\u{1F9D9}: VC Wizard ready");
    this.status.setAttr("title", "Wizard is ready");
  }
  async find_similar_ideas(editor, view) {
    const sel = editor.getSelection();
    new import_obsidian2.Notice("Search in progress...");
    let scriptPath = scriptPath_AI;
    const scriptName = "similar_ideas.py";
    var args = [sel, openaiAPIKey, this.settings.vaultPath];
    this.status.setText("\u{1F9D9} \u{1F50E}: VC Wizard searching...");
    this.status.setAttr("title", "Wizard is searching for similar ideas");
    const similar_ideas = await launch_python(pythonPath, scriptPath, scriptName, args);
    let search_results = await this.extract_title_and_path(similar_ideas);
    this.updateView(search_results);
    this.status.setText("\u{1F9D9}: VC Wizard ready");
    this.status.setAttr("title", "Wizard is ready");
  }
  async register_file_change(file, type) {
    let scriptPath = scriptPath_AI;
    const scriptName = "index_vault.py";
    const plugin_path = scriptPath_AI;
    let base_name = file.name.split(".md")[0];
    let file_path = this.settings.vaultPath + file.path;
    let storage_path = plugin_path + "/modified_paths.json";
    if (type == "modified" /* modified */) {
      let value = { "change_type": "modified" /* modified */, "full_path": file_path };
      append_to_json(storage_path, base_name, value);
    } else if (type == "deleted" /* deleted */) {
      new import_obsidian2.Notice(`${base_name} has been deleted`);
      let value = { "change_type": "deleted" /* deleted */, "full_path": file_path };
      append_to_json(storage_path, base_name, value);
    } else if (type == "new" /* new */) {
      new import_obsidian2.Notice(`${base_name} has been created`);
      let value = { "change_type": "new" /* new */, "full_path": file_path };
      append_to_json(storage_path, base_name, value);
    }
  }
  async index_new_and_modified_files() {
    const plugin_path = scriptPath_AI;
    let storage_path = plugin_path + "/modified_paths.json";
    fs.readFile(storage_path, async (err, data) => {
      if (err) {
        throw err;
      }
      let files_to_modify;
      new import_obsidian2.Notice("Will read changed files now..");
      this.status.setText("\u{1F9D9}: VC Wizard indexing...");
      this.status.setAttr("title", "Wizard is indexing your vault...");
      try {
        files_to_modify = JSON.parse(data);
        console.log(files_to_modify);
      } catch (e) {
        new import_obsidian2.Notice("No new notes to index");
        this.status.setText("\u{1F9D9}: VC Wizard ready");
        this.status.setAttr("title", "VC Wizard is ready");
        return;
      }
      if (Object.keys(files_to_modify).length < 1) {
        new import_obsidian2.Notice("No new notes to index");
        this.status.setText("\u{1F9D9}: VC Wizard ready");
        this.status.setAttr("title", "VC Wizard is ready");
        return;
      }
      try {
        await this.index_files(storage_path);
      } catch (e) {
        new import_obsidian2.Notice("There was an error while indexing!");
        this.status.setText("\u{1F9D9}: VC Wizard ready");
        this.status.setAttr("title", "VC Wizard is ready");
        return;
      }
      new import_obsidian2.Notice("Finished indexing!");
      this.status.setText("\u{1F9D9}: VC Wizard ready");
      this.status.setAttr("title", "VC Wizard is ready");
      save_json(storage_path, {});
    });
  }
  async index_vault() {
    let files = this.app.vault.getMarkdownFiles();
    let file_paths = {};
    let vault_path = this.settings.vaultPath;
    const plugin_path = scriptPath_AI;
    new import_obsidian2.Notice("Started indexing the full vault!");
    this.status.setText("\u{1F9D9}: VC Wizard indexing...");
    this.status.setAttr("title", "Wizard is indexing your vault...");
    for (let file of files) {
      if (file.path.includes("Readwise")) {
        file_paths[file.basename] = { "change_type": "new" /* new */, "full_path": vault_path + file.path };
      }
    }
    console.log(`Files length: ${file_paths.length}`);
    const json_path = plugin_path + "/file_paths.json";
    save_json(json_path, file_paths);
    try {
      await this.index_files(json_path);
    } catch (e) {
      new import_obsidian2.Notice("There was an error while indexing!");
      return;
    }
    new import_obsidian2.Notice("Finished indexing!");
    this.status.setText("\u{1F9D9}: VC Wizard ready");
    this.status.setAttr("title", "VC Wizard is ready");
    save_json(json_path, {});
  }
  async index_files(json_path) {
    let scriptPath = scriptPath_AI;
    const scriptName = "index_vault.py";
    const plugin_path = scriptPath_AI;
    var args = [json_path, openaiAPIKey, plugin_path];
    let results = await launch_python(pythonPath, scriptPath, scriptName, args);
    console.log(results);
    this.status.setText("\u{1F9D9}: VC Wizard ready");
    this.status.setAttr("title", "VC Wizard is ready");
    return results;
  }
  async extract_title_and_path(results) {
    var _a;
    let counter = 0;
    let search_results = {};
    let current_filename = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.basename;
    console.log(`current filename: ${current_filename}`);
    for (let result of results) {
      if (counter % 3 == 0 && counter != 0) {
        let sentence = '"' + results.at(counter) + '"';
        let source = results.at(counter + 2);
        source = source == null ? void 0 : source.split(":")[1].trim();
        console.log(`counter: ${counter}, This source: ${source}`);
        if (source == current_filename) {
          counter = counter + 1;
          continue;
        }
        let source_file = await this.get_path_by_name(source);
        console.log(source_file);
        if (source_file != null && source != null) {
          let obsidian_path = "obsidian://advanced-uri?vault=";
          obsidian_path = obsidian_path + this.app.vault.getName() + "&filepath=";
          obsidian_path = obsidian_path + source_file.path;
          console.log(`my source path: ${obsidian_path}`);
          search_results[source] = { "source_path": obsidian_path, "text": sentence };
        }
      }
      counter = counter + 1;
    }
    return search_results;
  }
  async get_path_by_name(source) {
    let all_files = this.app.vault.getMarkdownFiles();
    for (let file of all_files) {
      let filename = file.basename;
      if (filename == source) {
        return file;
      }
    }
    return null;
  }
};
var SampleSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for your butler" });
    new import_obsidian2.Setting(containerEl).setName("Obsidian Vault Path").setDesc("The path to the vault where you wish to use the plugin").addText((text) => text.setPlaceholder("Enter path").setValue(this.plugin.settings.vaultPath).onChange(async (value) => {
      console.log("path: " + value);
      this.plugin.settings.vaultPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API Key").addText((text) => text.setPlaceholder("Enter key").setValue(this.plugin.settings.openAIKey).onChange(async (value) => {
      console.log("Open AI key: " + value);
      this.plugin.settings.openAIKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Affinity: API Key").setDesc("Your Affinity API Key").addText((text) => text.setPlaceholder("Enter key").setValue(this.plugin.settings.affinityKey).onChange(async (value) => {
      console.log("key: " + value);
      this.plugin.settings.affinityKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Affinity: Owner Value").setDesc("Every person has a code on Affinity. Please give in the code for the person that should be added as owner of startups and VCs that gets pushed").addText((text) => text.setPlaceholder("Enter value").setValue(this.plugin.settings.owner_person_value).onChange(async (value) => {
      console.log("Owner value: " + value);
      this.plugin.settings.owner_person_value = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Affinity: Connection Owner Field ID").setDesc("Depending on the list you save fellow VCs in, there is a field that represent the 'connection owner with the fund', enter the field id here").addText((text) => text.setPlaceholder("Enter value").setValue(this.plugin.settings.connection_owner_field_id).onChange(async (value) => {
      console.log("Connection Owner Field ID value: " + value);
      this.plugin.settings.connection_owner_field_id = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Affinity: Venture Network List ID").setDesc("Please enter the list id for the list you save your relationships with VCs in").addText((text) => text.setPlaceholder("Enter value").setValue(this.plugin.settings.venture_network_list_id).onChange(async (value) => {
      console.log("Venture network list id: " + value);
      this.plugin.settings.venture_network_list_id = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Python Virtual Environment Path").setDesc("The path to python virtual environment").addText((text) => text.setPlaceholder("Enter path").setValue(this.plugin.settings.pythonPath).onChange(async (value) => {
      console.log("PythonPath: " + value);
      this.plugin.settings.pythonPath = value;
      await this.plugin.saveSettings();
    }));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL3B5dGhvbi1zaGVsbC9pbmRleC50cyIsICJtYWluLnRzIiwgInZpZXcudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbbnVsbCwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBNYXJrZG93blZpZXcsIE1vZGFsLCBOb3RpY2UsIFBsdWdpbiwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgTWVudSwgTWVudUl0ZW0sIE1hcmtkb3duRmlsZUluZm8sIFRGaWxlLCBUQWJzdHJhY3RGaWxlfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBXaXphcmRWaWV3LCBXSVpBUkRfVklFVyB9IGZyb20gJ3ZpZXcnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuXG5sZXQgcHl0aG9uUGF0aCA9ICcnXG5sZXQgc2NyaXB0UGF0aF9BSSA9ICcnXG5sZXQgYWZmaW5pdHlBUElLZXkgPSAnJ1xubGV0IG9wZW5haUFQSUtleSA9ICcnXG5sZXQgb3duZXJfdmFsdWUgPSAnMTAnXG5sZXQgY29ubmVjdGlvbl9vd25lcl9maWVsZCA9ICcxMCdcbmxldCB2ZW50dXJlX25ldHdvcmtfbGlzdCA9ICc1MDAnXG5cblxuXG5hc3luYyBmdW5jdGlvbiBzdW1tYXJpemVfc2VsZWN0ZWRfc3RhcnR1cF90ZXh0KGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXd8TWFya2Rvd25GaWxlSW5mbywgc3RhdHVzOiBIVE1MRWxlbWVudCl7XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyB0aGUgc2VsZWN0ZWQgdGV4dCBmcm9tIGEgc3RhcnR1cCwgc3VtbWFyaXplcyBpdCwgYW5kIHRoZW4gcHV0cyBpdCBiYWNrIGluIHRoZSBmaWxlXG4gICAgICogVGhlIFwiZnVsbC10ZXh0XCIgZ2V0cyBhcHBlbmVkIGFmdGVyIHRoZSBoZWFkaW5nICcjIFN0b3AgSW5kZXhpbmcnIHN1Y2ggdGhhdCBpdCBpcyBub3QgaW5kZXhlZCBhbnltb3JlIGJ5IHRoZSBlbWJlZGRpbmcgZW5naW5lXG4gICAgICogVGhpcyBhbHNvIGhlbHBzIHRvIGF2b2lkIHB1c2hpbmcgYWxsIG9mIHRoZSBjb252b2x1dGVkIHRleHQgaW50byBBZmZpbml0eSBsYXRlciBvblxuICAgICAqL1xuICAgIGNvbnN0IHNlbCA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKVxuICAgIC8vY29uc29sZS5sb2coYFlvdXIgVGV4dDogJHtzZWx9YClcbiAgICBsZXQgc2NyaXB0UGF0aCA9IHNjcmlwdFBhdGhfQUlcbiAgICBjb25zdCBzY3JpcHROYW1lID0gJ3N0YXJ0dXBfc3VtbWFyaXplcl9oZWxwZXIucHknXG4gICAgdmFyIGFyZ3MgPSBbc2VsLCBvcGVuYWlBUElLZXldXG4gICAgbmV3IE5vdGljZShcIlN1bW1hcml6aW5nLi4uXCIpXG4gICAgc3RhdHVzLnNldFRleHQoJ1x1RDgzRVx1REREOTogVkMgV2l6YXJkIHN1bW1hcml6aW5nLi4uJylcbiAgICBzdGF0dXMuc2V0QXR0cigndGl0bGUnLCAnV2l6YXJkIGlzIHN1bW1hcml6aW5nLi4uJylcbiAgICAvL1dlIGRlY2xhcmUgZ2V0X3NlbGVjdGVkX3RleHQgYXMgYSBmdW5jdGlvbiB0aGF0IFwiV0FJVFNcIiAoYXN5bmMpLCBhbmQgd2Ugd2FpdCBmb3IgdGhlIHJlc3VsdCBoZXJlXG4gICAgY29uc3Qgc3VtbWFyeSA9IGF3YWl0IGxhdW5jaF9weXRob24ocHl0aG9uUGF0aCwgc2NyaXB0UGF0aCwgc2NyaXB0TmFtZSwgYXJncylcblxuICAgIGxldCBuZXdfc3VtbWFyeTogc3RyaW5nID0gU3RyaW5nKHN1bW1hcnkpXG4gICAgLy9DcmVhdGUgbmV3IGxpbmVzIGluIHRoZSBzdW1tYXJ5IChzb21laG93IGl0IGdldHMgbG9zdCBiZXR3ZWVuIFB5dGhvbiBhbmQgSmF2YXNjcmlwdClcbiAgICBuZXdfc3VtbWFyeSA9IG5ld19zdW1tYXJ5LnJlcGxhY2UoLywtL2csICdcXG4tJylcbiAgICBjb25zb2xlLmxvZyhgVGhlIHN0YXJ0dXAgc3VtbWFyeTpcXG4gJHtuZXdfc3VtbWFyeX1gKVxuXG4gICAgY29uc3QgcmVwbGFjZW1lbnQgPSAnI2dwdF9zdW1tYXJpemVkLCAjcmV2aWV3X3N0YXJ0dXAgXFxuJysgbmV3X3N1bW1hcnkgKyAnXFxuJyArICcjIFN0b3AgSW5kZXhpbmcgXFxuIyMgTm90ZXNcXG4nICsgc2VsXG4gICAgZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24ocmVwbGFjZW1lbnQpXG4gICAgc3RhdHVzLnNldFRleHQoJ1x1RDgzRVx1REREOTogVkMgV2l6YXJkIHJlYWR5JylcbiAgICBzdGF0dXMuc2V0QXR0cigndGl0bGUnLCAnV2l6YXJkIGlzIHJlYWR5JylcblxufVxuXG5cblxuYXN5bmMgZnVuY3Rpb24gbGF1bmNoX3B5dGhvbihweXRob25QYXRoOiBzdHJpbmcsIHNjcmlwdFBhdGg6IHN0cmluZywgc2NyaXB0TmFtZTogc3RyaW5nLCBhcmdzOiBhbnkpe1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gbGF1bmNoZXMgYSBweXRob24gc2NyaXB0IHdpdGggdGhlIGNvcnJlY3QgcHl0aG9uIHZpcnR1YWwgZW52aXJvbm1lbnQgYW5kIHJldHVybnMgd2hhdGV2ZXIgdGhlIHB5dGhvbiBzY3JpcHQgcHJpbnRzISEgKG5vIHZhbHVlIHBhc3NpbmcsIHRha2UgY2FyZSlcbiAgICAgKi9cbiAgICBsZXQge1B5dGhvblNoZWxsfSA9IHJlcXVpcmUoJ3B5dGhvbi1zaGVsbCcpXG4gICAgY29uc3Qgb3B0aW9ucyA9IHttb2RlOiAndGV4dCcsIHB5dGhvblBhdGg6IHB5dGhvblBhdGgsIHNjcmlwdFBhdGg6IHNjcmlwdFBhdGgsIGFyZ3M6IGFyZ3N9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgUHl0aG9uU2hlbGwucnVuKHNjcmlwdE5hbWUsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnI6IEVycm9yLCByZXN1bHRzOiBhbnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdFxuXG59XG5cblxuYXN5bmMgZnVuY3Rpb24gc3VtbWFyaXplX3ZjX3RleHQodGV4dDogc3RyaW5nKXtcbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgZnVsbCB0ZXh0IGluIGEgVkMgbm90ZSwgdGhpcyBmdW5jdGlvbiBzdW1tYXJpemVzIHRoZSBpbXBvcnRhbnQgcGFydCAoYmVmb3JlICMgU3RvcCBJbmRleGluZykgYW5kIHJldHVybnMgdGhlIG5ldyBmdWxsIHRleHQgdGhhdCBzaG91bGQgYmUgd3JpdHRlbiB0byB0aGUgZmlsZVxuICAgICAqIFRoZSBmdWxsIHRleHQgaW5jbHVkZXMgdGhlIG1ldGEgZGF0YSBhbmQgdGFncyBpbmZvcm1hdGlvbiBiZWZvcmUgdGhlIHRpdGxlLCB0aGUgdGl0bGUsIHRoZSBzdW1tYXJ5LCBhbmQgYWRkcyB0aGUgY29yZSBkYXRhIGFmdGVyIHRoZSBoZWFkaW5nIFwiIyBTdG9wIEluZGV4aW5nXCJcbiAgICAgKi9cbiAgICBjb25zdCBzY3JpcHRQYXRoID0gc2NyaXB0UGF0aF9BSVxuICAgIGNvbnN0IHNjcmlwdE5hbWUgPSAndmNfc3VtbWFyaXplcl9oZWxwZXIucHknXG5cbiAgICAvLyBXZSBzaG91bGQgc3VtbWFyaXplIG9ubHkgaW5mb3JtYXRpb24gdGhhdCBpcyBiZWZvcmUgJyMgU3RvcCBJbmRleGluZydcbiAgICBsZXQgW3RpdGxlLCBzdWJzdHJpbmdzXSA9IGV4dHJhY3RfdGl0bGVfYW5kX25vdGUodGV4dClcbiAgICAvL1dlIGNvbnNpZGVyIGJvdGggZGF0YSBiZWZvcmUgdGhlIHRpdGxlIChoYXNodGFncykgYXMgd2VsbCBhcyB0aGUgYm9keSBvZiB0aGUgbm90ZVxuICAgIFxuICAgIGxldCBoYXNodGFnc1xuICAgIHRyeXtcbiAgICAgICBoYXNodGFncyA9IHN1YnN0cmluZ3NbMF0uc3BsaXQoJ1RhZ3M6JylbMV1cbiAgICB9XG4gICAgY2F0Y2h7XG4gICAgICAgIGhhc2h0YWdzID0gc3Vic3RyaW5nc1swXVxuICAgICAgICBuZXcgTm90aWNlKGAke3RpdGxlfTogRG9lcyBub3QgaGF2ZSBhbnkgZ3VpZGluZyBoYXNodGFncywgdGhpcyBjb3VsZCBoZWxwIHRoZSBzdW1tYXJpemVyIHVuZGVyc3RhbmQgdGhlIFZDIGJldHRlcmAsIDM2MDApXG4gICAgfVxuICAgIGxldCB0ZXh0X3RvX3N1bW1hcml6ZSA9IGhhc2h0YWdzICsgJ1xcbicgKyBzdWJzdHJpbmdzWzFdXG5cbiAgICBjb25zb2xlLmxvZyhgU3VtbWFyaXppbmc6ICR7dGl0bGV9YClcbiAgICAvL2NvbnNvbGUubG9nKFwiVGV4dCB0byBzdW1tYXJpemU6IFwiKVxuICAgIC8vY29uc29sZS5sb2codGV4dF90b19zdW1tYXJpemUpXG5cbiAgICB2YXIgYXJncyA9IFsnTm90ZXM6XFxuJyArIHRleHRfdG9fc3VtbWFyaXplICsgJ1N1bW1hcnk6XFxuJywgb3BlbmFpQVBJS2V5XSAvL3RleHRcbiAgICAvL1dlIGRlY2xhcmUgZ2V0X3NlbGVjdGVkX3RleHQgYXMgYSBmdW5jdGlvbiB0aGF0IFwiV0FJVFNcIiAoYXN5bmMpLCBhbmQgd2Ugd2FpdCBmb3IgdGhlIHJlc3VsdCBoZXJlXG4gICAgXG4gICAgY29uc3Qgc3VtbWFyeSA9IGF3YWl0IGxhdW5jaF9weXRob24ocHl0aG9uUGF0aCwgc2NyaXB0UGF0aCwgc2NyaXB0TmFtZSwgYXJncylcbiAgICBsZXQgbmV3X3N1bW1hcnk6IHN0cmluZyA9IFN0cmluZyhzdW1tYXJ5KVxuICAgIC8vU2VwYXJhdGUgZGlmZmVyZW50IGJ1bGxldCBwb2ludHNcbiAgICBuZXdfc3VtbWFyeSA9IG5ld19zdW1tYXJ5LnJlcGxhY2UoLywtL2csICdcXG4tJylcblxuICAgIFxuICAgIHRpdGxlID0gdGl0bGUudG9TdHJpbmcoKVxuICAgIGxldCBsZWFkaW5nX3RleHQgPSAnJ1xuICAgIGxldCByZXBsYWNlbWVudCA9ICcnXG4gICAgbGV0IHRhaWxpbmdfdGV4dCA9IGhhc2h0YWdzXG5cbiAgICAvKmNvbnNvbGUubG9nKGBUaXRsZTogJHt0aXRsZX1gKVxuICAgIGNvbnNvbGUubG9nKGBCZWZvcmUgdGhlIHRpdGxlOlxcbiR7c3Vic3RyaW5nc1swXX1gKVxuICAgIGNvbnNvbGUubG9nKGBBZnRlciB0aGUgdGl0bGU6ICR7c3Vic3RyaW5nc1sxXX1gKSovXG5cbiAgICBpZihzdWJzdHJpbmdzKXtcbiAgICAgICAgbGVhZGluZ190ZXh0ID0gc3Vic3RyaW5nc1swXSArICdcXG4nICsgdGl0bGUgKyAnXFxuJ1xuICAgICAgICBmb3IgKGxldCBzdWJzdHJpbmcgb2Ygc3Vic3RyaW5ncy5zbGljZSgxKSl7XG4gICAgICAgICAgICB0YWlsaW5nX3RleHQgPSB0YWlsaW5nX3RleHQgKyAnXFxuJyArIHN1YnN0cmluZ1xuICAgICAgICB9XG4gICAgICAgIHJlcGxhY2VtZW50ID0gbGVhZGluZ190ZXh0ICsgJyNncHRfc3VtbWFyaXplZCwgI3JldmlldyBcXG4nKyBuZXdfc3VtbWFyeSArICdcXG4nICsgJyMgU3RvcCBJbmRleGluZyBcXG4jIyBOb3Rlc1xcbicgKyB0YWlsaW5nX3RleHRcbiAgICAgICAgcmV0dXJuIFtyZXBsYWNlbWVudCwgbmV3X3N1bW1hcnksIHRpdGxlXVxuICAgIH1cbiAgICBlbHNle1xuICAgICAgICByZXR1cm4gW3RleHQsIHRleHQsICcnXVxuXG4gICAgfVxuXG4gICAgXG59XG5cblxuZnVuY3Rpb24gY3JlYXRlX25vdGljZSgpe1xuICAgIG5ldyBOb3RpY2UoXCJOaWNlIHRvIG1lZXQgeW91IVwiKVxufVxuXG5mdW5jdGlvbiBleHRyYWN0X3RpdGxlX2FuZF9ub3RlKHRleHQ6IHN0cmluZyl7XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhbGwgdGhlIHRleHQgaW4gdGhlIGZpbGUgYW5kIHJldHVybnMgdGhlIHRpdGxlIGFuZCB0aGUgYm9keSBvZiB0aGUgbm90ZS5cbiAgICAgKiBUaGUgc3BsaXQgaGFwcGVucyBiYXNlZCBvbiBoMSBoZWFkZXIuIFxuICAgICAqIFRoaXMgbWVhbnMgc3Vic3RyaW5nc1swXSBpcyB1c3VhbGx5IHRoZSBkYXRhIGJlZm9yZSB0aGUgdGl0bGUuXG4gICAgICogc3Vic3RyaW5nc1sxXSBpcyB1c3VhbGx5IHRoZSBib2R5IG9mIHRoZSBub3RlXG4gICAgICogaWYgdGhlcmUgaXMgc3Vic3RyaW5nIFsyXSwgdGhpcyBtZWFucyB0aGVyZSBpcyBhbm90aGVyIGgxIGhlYWRlciAodXN1YWxseSAjIFN0b3AgSW5kZXhpbmcpXG4gICAgICogRG93bnN0cmVhbSB0YXNrcyBvbmx5IGRlYWxzIHdpdGggc3Vic3RyaW5nWzFdIGFzIHRoZSBub3RlOyBpLmUgaW5mb3JtYXRpb24gYWZ0ZXIgdGhlIFN0b3AgSW5kZXhpbmcgYXJlIGV4ZWNsdWRlZFxuICAgICAqL1xuXG4gICAgICAgIC8vP2dtIG1lYW5zIHN0cmluZyBpcyBtdWx0aWxpbmVzLCBhbmQgXiB3b3VsZCBjYXRjaCBiZWdpbm5pbmcgb2YgZXZlcnkgbGluZSBub3QganVzdCBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZyFcbiAgICAgICAgbGV0IHBhdHRlcm4gPSAvXiMgLipcXG4vZ207XG4gICAgICAgIGxldCBtYXRjaGVzID0gdGV4dC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgbGV0IHRpdGxlID0gJydcbiAgICAgICAgaWYobWF0Y2hlcyl7XG4gICAgICAgICAgICB0aXRsZSA9IG1hdGNoZXNbMF1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3Vic3RyaW5ncyA9IHRleHQuc3BsaXQocGF0dGVybilcbiAgICAgICAgY29uc29sZS5sb2coYFRpdGxlOiAke3RpdGxlfWApXG4gICAgICAgIGNvbnNvbGUubG9nKHN1YnN0cmluZ3MpXG5cbiAgICAgICAgcmV0dXJuIFt0aXRsZSwgc3Vic3RyaW5nc11cblxufVxuXG5mdW5jdGlvbiBleHRyYWN0X3N1bW1hcnkoZnVsbF9ub3RlOnN0cmluZyl7XG4gICAgLy9XaGVuIGEgbm90ZSBpcyByZWFkeSAoaGFzIGdwdF9zdW1tYXJpemVkIGFuZCBBZmZpbml0eSB0YWdzKSwgZXh0cmFjdCB0aGUgc3VtbWFyeSBmcm9tIGZ1bGwgdGV4dFxuICAgIGxldCBzdWJzdHJpbmdzID0gZnVsbF9ub3RlLnNwbGl0KCcjIFN0b3AgSW5kZXhpbmcnKVxuICAgIGxldCBzdW1tYXJ5ID0gc3Vic3RyaW5nc1swXVxuICAgIC8vY29uc29sZS5sb2coYFN1bW1hcnk6ICR7c3VtbWFyeX1gKVxuICAgIHJldHVybiBzdW1tYXJ5XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZV9hZmZpbml0eShub3RlOiBzdHJpbmcsIGVudGl0eV9uYW1lOnN0cmluZywgc2NyaXB0TmFtZTogc3RyaW5nKXtcbiAgICBjb25zdCBzY3JpcHRQYXRoID0gc2NyaXB0UGF0aF9BSVxuICAgIGlmIChzY3JpcHROYW1lID09ICdhZmZpbml0eV92Y19oZWxwZXIucHknKXtcbiAgICAgICAgdmFyIGFyZ3MgPSBbZW50aXR5X25hbWUsIG5vdGUsIGFmZmluaXR5QVBJS2V5LCBvd25lcl92YWx1ZSwgY29ubmVjdGlvbl9vd25lcl9maWVsZCwgdmVudHVyZV9uZXR3b3JrX2xpc3RdXG5cbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgdmFyIGFyZ3MgPSBbZW50aXR5X25hbWUsIG5vdGUsIGFmZmluaXR5QVBJS2V5LCBvd25lcl92YWx1ZV1cblxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIlVwZGF0ZSBBZmZpbml0eVwiKVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbGF1bmNoX3B5dGhvbihweXRob25QYXRoLCBzY3JpcHRQYXRoLCBzY3JpcHROYW1lLCBhcmdzKVxuXG4gICAgY29uc29sZS5sb2cocmVzcG9uc2UpXG4gICAgcmV0dXJuIHJlc3BvbnNlXG5cbn1cblxuZnVuY3Rpb24gdmNfcmVhZHlfZm9yX2FmZmluaXR5KGZpbGVfY29udGVudDogc3RyaW5nKXtcbiAgICByZXR1cm4gZmlsZV9jb250ZW50LmluY2x1ZGVzKCcjZ3B0X3N1bW1hcml6ZWQnKSAmJiBmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNBZmZpbml0eScpXG59XG5cbmZ1bmN0aW9uIHN0YXJ0dXBfcmVhZHlfZm9yX2FmZmluaXR5KGZpbGVfY29udGVudDogc3RyaW5nKXtcbiAgICByZXR1cm4gKGZpbGVfY29udGVudC5pbmNsdWRlcygnI3N0YXJ0dXBzL3NjcmVlbmVkJykgJiYgZmlsZV9jb250ZW50LmluY2x1ZGVzKCcjQWZmaW5pdHknKSlcbn1cblxuZnVuY3Rpb24gaXNfc3RhcnR1cF9yZWFkeV9mb3JfdHJhaW5pbmcoZmlsZV9jb250ZW50OiBzdHJpbmcpe1xuICAgIHJldHVybiAoZmlsZV9jb250ZW50LmluY2x1ZGVzKCcjc3RhcnR1cHMvc2NyZWVuZWQnKSAmJiBmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNncHRfc3VtbWFyaXplZCcpICYmICFmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNyZXZpZXdfc3RhcnR1cCcpICYmICFmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNzYXZlZCcpKVxufVxuXG5mdW5jdGlvbiBpc192Y19yZWFkeV9mb3JfdHJhaW5pbmcoZmlsZV9jb250ZW50OiBzdHJpbmcpe1xuICAgIHJldHVybiAoZmlsZV9jb250ZW50LmluY2x1ZGVzKCcjbmV0d29yay9jb25uZWN0ZWQnKSAmJiBmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNncHRfc3VtbWFyaXplZCcpICYmICFmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNyZXZpZXcnKSAmJiAhZmlsZV9jb250ZW50LmluY2x1ZGVzKCcjc2F2ZWQnKSlcbn1cblxuZnVuY3Rpb24gbm90aWZ5X2Zvcl9taXNzaW5nX3Blb3BsZShwZXJzb25fbmFtZTogc3RyaW5nLCByZXNwb25zZTogYW55KXtcbiAgICAvKipcbiAgICAgKiBJZiBhIHBlcnNvbiBpcyBub3QgZm91bmQgaW4gYWZmaW5pdHksIHNlbmQgYSBub3RpZmljYXRpb24gYW5kIHJldHVybiBmYWxzZVxuICAgICAqL1xuICAgIGZvciAobGV0IGl0ZW0gb2YgcmVzcG9uc2Upe1xuICAgICAgICBpZiAoaXRlbS5pbmNsdWRlcygnT29wcycpKXtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFBlcnNvbjogJHtwZXJzb25fbmFtZX0gd2FzIG5vdCBmb3VuZGAsIDM2MDAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuXG4gICAgfSAgIFxuICAgIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBub3RpZnlfZm9yX21pc3Npbmdfc3RhcnR1cHMoc3RhcnR1cF9uYW1lOiBzdHJpbmcsIHJlc3BvbnNlOiBhbnkpe1xuICAgIGZvciAobGV0IGl0ZW0gb2YgcmVzcG9uc2Upe1xuICAgICAgICBpZihpdGVtLmluY2x1ZGVzKCdFcnJvcicpKXtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYFN0YXJ0dXA6ICR7c3RhcnR1cF9uYW1lfSB3YXMgZm91bmQgYnV0IGNvdWxkIG5vdCBiZSB1cGRhdGVkYCwgMzYwMDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0uaW5jbHVkZXMoJ1N0YXJ0dXAnKSl7XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBTdGFydHVwOiAke3N0YXJ0dXBfbmFtZX0gY291bGQgbm90IGJlIGZvdW5kYCwgMzYwMDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxufVxuXG5hc3luYyBmdW5jdGlvbiBwdXNoX3Zjc190b19hZmZpbml0eShzdGF0dXM6IEhUTUxFbGVtZW50KXtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHB1c2hlcyBhbGwgcmVhZHkgVkNzIHRvIGFmZmluaXR5LCBpdCBhbHNvIG5vdGlmaWVzIHVzIGlmIGEgcGVyc29uIGNhbiBub3QgYmUgZm91bmQgb24gYWZmaW5pdHlcbiAgICAgKi9cbiAgICBjb25zdCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKVxuICAgIHN0YXR1cy5zZXRUZXh0KCdcdUQ4M0VcdURERDk6IFZDIFdpemFyZCBzeW5jaW5nIHdpdGggQWZmaW5pdHkuLi4nKVxuICAgIHN0YXR1cy5zZXRBdHRyKCd0aXRsZScsICdXaXphcmQgaXMgcHVzaGluZyBWQ3MgaW5mbyB0byBBZmZpbml0eS4uLicpXG4gICAgZm9yIChsZXQgaXRlbSBvZiBmaWxlcyl7XG4gICAgICAgIGxldCBmaWxlX2NvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGl0ZW0pXG4gICAgICAgIGlmICh2Y19yZWFkeV9mb3JfYWZmaW5pdHkoZmlsZV9jb250ZW50KSl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCBbdGl0bGUsIHN1YnN0cmluZ3NdID0gZXh0cmFjdF90aXRsZV9hbmRfbm90ZShmaWxlX2NvbnRlbnQpXG4gICAgICAgICAgICBsZXQgc3VtbWFyeSA9IHN1YnN0cmluZ3NbMV0gLy9leHRyYWN0X3N1bW1hcnkoc3Vic3RyaW5nc1sxXSlcbiAgICAgICAgICAgIGxldCBwZXJzb25fbmFtZSA9IFN0cmluZyh0aXRsZSlcbiAgICAgICAgICAgIGxldCBzY3JpcHROYW1lID0gJ2FmZmluaXR5X3ZjX2hlbHBlci5weSdcbiAgICAgICAgICAgIGxldCByZXNwb25zZTogYW55ID0gYXdhaXQgdXBkYXRlX2FmZmluaXR5KHN1bW1hcnksIHBlcnNvbl9uYW1lLCBzY3JpcHROYW1lKVxuICAgICAgICAgICAgaWYgKCFub3RpZnlfZm9yX21pc3NpbmdfcGVvcGxlKHBlcnNvbl9uYW1lLCByZXNwb25zZSkpe1xuICAgICAgICAgICAgICAgIC8vaWYgdGhlIHBlcnNvbiB3YXMgdXBkYXRlZCBvbiBhZmZpbml0eSBzdWNjZXNzZnVseSBhbmQgbm90IG1pc3NpbmcgZnJvbSBkYXRhYmFzZSwgcmVtb3ZlICNBZmZpbml0eSBmcm9tIHRleHRcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBWQzogJHtwZXJzb25fbmFtZX0gd2FzIHVwZGF0ZWQgb24gQWZmaW5pdHlgKVxuICAgICAgICAgICAgICAgIGZpbGVfY29udGVudCA9IGZpbGVfY29udGVudC5yZXBsYWNlKC8jQWZmaW5pdHkvZywgJycpXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGl0ZW0sIGZpbGVfY29udGVudClcblxuICAgICAgICAgICAgfVxuICAgICAgICBcblxuICAgICAgICB9XG5cbiAgICB9XG4gICAgc3RhdHVzLnNldFRleHQoJ1x1RDgzRVx1REREOTogVkMgV2l6YXJkIHJlYWR5JylcbiAgICBzdGF0dXMuc2V0QXR0cigndGl0bGUnLCAnV2l6YXJkIGlzIHJlYWR5JylcblxufVxuXG5cbmFzeW5jIGZ1bmN0aW9uIHB1c2hfc3RhcnR1cHNfdG9fYWZmaW5pdHkoc3RhdHVzOiBIVE1MRWxlbWVudCl7XG4gICAgLyoqXG4gICAgICogUHVzaCBhbGwgZWxpZ2libGUgc3RhcnR1cHMgdG8gYWZmaW5pdHkgKG5vdGlmeSBtZSBvdGhlcndpc2UpXG4gICAgICovXG4gICAgY29uc3QgZmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKClcbiAgICBzdGF0dXMuc2V0VGV4dCgnXHVEODNFXHVEREQ5OiBWQyBXaXphcmQgc3luY2luZyB3aXRoIEFmZmluaXR5Li4uJylcbiAgICBzdGF0dXMuc2V0QXR0cigndGl0bGUnLCAnV2l6YXJkIGlzIHB1c2hpbmcgc3RhcnR1cCBpbmZvIHRvIEFmZmluaXR5Li4uJylcbiAgICBmb3IgKGxldCBpdGVtIG9mIGZpbGVzKXtcbiAgICAgICAgbGV0IGZpbGVfY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoaXRlbSlcbiAgICAgICAgaWYgKHN0YXJ0dXBfcmVhZHlfZm9yX2FmZmluaXR5KGZpbGVfY29udGVudCkpe1xuICAgICAgICAgICAgbGV0IFt0aXRsZSwgc3Vic3RyaW5nc10gPSBleHRyYWN0X3RpdGxlX2FuZF9ub3RlKGZpbGVfY29udGVudClcbiAgICAgICAgICAgIGxldCBzdGFydHVwX25hbWUgPSBTdHJpbmcodGl0bGUpXG4gICAgICAgICAgICBsZXQgbm90ZSA9IHN1YnN0cmluZ3NbMV1cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYFN0YXJ0dXAgbmFtZTogJHtzdGFydHVwX25hbWV9YClcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYE5vdGU6ICR7bm90ZX1gKVxuICAgICAgICAgICAgbGV0IHNjcmlwdE5hbWUgPSAnYWZmaW5pdHlfc3RhcnR1cF9oZWxwZXIucHknXG4gICAgICAgICAgICBsZXQgcmVzcG9uc2U6IGFueSA9IGF3YWl0IHVwZGF0ZV9hZmZpbml0eShub3RlLCBzdGFydHVwX25hbWUsIHNjcmlwdE5hbWUpXG5cbiAgICAgICAgICAgIGlmICghbm90aWZ5X2Zvcl9taXNzaW5nX3N0YXJ0dXBzKHN0YXJ0dXBfbmFtZSwgcmVzcG9uc2UpKXtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBTdGFydHVwOiAke3N0YXJ0dXBfbmFtZX0gd2FzIHVwZGF0ZWQgb24gQWZmaW5pdHlgKVxuICAgICAgICAgICAgICAgIGZpbGVfY29udGVudCA9IGZpbGVfY29udGVudC5yZXBsYWNlKC8jQWZmaW5pdHkvZywgJycpXG4gICAgICAgICAgICAgICAgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGl0ZW0sIGZpbGVfY29udGVudClcbiAgICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgfVxuXG4gICAgfVxuICAgIG5ldyBOb3RpY2UoJ0RvbmUhJylcbiAgICBzdGF0dXMuc2V0VGV4dCgnXHVEODNFXHVEREQ5OiBWQyBXaXphcmQgcmVhZHknKVxuICAgIHN0YXR1cy5zZXRBdHRyKCd0aXRsZScsICdXaXphcmQgaXMgcmVhZHknKVxufVxuXG5mdW5jdGlvbiBpc19zdW1tYXJpemFibGUoZmlsZV9jb250ZW50OiBzdHJpbmcpe1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBWQyBpcyB0byBiZSBzdW1tYXJpemVkIChJIGFtIGNvbm5lY3RlZCB3aXRoIHRoZW0gYW5kIHRoZXkgYXJlIG5vdCBhbHJlYWR5IHN1bW1hcml6ZWQpXG4gICAgICovXG4gICAgcmV0dXJuIGZpbGVfY29udGVudC5pbmNsdWRlcygnI25ldHdvcmsvY29ubmVjdGVkJykgJiYgKCBmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNFbnRpdHkvVkMnKSB8fCBmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNQZXJzb24vVkMnKSApICYmIChmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJyNncHRfc3VtbWFyaXplZCcpICE9IHRydWUpICYmIChmaWxlX2NvbnRlbnQuaW5jbHVkZXMoJ2RhdGF2aWV3JykgIT0gdHJ1ZSlcblxufVxuXG5mdW5jdGlvbiBzYXZlX2pzb24oZmlsZV9wYXRoOiBzdHJpbmcsIGNvbnRlbnQ6IGFueSl7XG4gICAgY29uc3QganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpXG4gICAgZnMud3JpdGVGaWxlKGZpbGVfcGF0aCwganNvblN0cmluZywgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2F2aW5nIHRoZSBmaWxlOiAke2Vycn1gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ0ZpbGUgaGFzIGJlZW4gY3JlYXRlZCcpO1xuICAgICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZF90b19qc29uKGZpbGVfcGF0aDogc3RyaW5nLCBrZXk6IGFueSwgdmFsdWU6YW55KXtcbiAgICBmcy5yZWFkRmlsZShmaWxlX3BhdGgsIChlcnIsIGRhdGE6IGFueSkgPT4ge1xuICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9sZERhdGEgXG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgb2xkRGF0YSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSl7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGZpbGUgaXMgZW1wdHksIGRhdGEgd2lsbCBiZSBhbiBlbXB0eSBzdHJpbmcsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2lsbCBjYXVzZSBKU09OLnBhcnNlKCkgdG8gdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBzZXQgb2xkRGF0YSB0byBhbiBlbXB0eSBvYmplY3QuXG4gICAgICAgICAgICAgICAgb2xkRGF0YSA9IHt9XG4gICAgICAgIH1cbiAgICAgICAgb2xkRGF0YVtrZXldID0gdmFsdWUgLy97J2NoYW5nZV90eXBlJzogRmlsZVR5cGUubW9kaWZpZWQsICdmdWxsX3BhdGgnOiBmaWxlX3BhdGh9IFxuICAgICAgICBjb25zdCB1cGRhdGVkSnNvbiA9IEpTT04uc3RyaW5naWZ5KG9sZERhdGEpXG4gICAgICAgIGZzLndyaXRlRmlsZShmaWxlX3BhdGgsIHVwZGF0ZWRKc29uLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB0aHJvdyBlcnI7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRGF0YSBhcHBlbmRlZCB0byBmaWxlJylcbiAgICAgICAgfSlcblxuXG4gICAgfSk7XG5cbn1cblxuaW50ZXJmYWNlIEJ1dGxlclNldHRpbmdzIHtcblx0dmF1bHRQYXRoOiBzdHJpbmc7XG4gICAgYWZmaW5pdHlLZXk6IHN0cmluZztcbiAgICBvcGVuQUlLZXk6IHN0cmluZztcbiAgICBvd25lcl9wZXJzb25fdmFsdWU6IHN0cmluZztcbiAgICBjb25uZWN0aW9uX293bmVyX2ZpZWxkX2lkOiBzdHJpbmc7XG4gICAgdmVudHVyZV9uZXR3b3JrX2xpc3RfaWQ6IHN0cmluZztcbiAgICBweXRob25QYXRoOiBzdHJpbmdcblxufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBCdXRsZXJTZXR0aW5ncyA9IHtcblx0dmF1bHRQYXRoOiAnZGVmYXVsdCcsXG4gICAgYWZmaW5pdHlLZXk6ICdkZWZhdWx0JyxcbiAgICBvcGVuQUlLZXk6ICdkZWZhdWx0JyxcbiAgICBvd25lcl9wZXJzb25fdmFsdWU6ICcxMCcsXG4gICAgY29ubmVjdGlvbl9vd25lcl9maWVsZF9pZDogJzEwMCcsXG4gICAgdmVudHVyZV9uZXR3b3JrX2xpc3RfaWQ6ICc1MDAnLFxuICAgIHB5dGhvblBhdGg6ICc8cGF0aC10by12aXJ0dWFsLWVudj4nXG5cbn1cblxuZW51bSBGaWxlVHlwZSB7XG4gICAgbW9kaWZpZWQgPSAnbW9kaWZpZWQnLFxuICAgIGRlbGV0ZWQgPSAnZGVsZXRlZCcsXG4gICAgbmV3ID0gJ25ldydcbn1cblxuZW51bSBTdW1tYXJ5VHlwZXtcbiAgICB2YyA9ICd2YycsXG4gICAgc3RhcnR1cCA9ICdzdGFydHVwJ1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZDV2l6YXJkUGx1Z2luIGV4dGVuZHMgUGx1Z2lue1xuICAgIHNldHRpbmdzOiBCdXRsZXJTZXR0aW5ncztcbiAgICBzdGF0dXM6IEhUTUxFbGVtZW50O1xuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB0aGlzLmFkZFN0YXR1c0Jhckl0ZW0oKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMucmVnaXN0ZXJWaWV3KFdJWkFSRF9WSUVXLCAobGVhZik9PiBuZXcgV2l6YXJkVmlldyhsZWFmKSlcbiAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT4ge1xuXHRcdFx0dGhpcy5hY3RpdmF0ZVZpZXcoKTtcblx0XHRcdHRoaXMudXBkYXRlVmlldyhbXSk7XG5cdFx0fSk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KHRoaXMuYXBwLnZhdWx0Lm9uKCdtb2RpZnknLCAoZmlsZSkgPT4gdGhpcy5yZWdpc3Rlcl9maWxlX2NoYW5nZShmaWxlLCBGaWxlVHlwZS5tb2RpZmllZCkpKVxuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudCh0aGlzLmFwcC52YXVsdC5vbignZGVsZXRlJywgKGZpbGUpID0+IHRoaXMucmVnaXN0ZXJfZmlsZV9jaGFuZ2UoZmlsZSwgRmlsZVR5cGUuZGVsZXRlZCkpKVxuICAgICAgICB0aGlzLmFkZFJpYmJvbkljb24oJ3N1bicsICdPbWFyIFBsdWdpbicsIGNyZWF0ZV9ub3RpY2UpXG4gICAgICAgICAgICBcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtpZDogJ3N1bW1hcml6ZS1zdGFydHVwLWNvbW1hbmQnLCBuYW1lOiAnU3VtbWFyaXplIFRoaXMgU3RhcnR1cCcsIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yLCB2aWV3KSA9PiBzdW1tYXJpemVfc2VsZWN0ZWRfc3RhcnR1cF90ZXh0KGVkaXRvciwgdmlldywgdGhpcy5zdGF0dXMpfSlcbiAgICAgICAgXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7aWQ6ICdpbmRleC12YXVsdCcsIG5hbWU6ICdJbmRleCBWYXVsdCcsIGNhbGxiYWNrOiAoKSA9PiB0aGlzLmluZGV4X3ZhdWx0KCl9KVxuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7aWQ6ICdpbmRleC1jaGFuZ2VkLWZpbGVzJywgbmFtZTogJ1JlaW5kZXggTmV3L0NoYW5nZWQgRmlsZXMgT25seScsIGNhbGxiYWNrOiAoKSA9PiB0aGlzLmluZGV4X25ld19hbmRfbW9kaWZpZWRfZmlsZXMoKX0pXG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtpZDogJ2ZpbmQtc2ltaWxhci1pZGVhcycsIG5hbWU6ICdGaW5kIFNpbWlsYXIgSWRlYXMnLCBlZGl0b3JDYWxsYmFjazogKGVkaXRvciwgdmlldykgPT4gdGhpcy5maW5kX3NpbWlsYXJfaWRlYXMoZWRpdG9yLCB2aWV3KX0pXG4gICAgXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7aWQ6ICdzdW1tYXJpemUtYWxsLXZjLWNvbW1hbmQnLCBuYW1lOiAnU3VtbWFyaXplIEFsbCBWQyBOb3RlcycsIGNhbGxiYWNrOiAoKSA9PiB0aGlzLnN1bW1hcml6ZV9hbGxfdmMoKX0pXG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtpZDogJ2FmZmluaXR5LXZjJywgbmFtZTogJ1B1c2ggVkNzIHRvIEFmZmluaXR5JywgY2FsbGJhY2s6ICgpID0+IHB1c2hfdmNzX3RvX2FmZmluaXR5KHRoaXMuc3RhdHVzKX0pXG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtpZDogJ2FmZmluaXR5LXN0YXJ0dXAnLCBuYW1lOiAnUHVzaCBTdGFydHVwcyB0byBBZmZpbml0eScsIGNhbGxiYWNrOiAoKSA9PiBwdXNoX3N0YXJ0dXBzX3RvX2FmZmluaXR5KHRoaXMuc3RhdHVzKX0pXG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtpZDogJ3NhdmUtc3RhcnR1cC1zdW1tYXJ5JywgbmFtZTogJ1RyYWluaW5nOiBTYXZlIEFsbCBTdGFydHVwIFN1bW1hcmllcycsIGNhbGxiYWNrOiAoKSA9PiB0aGlzLnNhdmVfYWxsX2FwcHJvdmVkX3N1bW1hcmllcyhTdW1tYXJ5VHlwZS5zdGFydHVwKX0pXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7aWQ6ICdzYXZlLXZjLXN1bW1hcnknLCBuYW1lOiAnVHJhaW5pbmc6IFNhdmUgQWxsIFZDcyBTdW1tYXJpZXMnLCBjYWxsYmFjazogKCkgPT4gdGhpcy5zYXZlX2FsbF9hcHByb3ZlZF9zdW1tYXJpZXMoU3VtbWFyeVR5cGUudmMpfSlcblxuICAgICAgICB0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNhbXBsZVNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0VGV4dCgnXHVEODNFXHVEREQ5OiBWQyBXaXphcmQgcmVhZHknKVxuICAgICAgICB0aGlzLnN0YXR1cy5zZXRBdHRyKCd0aXRsZScsICdXaXphcmQgaXMgcmVhZHknKVxuXG4gICAgXG4gICAgfVxuXG4gICAgb251bmxvYWQoKSB7XG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5kZXRhY2hMZWF2ZXNPZlR5cGUoV0laQVJEX1ZJRVcpXG4gICAgICAgIHRoaXMuc3RhdHVzLnNldFRleHQoJ1x1RDgzRVx1REREOTogVkMgV2l6YXJkIGxlZnQnKVxuICAgICAgICB0aGlzLnN0YXR1cy5zZXRBdHRyKCd0aXRsZScsICdXaXphcmQgc2F5cyBcdUQ4M0RcdURDNEInKVxuXG4gICAgfVxuXG4gICAgYXN5bmMgYWN0aXZhdGVWaWV3KCkge1xuXHRcdHRoaXMuYXBwLndvcmtzcGFjZS5kZXRhY2hMZWF2ZXNPZlR5cGUoV0laQVJEX1ZJRVcpO1xuXHRcdFxuXHRcdGF3YWl0IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRSaWdodExlYWYoZmFsc2UpLnNldFZpZXdTdGF0ZSh7XG5cdFx0ICB0eXBlOiBXSVpBUkRfVklFVyxcblx0XHQgIGFjdGl2ZTogdHJ1ZSxcblx0XHR9KTtcblx0XG5cdFx0dGhpcy5hcHAud29ya3NwYWNlLnJldmVhbExlYWYoXG5cdFx0ICB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKFdJWkFSRF9WSUVXKVswXVxuXHRcdCk7XG5cdH1cbiAgICBhc3luYyB1cGRhdGVWaWV3KHJlc3VsdHM6IGFueSkge1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZShXSVpBUkRfVklFVylbMF0/LnZpZXc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3IGluc3RhbmNlb2YgV2l6YXJkVmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy51cGRhdGUocmVzdWx0cylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkU2V0dGluZ3MoKXtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XG4gICAgICAgIHNjcmlwdFBhdGhfQUkgPSB0aGlzLnNldHRpbmdzLnZhdWx0UGF0aCArICcub2JzaWRpYW4vcGx1Z2lucy92Y193aXphcmQnXG4gICAgICAgIG9wZW5haUFQSUtleSA9IHRoaXMuc2V0dGluZ3Mub3BlbkFJS2V5XG4gICAgICAgIGFmZmluaXR5QVBJS2V5ID0gdGhpcy5zZXR0aW5ncy5hZmZpbml0eUtleVxuICAgICAgICBvd25lcl92YWx1ZSA9IHRoaXMuc2V0dGluZ3Mub3duZXJfcGVyc29uX3ZhbHVlXG4gICAgICAgIGNvbm5lY3Rpb25fb3duZXJfZmllbGQgPSB0aGlzLnNldHRpbmdzLmNvbm5lY3Rpb25fb3duZXJfZmllbGRfaWRcbiAgICAgICAgdmVudHVyZV9uZXR3b3JrX2xpc3QgPSB0aGlzLnNldHRpbmdzLnZlbnR1cmVfbmV0d29ya19saXN0X2lkXG4gICAgICAgIHB5dGhvblBhdGggPSB0aGlzLnNldHRpbmdzLnB5dGhvblBhdGhcbiAgICB9XG5cbiAgICBhc3luYyBzYXZlU2V0dGluZ3MoKXtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKVxuICAgICAgICBzY3JpcHRQYXRoX0FJID0gdGhpcy5zZXR0aW5ncy52YXVsdFBhdGggKyAnLm9ic2lkaWFuL3BsdWdpbnMvdmNfd2l6YXJkJ1xuICAgICAgICBvcGVuYWlBUElLZXkgPSB0aGlzLnNldHRpbmdzLm9wZW5BSUtleVxuICAgICAgICBhZmZpbml0eUFQSUtleSA9IHRoaXMuc2V0dGluZ3MuYWZmaW5pdHlLZXlcbiAgICAgICAgb3duZXJfdmFsdWUgPSB0aGlzLnNldHRpbmdzLm93bmVyX3BlcnNvbl92YWx1ZVxuICAgICAgICBjb25uZWN0aW9uX293bmVyX2ZpZWxkID0gdGhpcy5zZXR0aW5ncy5jb25uZWN0aW9uX293bmVyX2ZpZWxkX2lkXG4gICAgICAgIHZlbnR1cmVfbmV0d29ya19saXN0ID0gdGhpcy5zZXR0aW5ncy52ZW50dXJlX25ldHdvcmtfbGlzdF9pZFxuICAgICAgICBweXRob25QYXRoID0gdGhpcy5zZXR0aW5ncy5weXRob25QYXRoXG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0X3Byb21wdF9hbmRfY29tcGxldGlvbihmaWxlX2NvbnRlbnQ6IGFueSl7XG4gICAgICAgIGxldCBbdGl0bGUsIHN1YnN0cmluZ3NdID0gZXh0cmFjdF90aXRsZV9hbmRfbm90ZShmaWxlX2NvbnRlbnQpXG4gICAgICAgIGxldCBzdGFydHVwX25hbWUgPSBTdHJpbmcodGl0bGUpXG4gICAgICAgIGxldCBub3RlID0gc3Vic3RyaW5nc1sxXVxuICAgICAgICBsZXQgZnVsbF90ZXh0OiBhbnkgPSAnJ1xuICAgICAgICBsZXQgZmlyc3RfY2FsbF9ub3RlczogYW55XG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgIGZ1bGxfdGV4dCA9IHN1YnN0cmluZ3Muc2xpY2UoMilcblxuICAgICAgICB9XG4gICAgICAgIGNhdGNoe1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEZvciAke3N0YXJ0dXBfbmFtZX0sIEkgY291bGQgbm90IGZpbmQgdGhlIHRleHQgdGhhdCBsZWFkIHRvIHRoZSBzdW1tYXJ5YClcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYEZvciAke3N0YXJ0dXBfbmFtZX0sIEkgY291bGQgbm90IGZpbmQgdGhlIHRleHQgdGhhdCBsZWFkIHRvIHRoZSBzdW1tYXJ5YClcbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbCwgbnVsbF1cbiAgICAgICAgfVxuICAgICAgICB0cnl7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdGdWxsIHRleHQ6XFxuJylcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZnVsbF90ZXh0KVxuICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSAvXiMjIC4qXFxuL2dtO1xuICAgICAgICAgICAgbGV0IHN1YnN0cmluZ3NfMiA9IGZ1bGxfdGV4dFswXS5zcGxpdChwYXR0ZXJuKVxuICAgICAgICAgICAgZmlyc3RfY2FsbF9ub3RlcyA9IHN1YnN0cmluZ3NfMlsxXVxuICAgICAgICAgICAgaWYgKGZpcnN0X2NhbGxfbm90ZXMubGVuZ3RoIDwgMSl7XG4gICAgICAgICAgICAgICAgLy9JZiB0aGVyZSBhcmUgbm8gbm90ZXMgdGhhdCBnb3QgY2F1Z2h0XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJFcnJvclwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2h7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtzdGFydHVwX25hbWV9OiBEb2VzIG5vdCBoYXZlICMjTm90ZXMgdW5kZXJuZWF0aCAjU3RvcEluZGV4aW5nYClcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYCR7c3RhcnR1cF9uYW1lfSwgRG9lcyBub3QgaGF2ZSAjI05vdGVzIHVuZGVybmVhdGggI1N0b3BJbmRleGluZ2ApXG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGwsIG51bGxdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtmaXJzdF9jYWxsX25vdGVzLCBub3RlLCB0aXRsZV1cblxuICAgIH1cblxuICAgIGFzeW5jIGFwcGVuZF90cmFpbmluZ19kYXRhX3RvX2pzb25sKHRyYWluaW5nX3BhdGg6IHN0cmluZywgcHJvbXB0OiBzdHJpbmcsIGNvbXBsZXRpb246IHN0cmluZyl7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmRzIGEgZGljdGlvbmFyeSB0eXBlIGZpbGUgXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB0cmFpbmluZ19leGFtcGxlID0geydwcm9tcHQnOiBwcm9tcHQsICdjb21wbGV0aW9uJzogY29tcGxldGlvbn0gXG4gICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeSh0cmFpbmluZ19leGFtcGxlKVxuICAgICAgICBmcy5hcHBlbmRGaWxlU3luYyh0cmFpbmluZ19wYXRoLCBqc29uICsgJ1xcbicpXG5cbiAgICB9XG5cbiAgICBhc3luYyBtYXJrX2ZpbGVfYXNfc2F2ZWQoZmlsZV9jb250ZW50OiBhbnkpe1xuICAgICAgICBsZXQgaW5kZXggPSBmaWxlX2NvbnRlbnQuaW5kZXhPZignI2dwdF9zdW1tYXJpemVkJylcbiAgICAgICAgaWYgKGluZGV4ICYmIGluZGV4IT0tMSl7XG4gICAgICAgICAgICBsZXQgbGVuID0gJyNncHRfc3VtbWFyaXplZCcubGVuZ3RoXG4gICAgICAgICAgICBsZXQgbmV3X3N0cmluZyA9ICcsICNzYXZlZCdcbiAgICAgICAgICAgIGZpbGVfY29udGVudCA9IGZpbGVfY29udGVudC5zdWJzdHJpbmcoMCwgaW5kZXgrbGVuKSArIG5ld19zdHJpbmcgKyBmaWxlX2NvbnRlbnQuc3Vic3RyaW5nKGluZGV4K2xlbilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZV9jb250ZW50XG5cblxuICAgIH1cblxuXG4gICAgYXN5bmMgc2F2ZV9hbGxfYXBwcm92ZWRfc3VtbWFyaWVzKHN1bW1hcnlfdHlwZTogU3VtbWFyeVR5cGUpe1xuICAgICAgICBjb25zdCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKVxuICAgICAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KCdcdUQ4M0VcdURERDk6IFZDIFdpemFyZCBzYXZpbmcgc3RhcnR1cCBzdW1tYXJpZXMnKVxuICAgICAgICB0aGlzLnN0YXR1cy5zZXRBdHRyKCd0aXRsZScsICdXaXphcmQgaXMgc2F2aW5nIGRhdGEgdG8gaW1wcm92ZScpXG4gICAgICAgIGxldCBqdWRnZV9mdW5jdGlvblxuICAgICAgICBsZXQgdHJhaW5pbmdfZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdW1tYXJ5X3R5cGUgPT0gU3VtbWFyeVR5cGUuc3RhcnR1cClcbiAgICAgICAge1xuICAgICAgICAgICAganVkZ2VfZnVuY3Rpb24gPSBpc19zdGFydHVwX3JlYWR5X2Zvcl90cmFpbmluZ1xuICAgICAgICAgICAgdHJhaW5pbmdfZXh0ZW5zaW9uID0gJy90cmFpbmluZ19kYXRhL3N0YXJ0dXBfc3VtbWFyeV90cmFpbmluZy9zdGFydHVwX3N1bW1hcnlfdHJhaW5pbmcuanNvbmwnXG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdW1tYXJ5X3R5cGUgPT0gU3VtbWFyeVR5cGUudmMpe1xuICAgICAgICAgICAganVkZ2VfZnVuY3Rpb24gPSBpc192Y19yZWFkeV9mb3JfdHJhaW5pbmdcbiAgICAgICAgICAgIHRyYWluaW5nX2V4dGVuc2lvbiA9ICcvdHJhaW5pbmdfZGF0YS92Y19zdW1tYXJ5X3RyYWluaW5nL3ZjX3N1bW1hcnlfdHJhaW5pbmcuanNvbmwnXG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJFcnJvcjogV3JvbmcgdHlwZSBvZiBzdW1tYXJ5IHNlbGVjdGVkXCIpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIldyb25nIHR5cGUgb2Ygc3VtbWFyeSBzZWxlY3RlZFwiKSAgICAgXG4gICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGZpbGVzKXtcbiAgICAgICAgICAgIGxldCBmaWxlX2NvbnRlbnQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGl0ZW0pXG4gICAgICAgICAgICBpZiAoanVkZ2VfZnVuY3Rpb24oZmlsZV9jb250ZW50KSl7XG5cbiAgICAgICAgICAgICAgICBsZXQgW2ZpcnN0X2NhbGxfbm90ZXMsIG5vdGUsIHRpdGxlXSA9IGF3YWl0IHRoaXMuZ2V0X3Byb21wdF9hbmRfY29tcGxldGlvbihmaWxlX2NvbnRlbnQpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0X2NhbGxfbm90ZXMgJiYgbm90ZSAmJiB0aXRsZSl7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbHVnaW5fcGF0aCA9IHNjcmlwdFBhdGhfQUlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhaW5pbmdfcGF0aCA9IHBsdWdpbl9wYXRoICsgdHJhaW5pbmdfZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwZW5kX3RyYWluaW5nX2RhdGFfdG9fanNvbmwodHJhaW5pbmdfcGF0aCwgZmlyc3RfY2FsbF9ub3Rlcywgbm90ZSlcbiAgICAgICAgICAgICAgICAgICAgZmlsZV9jb250ZW50ID0gYXdhaXQgdGhpcy5tYXJrX2ZpbGVfYXNfc2F2ZWQoZmlsZV9jb250ZW50KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC52YXVsdC5tb2RpZnkoaXRlbSwgZmlsZV9jb250ZW50KVxuICAgICAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGAke3RpdGxlfSBoYXMgYmVlbiBzYXZlZGApXG4gICAgXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHN1bW1hcml6ZV9hbGxfdmMoKXtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gc3VtbWFyaXplZCBhbGwgVkMgbm90ZXMgdGhhdCBhcmUgZWxpZ2libGUgZm9yIHN1bW1hcml6YXRpb24gKHBlb3BsZSBvciBlbnRpdGllcyBJIGFtIGNvbm5lY3RlZCB3aXRoKVxuICAgICAgICAgKi9cblxuICAgICAgICBjb25zdCBmaWxlcyA9IHRoaXMuYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKVxuICAgICAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KCdcdUQ4M0VcdURERDk6IFZDIFdpemFyZCBzdW1tYXJpemluZy4uLicpXG4gICAgICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoJ3RpdGxlJywgJ1dpemFyZCBpcyBzdW1tYXJpemluZyBhbGwgeW91ciBWQyBjb25uZWN0aW9ucy4uLicpXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgZmlsZXMpe1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhpdGVtLm5hbWUpXG4gICAgICAgICAgICBsZXQgZmlsZV9jb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChpdGVtKVxuICAgICAgICAgICAgaWYgKGlzX3N1bW1hcml6YWJsZShmaWxlX2NvbnRlbnQpKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgV2UgYXJlIGNoYW5naW5nIGZpbGU6ICR7aXRlbS5uYW1lfWApXG4gICAgICAgICAgICAgICAgLy9XZSBzaG91bGQgc3VtbWFyaXplIHRoaXMgZmlsZSB0aGVuXG4gICAgICAgICAgICAgICAgbGV0IFtuZXdfdGV4dCwgc3VtbWFyeSwgdGl0bGVdID0gYXdhaXQgc3VtbWFyaXplX3ZjX3RleHQoZmlsZV9jb250ZW50KVxuICAgICAgICAgICAgICAgIGlmICh0aXRsZSAhPSAnJyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShpdGVtLCBuZXdfdGV4dClcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShgJHt0aXRsZX0gaGFzIGJlZW4gc3VtbWFyaXplZGApXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG5cbiAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KCdcdUQ4M0VcdURERDk6IFZDIFdpemFyZCByZWFkeScpXG4gICAgICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoJ3RpdGxlJywgJ1dpemFyZCBpcyByZWFkeScpXG4gICAgICAgIFxuXG4gICAgICAgIC8vdmF1bHQuXG5cbiAgICAgICAgXG5cbiAgICB9XG4gICAgYXN5bmMgZmluZF9zaW1pbGFyX2lkZWFzKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXd8TWFya2Rvd25GaWxlSW5mbyl7XG4gICAgICAgIGNvbnN0IHNlbCA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKVxuICAgICAgICBuZXcgTm90aWNlKFwiU2VhcmNoIGluIHByb2dyZXNzLi4uXCIpXG4gICAgICAgIGxldCBzY3JpcHRQYXRoID0gc2NyaXB0UGF0aF9BSVxuICAgICAgICBjb25zdCBzY3JpcHROYW1lID0gJ3NpbWlsYXJfaWRlYXMucHknXG4gICAgICAgIHZhciBhcmdzID0gW3NlbCwgb3BlbmFpQVBJS2V5LCB0aGlzLnNldHRpbmdzLnZhdWx0UGF0aF1cbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0VGV4dCgnXHVEODNFXHVEREQ5IFx1RDgzRFx1REQwRTogVkMgV2l6YXJkIHNlYXJjaGluZy4uLicpXG4gICAgICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoJ3RpdGxlJywgJ1dpemFyZCBpcyBzZWFyY2hpbmcgZm9yIHNpbWlsYXIgaWRlYXMnKVxuICAgICAgICBjb25zdCBzaW1pbGFyX2lkZWFzID0gYXdhaXQgbGF1bmNoX3B5dGhvbihweXRob25QYXRoLCBzY3JpcHRQYXRoLCBzY3JpcHROYW1lLCBhcmdzKSBhcyBzdHJpbmcgW10gICAgICAgIFxuICAgICAgICAvL2NvbnNvbGUubG9nKHNpbWlsYXJfaWRlYXMpXG4gICAgICAgIGxldCBzZWFyY2hfcmVzdWx0cyA9IGF3YWl0IHRoaXMuZXh0cmFjdF90aXRsZV9hbmRfcGF0aChzaW1pbGFyX2lkZWFzKVxuICAgICAgICAvL2NvbnNvbGUubG9nKCdTZWFyY2ggcmVzdWx0czpcXG4nKVxuICAgICAgICAvL2NvbnNvbGUubG9nKHNlYXJjaF9yZXN1bHRzKVxuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoc2VhcmNoX3Jlc3VsdHMpXG4gICAgICAgIHRoaXMuc3RhdHVzLnNldFRleHQoJ1x1RDgzRVx1REREOTogVkMgV2l6YXJkIHJlYWR5JylcbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cigndGl0bGUnLCAnV2l6YXJkIGlzIHJlYWR5JylcbiAgICBcbiAgICBcbiAgICB9XG5cbiAgICBhc3luYyByZWdpc3Rlcl9maWxlX2NoYW5nZShmaWxlOiBUQWJzdHJhY3RGaWxlLCB0eXBlOkZpbGVUeXBlKXtcbiAgICAgICAgbGV0IHNjcmlwdFBhdGggPSBzY3JpcHRQYXRoX0FJXG4gICAgICAgIGNvbnN0IHNjcmlwdE5hbWUgPSAnaW5kZXhfdmF1bHQucHknXG4gICAgICAgIGNvbnN0IHBsdWdpbl9wYXRoID0gc2NyaXB0UGF0aF9BSVxuICAgICAgICBsZXQgYmFzZV9uYW1lID0gZmlsZS5uYW1lLnNwbGl0KCcubWQnKVswXVxuICAgICAgICBsZXQgZmlsZV9wYXRoID0gdGhpcy5zZXR0aW5ncy52YXVsdFBhdGggKyBmaWxlLnBhdGhcbiAgICAgICAgbGV0IHN0b3JhZ2VfcGF0aCA9IHBsdWdpbl9wYXRoICsgJy9tb2RpZmllZF9wYXRocy5qc29uJ1xuICAgICAgICBpZiAodHlwZSA9PSBGaWxlVHlwZS5tb2RpZmllZCl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHsnY2hhbmdlX3R5cGUnOiBGaWxlVHlwZS5tb2RpZmllZCwgJ2Z1bGxfcGF0aCc6IGZpbGVfcGF0aH0gXG4gICAgICAgICAgICBhcHBlbmRfdG9fanNvbihzdG9yYWdlX3BhdGgsIGJhc2VfbmFtZSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBGaWxlVHlwZS5kZWxldGVkKXtcblxuICAgICAgICAgICAgbmV3IE5vdGljZShgJHtiYXNlX25hbWV9IGhhcyBiZWVuIGRlbGV0ZWRgKVxuICAgICAgICAgICAgbGV0IHZhbHVlID0geydjaGFuZ2VfdHlwZSc6IEZpbGVUeXBlLmRlbGV0ZWQsICdmdWxsX3BhdGgnOiBmaWxlX3BhdGh9IFxuICAgICAgICAgICAgYXBwZW5kX3RvX2pzb24oc3RvcmFnZV9wYXRoLCBiYXNlX25hbWUsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICAgIC8vdG9kbyBubyBuZWVkIHRvIHRyYWNrIG5ldyBmaWxlcyBzaW5jZSB0aGV5IG9ubHkgY291bnQgd2hlbiBtb2RpZmllZCBhbnl3YXlzP1xuICAgICAgICAvL3RvZG8gY291bGQgYmUgdXNlZnVsIG9ubHksIGlmIEkgbWFrZSBzdXJlIG5vdCB0byBvdmVyd3JpdGUgJ21vZGlmaWVkX3BhdGhzJyBieSBtb2RpZmllZCBpZiBuZXcgYWxyZWFkeSBleGlzdHMuIFRoZW4gdXNlIHRoYXQgdG8gYXZvaWQgdXNlbGVzcyBzZWFyY2ggaWYgYSBuZXcgZmlsZSBleGlzdCBhbHJlYWR5IGluIG91ciBpbmRleGVkIGRhdGFiYXNlXG4gICAgICAgIC8vdG9kbyBpZiBJIGRlY2lkZWQgZm9yIHllcywgYWRkIGFuIGV2ZW50bGlzdGVudCBpbiBvbmxvYWRcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBGaWxlVHlwZS5uZXcpe1xuICAgICAgICAgICAgbmV3IE5vdGljZShgJHtiYXNlX25hbWV9IGhhcyBiZWVuIGNyZWF0ZWRgKVxuICAgICAgICAgICAgbGV0IHZhbHVlID0geydjaGFuZ2VfdHlwZSc6IEZpbGVUeXBlLm5ldywgJ2Z1bGxfcGF0aCc6IGZpbGVfcGF0aH1cbiAgICAgICAgICAgIGFwcGVuZF90b19qc29uKHN0b3JhZ2VfcGF0aCwgYmFzZV9uYW1lLCB2YWx1ZSlcblxuICAgICAgICB9XG5cblxuICAgIH1cbiAgICBhc3luYyBpbmRleF9uZXdfYW5kX21vZGlmaWVkX2ZpbGVzKCl7XG4gICAgICAgIGNvbnN0IHBsdWdpbl9wYXRoID0gc2NyaXB0UGF0aF9BSVxuICAgICAgICBsZXQgc3RvcmFnZV9wYXRoID0gcGx1Z2luX3BhdGggKyAnL21vZGlmaWVkX3BhdGhzLmpzb24nXG4gICAgICAgIGZzLnJlYWRGaWxlKHN0b3JhZ2VfcGF0aCwgYXN5bmMgKGVyciwgZGF0YTogYW55KSA9PiB7XG4gICAgICAgICAgICBpZihlcnIpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGxldCBmaWxlc190b19tb2RpZnkgXG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiV2lsbCByZWFkIGNoYW5nZWQgZmlsZXMgbm93Li5cIilcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzLnNldFRleHQoJ1x1RDgzRVx1REREOTogVkMgV2l6YXJkIGluZGV4aW5nLi4uJylcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoJ3RpdGxlJywgJ1dpemFyZCBpcyBpbmRleGluZyB5b3VyIHZhdWx0Li4uJylcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgIGZpbGVzX3RvX21vZGlmeSA9IEpTT04ucGFyc2UoZGF0YSlcbiAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGZpbGVzX3RvX21vZGlmeSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKXtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIk5vIG5ldyBub3RlcyB0byBpbmRleFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KCdcdUQ4M0VcdURERDk6IFZDIFdpemFyZCByZWFkeScpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoJ3RpdGxlJywgJ1ZDIFdpemFyZCBpcyByZWFkeScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhmaWxlc190b19tb2RpZnkpLmxlbmd0aCA8IDEpe1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJObyBuZXcgbm90ZXMgdG8gaW5kZXhcIilcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KCdcdUQ4M0VcdURERDk6IFZDIFdpemFyZCByZWFkeScpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cigndGl0bGUnLCAnVkMgV2l6YXJkIGlzIHJlYWR5JylcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5kZXhfZmlsZXMoc3RvcmFnZV9wYXRoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpe1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaW5kZXhpbmchXCIpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMuc2V0VGV4dCgnXHVEODNFXHVEREQ5OiBWQyBXaXphcmQgcmVhZHknKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoJ3RpdGxlJywgJ1ZDIFdpemFyZCBpcyByZWFkeScpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9FbXB0eSB0aGUgbW9kaWZpZWQgZmlsZVxuICAgICAgICAgICAgbmV3IE5vdGljZShcIkZpbmlzaGVkIGluZGV4aW5nIVwiKVxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhzdG9yYWdlX3BhdGgpXG4gICAgICAgICAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KCdcdUQ4M0VcdURERDk6IFZDIFdpemFyZCByZWFkeScpXG4gICAgICAgICAgICB0aGlzLnN0YXR1cy5zZXRBdHRyKCd0aXRsZScsICdWQyBXaXphcmQgaXMgcmVhZHknKVxuICAgICAgICAgICAgc2F2ZV9qc29uKHN0b3JhZ2VfcGF0aCwge30pXG5cbiAgICAgICAgfSlcbiAgICBcbiAgICB9XG5cbiAgICBhc3luYyBpbmRleF92YXVsdCgpe1xuICAgICAgICBsZXQgZmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKClcbiAgICAgICAgbGV0IGZpbGVfcGF0aHM6IGFueSA9IHt9XG4gICAgICAgIGxldCB2YXVsdF9wYXRoID0gdGhpcy5zZXR0aW5ncy52YXVsdFBhdGhcbiAgICAgICAgY29uc3QgcGx1Z2luX3BhdGggPSBzY3JpcHRQYXRoX0FJXG4gICAgICAgIG5ldyBOb3RpY2UoXCJTdGFydGVkIGluZGV4aW5nIHRoZSBmdWxsIHZhdWx0IVwiKVxuICAgICAgICB0aGlzLnN0YXR1cy5zZXRUZXh0KCdcdUQ4M0VcdURERDk6IFZDIFdpemFyZCBpbmRleGluZy4uLicpXG4gICAgICAgIHRoaXMuc3RhdHVzLnNldEF0dHIoJ3RpdGxlJywgJ1dpemFyZCBpcyBpbmRleGluZyB5b3VyIHZhdWx0Li4uJylcbiAgICAgICAgZm9yKGxldCBmaWxlIG9mIGZpbGVzKXtcbiAgICAgICAgICAgIGlmIChmaWxlLnBhdGguaW5jbHVkZXMoJ1JlYWR3aXNlJykpeyAgXG4gICAgICAgICAgICAgICAgZmlsZV9wYXRoc1tmaWxlLmJhc2VuYW1lXSA9IHsnY2hhbmdlX3R5cGUnOiBGaWxlVHlwZS5uZXcsJ2Z1bGxfcGF0aCc6IHZhdWx0X3BhdGggKyBmaWxlLnBhdGh9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coYEZpbGVzIGxlbmd0aDogJHtmaWxlX3BhdGhzLmxlbmd0aH1gKVxuICAgICAgICBjb25zdCBqc29uX3BhdGggPSBwbHVnaW5fcGF0aCArICcvJyArICdmaWxlX3BhdGhzLmpzb24nXG4gICAgICAgIHNhdmVfanNvbihqc29uX3BhdGgsIGZpbGVfcGF0aHMpXG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5kZXhfZmlsZXMoanNvbl9wYXRoKVxuXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpe1xuICAgICAgICAgICAgbmV3IE5vdGljZShcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBpbmRleGluZyFcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXcgTm90aWNlKFwiRmluaXNoZWQgaW5kZXhpbmchXCIpXG4gICAgICAgIHRoaXMuc3RhdHVzLnNldFRleHQoJ1x1RDgzRVx1REREOTogVkMgV2l6YXJkIHJlYWR5JylcbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cigndGl0bGUnLCAnVkMgV2l6YXJkIGlzIHJlYWR5JylcbiAgICAgICAgc2F2ZV9qc29uKGpzb25fcGF0aCwge30pXG5cbiAgICAgICAgXG4gICAgICAgIFxuXG4gICAgfVxuXG4gICAgYXN5bmMgaW5kZXhfZmlsZXMoanNvbl9wYXRoOiBzdHJpbmcpe1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kZXggYWxsIHRoZSBmaWxlcyB3aG8gcGF0aHMgaXMgc2F2ZWQgaW4ganNvbl9wYXRoXG4gICAgICAgICAqL1xuICAgICAgICBcbiAgICAgICAgbGV0IHNjcmlwdFBhdGggPSBzY3JpcHRQYXRoX0FJXG4gICAgICAgIGNvbnN0IHNjcmlwdE5hbWUgPSAnaW5kZXhfdmF1bHQucHknXG4gICAgICAgIGNvbnN0IHBsdWdpbl9wYXRoID0gc2NyaXB0UGF0aF9BSVxuICAgICAgICBcbiAgICAgICAgdmFyIGFyZ3MgPSBbanNvbl9wYXRoLCBvcGVuYWlBUElLZXksIHBsdWdpbl9wYXRoXVxuXG5cbiAgICAgICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBsYXVuY2hfcHl0aG9uKHB5dGhvblBhdGgsIHNjcmlwdFBhdGgsIHNjcmlwdE5hbWUsIGFyZ3MpXG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpXG4gICAgICAgIHRoaXMuc3RhdHVzLnNldFRleHQoJ1x1RDgzRVx1REREOTogVkMgV2l6YXJkIHJlYWR5JylcbiAgICAgICAgdGhpcy5zdGF0dXMuc2V0QXR0cigndGl0bGUnLCAnVkMgV2l6YXJkIGlzIHJlYWR5JylcbiAgICAgICAgcmV0dXJuIHJlc3VsdHNcbiAgICB9XG4gICAgYXN5bmMgZXh0cmFjdF90aXRsZV9hbmRfcGF0aChyZXN1bHRzOiBzdHJpbmdbXSl7XG4gICAgICAgIFxuICAgICAgICAvL2NvbnNvbGUubG9nKGFsbF9maWxlcylcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwXG4gICAgICAgIGxldCBzZWFyY2hfcmVzdWx0czogYW55ID0ge30gLy97J3NlbnRlbmNlcyc6IFtdLCAnc291cmNlX25hbWUnOiBbXSwgJ3NvdXJjZV9wYXRoJzogW119XG4gICAgICAgIGxldCBjdXJyZW50X2ZpbGVuYW1lID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKT8uYmFzZW5hbWVcbiAgICAgICAgY29uc29sZS5sb2coYGN1cnJlbnQgZmlsZW5hbWU6ICR7Y3VycmVudF9maWxlbmFtZX1gKVxuICAgICAgICBmb3IgKGxldCByZXN1bHQgb2YgcmVzdWx0cyl7XG4gICAgICAgICAgaWYgKGNvdW50ZXIgJSAzID09IDAgJiYgY291bnRlciE9IDApXG4gICAgICAgICAge1xuICAgICAgICAgICAgbGV0IHNlbnRlbmNlID0gJ1xcXCInICsgcmVzdWx0cy5hdChjb3VudGVyKSArICdcXFwiJ1xuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IHJlc3VsdHMuYXQoY291bnRlcisyKVxuICAgICAgICAgICAgc291cmNlID0gc291cmNlPy5zcGxpdCgnOicpWzFdLnRyaW0oKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgY291bnRlcjogJHtjb3VudGVyfSwgVGhpcyBzb3VyY2U6ICR7c291cmNlfWApXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHNvdXJjZSA9PSBjdXJyZW50X2ZpbGVuYW1lKXtcbiAgICAgICAgICAgICAgICAvL0RvIG5vdCBhZGQgcmVzdWx0cyBmcm9tIHRoZSBjdXJyZW50IGZpbGVcbiAgICAgICAgICAgICAgICBjb3VudGVyID0gY291bnRlciArIDFcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNvdXJjZV9maWxlID0gYXdhaXQgdGhpcy5nZXRfcGF0aF9ieV9uYW1lKHNvdXJjZSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHNvdXJjZV9maWxlKVxuICAgICAgICAgICAgaWYgKHNvdXJjZV9maWxlICE9IG51bGwgJiYgc291cmNlICE9IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IG9ic2lkaWFuX3BhdGggPSAnb2JzaWRpYW46Ly9hZHZhbmNlZC11cmk/dmF1bHQ9JyAvL29wZW4gLSBhZHZhbmNlZC11cmlcbiAgICAgICAgICAgICAgICBvYnNpZGlhbl9wYXRoID0gb2JzaWRpYW5fcGF0aCArIHRoaXMuYXBwLnZhdWx0LmdldE5hbWUoKSArICcmZmlsZXBhdGg9JyAvL2ZpbGUgLSBmaWxlcGF0aFxuICAgICAgICAgICAgICAgIC8vbGV0IHNvdXJjZV9wYXRoID0gc291cmNlX2ZpbGUucGF0aCAvL3RoaXMuYXBwLnZhdWx0LmdldFJlc291cmNlUGF0aChzb3VyY2VfZmlsZSlcbiAgICAgICAgICAgICAgICBvYnNpZGlhbl9wYXRoID0gb2JzaWRpYW5fcGF0aCArIHNvdXJjZV9maWxlLnBhdGhcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgbXkgc291cmNlIHBhdGg6ICR7b2JzaWRpYW5fcGF0aH1gKVxuICAgICAgICAgICAgICAgIHNlYXJjaF9yZXN1bHRzW3NvdXJjZV0gPSB7J3NvdXJjZV9wYXRoJzpvYnNpZGlhbl9wYXRoLCAndGV4dCc6IHNlbnRlbmNlfSBcblxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgfVxuICAgIFxuICAgICAgICAgIGNvdW50ZXIgPSBjb3VudGVyICsgMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWFyY2hfcmVzdWx0c1xuICAgIH1cbiAgICBhc3luYyBnZXRfcGF0aF9ieV9uYW1lKHNvdXJjZTogc3RyaW5nfHVuZGVmaW5lZCl7XG4gICAgICAgIGxldCBhbGxfZmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKClcbiAgICAgICAgZm9yIChsZXQgZmlsZSBvZiBhbGxfZmlsZXMpe1xuICAgICAgICAgICAgbGV0IGZpbGVuYW1lID0gZmlsZS5iYXNlbmFtZVxuICAgICAgICAgICAgaWYgKGZpbGVuYW1lID09IHNvdXJjZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbFxuXG5cbiAgICB9XG59XG5cbmNsYXNzIFNhbXBsZVNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFie1xuICAgIHBsdWdpbjogVkNXaXphcmRQbHVnaW5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBWQ1dpemFyZFBsdWdpbil7XG4gICAgICAgIHN1cGVyKGFwcCwgcGx1Z2luKVxuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpblxuICAgIH1cbiAgICBkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKCdoMicsIHt0ZXh0OiAnU2V0dGluZ3MgZm9yIHlvdXIgYnV0bGVyJ30pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnT2JzaWRpYW4gVmF1bHQgUGF0aCcpXG5cdFx0XHQuc2V0RGVzYygnVGhlIHBhdGggdG8gdGhlIHZhdWx0IHdoZXJlIHlvdSB3aXNoIHRvIHVzZSB0aGUgcGx1Z2luJylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHBhdGgnKVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudmF1bHRQYXRoKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ3BhdGg6ICcgKyB2YWx1ZSk7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MudmF1bHRQYXRoID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdH0pKTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKCdPcGVuQUkgQVBJIEtleScpXG4gICAgICAgIC5zZXREZXNjKCdZb3VyIE9wZW5BSSBBUEkgS2V5JylcbiAgICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIGtleScpXG4gICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Mub3BlbkFJS2V5KVxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdPcGVuIEFJIGtleTogJyArIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5vcGVuQUlLZXkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgIC5zZXROYW1lKCdBZmZpbml0eTogQVBJIEtleScpXG4gICAgICAgIC5zZXREZXNjKCdZb3VyIEFmZmluaXR5IEFQSSBLZXknKVxuICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignRW50ZXIga2V5JylcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5hZmZpbml0eUtleSlcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygna2V5OiAnICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmFmZmluaXR5S2V5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZSgnQWZmaW5pdHk6IE93bmVyIFZhbHVlJylcbiAgICAgICAgLnNldERlc2MoJ0V2ZXJ5IHBlcnNvbiBoYXMgYSBjb2RlIG9uIEFmZmluaXR5LiBQbGVhc2UgZ2l2ZSBpbiB0aGUgY29kZSBmb3IgdGhlIHBlcnNvbiB0aGF0IHNob3VsZCBiZSBhZGRlZCBhcyBvd25lciBvZiBzdGFydHVwcyBhbmQgVkNzIHRoYXQgZ2V0cyBwdXNoZWQnKVxuICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignRW50ZXIgdmFsdWUnKVxuICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm93bmVyX3BlcnNvbl92YWx1ZSlcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnT3duZXIgdmFsdWU6ICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Mub3duZXJfcGVyc29uX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZSgnQWZmaW5pdHk6IENvbm5lY3Rpb24gT3duZXIgRmllbGQgSUQnKVxuICAgICAgICAuc2V0RGVzYygnRGVwZW5kaW5nIG9uIHRoZSBsaXN0IHlvdSBzYXZlIGZlbGxvdyBWQ3MgaW4sIHRoZXJlIGlzIGEgZmllbGQgdGhhdCByZXByZXNlbnQgdGhlIFxcJ2Nvbm5lY3Rpb24gb3duZXIgd2l0aCB0aGUgZnVuZFxcJywgZW50ZXIgdGhlIGZpZWxkIGlkIGhlcmUnKVxuICAgICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcignRW50ZXIgdmFsdWUnKVxuICAgICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbm5lY3Rpb25fb3duZXJfZmllbGRfaWQpXG4gICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24gT3duZXIgRmllbGQgSUQgdmFsdWU6ICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY29ubmVjdGlvbl9vd25lcl9maWVsZF9pZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoJ0FmZmluaXR5OiBWZW50dXJlIE5ldHdvcmsgTGlzdCBJRCcpXG4gICAgICAgIC5zZXREZXNjKCdQbGVhc2UgZW50ZXIgdGhlIGxpc3QgaWQgZm9yIHRoZSBsaXN0IHlvdSBzYXZlIHlvdXIgcmVsYXRpb25zaGlwcyB3aXRoIFZDcyBpbicpXG4gICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdFbnRlciB2YWx1ZScpXG4gICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudmVudHVyZV9uZXR3b3JrX2xpc3RfaWQpXG4gICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1ZlbnR1cmUgbmV0d29yayBsaXN0IGlkOiAnICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnZlbnR1cmVfbmV0d29ya19saXN0X2lkID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZSgnUHl0aG9uIFZpcnR1YWwgRW52aXJvbm1lbnQgUGF0aCcpXG4gICAgICAgIC5zZXREZXNjKCdUaGUgcGF0aCB0byBweXRob24gdmlydHVhbCBlbnZpcm9ubWVudCcpXG4gICAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdFbnRlciBwYXRoJylcbiAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5weXRob25QYXRoKVxuICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQeXRob25QYXRoOiAnICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnB5dGhvblBhdGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgIH0pKTtcblx0fVxuXG59IiwgImltcG9ydCB7IEl0ZW1WaWV3LCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmV4cG9ydCBjb25zdCBXSVpBUkRfVklFVyA9IFwid2l6YXJkLXZpZXdcIjtcblxuZXhwb3J0IGNsYXNzIFdpemFyZFZpZXcgZXh0ZW5kcyBJdGVtVmlldyB7XG4gIGNvbnN0cnVjdG9yKGxlYWY6IFdvcmtzcGFjZUxlYWYpIHtcbiAgICBzdXBlcihsZWFmKTtcbiAgICB0aGlzLmljb24gPSAnc3VuJ1xuICB9XG5cbiAgZ2V0Vmlld1R5cGUoKSB7XG4gICAgcmV0dXJuIFdJWkFSRF9WSUVXO1xuICB9XG5cbiAgZ2V0RGlzcGxheVRleHQoKSB7XG4gICAgcmV0dXJuIFwiRXhhbXBsZSB2aWV3XCI7XG4gIH1cblxuICBhc3luYyBvbk9wZW4oKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXJFbC5jaGlsZHJlblsxXTtcbiAgICBjb250YWluZXIuZW1wdHkoKTtcbiAgICBjb250YWluZXIuY3JlYXRlRWwoXCJoNFwiLCB7dGV4dDogXCJSZWxhdGVkIElkZWFzXCIsIGNsczogXCJoZWFkaW5nXCJ9KTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZShzZWFyY2hfcmVzdWx0czogYW55KXsgLy9cbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lckVsLmNoaWxkcmVuWzFdO1xuICAgIC8vY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHt0ZXh0OiBcIkhlbGxvIFdvcmxkXCJ9KVxuICAgIGNvbnRhaW5lci5lbXB0eSgpXG4gICAgY29uc3Qgb3V0ZXJEaXYgPSBjb250YWluZXIuY3JlYXRlRWwoXCJoNFwiLCB7dGV4dDogXCJSZWxhdGVkIElkZWFzXFxuXCIsIGNsczogXCJoZWFkaW5nXCJ9KTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzZWFyY2hfcmVzdWx0cyl7XG5cbiAgICAgIGxldCBzb3VyY2VfbmFtZSA9IGtleVxuICAgICAgbGV0IHNvdXJjZV9wYXRoID0gc2VhcmNoX3Jlc3VsdHNba2V5XVsnc291cmNlX3BhdGgnXVxuICAgICAgbGV0IHRleHQgPSBzZWFyY2hfcmVzdWx0c1trZXldWyd0ZXh0J11cbiAgICAgIGNvbnN0IHF1b3RlID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiYmxvY2txdW90ZVwiLCB7dGV4dDogdGV4dCwgY2xzOiBcInF1b3RlXCJ9KVxuICAgICAgY29uc3QgbGluayA9IHF1b3RlLmNyZWF0ZUVsKFwiYVwiLCB7IGhyZWY6IHNvdXJjZV9wYXRoLCBhdHRyOiB7IFwiZGF0YS1wYXRoXCI6IHNvdXJjZV9wYXRoIH0gfSk7XG4gICAgICBsaW5rLmNyZWF0ZUVsKFwic3BhblwiLCB7ICAgXG4gICAgICAgICAgICAgICAgICB0ZXh0OiAnXFxuLS0nICsgc291cmNlX25hbWUgXG4gICAgICAgICAgfVxuICAgICAgKTtcblxuXG5cbiAgICB9XG5cbiAgICAvL2NvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7dGV4dDogcmVzdWx0cy5hdCgwKX0pXG4gICAgLy9vdXRlckRpdi5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IFwiXCIgfSk7XG4gICAgLy9vdXRlckRpdi5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJvdXRnb2luZy1saW5rLWhlYWRlclwiLCB0ZXh0OiBcIlx1MjZGMFwiIH0pO1xuICAgIFxuXG4gIH1cblxuICBhc3luYyBvbkNsb3NlKCkge1xuICAgIC8vIE5vdGhpbmcgdG8gY2xlYW4gdXAuXG4gIH1cbn0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFFBQUEsV0FBQSxRQUFBO0FBQ0EsUUFBQSxrQkFBQSxRQUFBO0FBQ0EsUUFBQSxPQUFBLFFBQUE7QUFDQSxRQUFBLFNBQUEsUUFBQTtBQUNBLFFBQUEsV0FBQSxRQUFBO0FBQ0EsUUFBQSxPQUFBLFFBQUE7QUFDQSxRQUFBLFNBQUEsUUFBQTtBQUVBLHFCQUFvQixRQUFnQjtBQUNoQyxVQUFJLE9BQU8sV0FBVyxlQUFlLFdBQVcsTUFBTTtBQUNsRCxlQUFPLENBQUE7aUJBQ0EsQ0FBQyxNQUFNLFFBQVEsTUFBTSxHQUFHO0FBQy9CLGVBQU8sQ0FBQyxNQUFNOztBQUVsQixhQUFPO0lBQ1g7QUFLQSxvQkFBZ0IsUUFBWSxNQUFJO0FBQzVCLFlBQU0sVUFBVSxNQUFNLEtBQUssV0FBVyxDQUFDLEVBQUUsUUFBUSxTQUFVLFFBQU07QUFDN0QsWUFBSSxRQUFRO0FBQ1IsbUJBQVMsT0FBTyxRQUFRO0FBQ3BCLGdCQUFJLE9BQU8sT0FBTzs7O01BRzlCLENBQUM7QUFDRCxhQUFPO0lBQ1g7QUFLQSw0QkFBcUI7QUFDakIsYUFBTyxLQUFLLE1BQU0sS0FBSyxPQUFNLElBQUssSUFBVztJQUNqRDtBQUVBLFFBQU0sY0FBYyxJQUFBLE9BQUEs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
